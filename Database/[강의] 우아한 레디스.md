# 우아한 레디스

[[우아한 테크 세미나] 우아한 레디스](https://www.youtube.com/watch?v=mPB2CZiAkKM)

## Redis 운영

### 메모리 관리

- 큰 메모리를 사용하는 instance 하나보다는 적은 메모리를 사용하는 instance 여러 개가 안전하다.

  24 GB < 8 + 8 + 8 GB

- Write가 heavy 한 경우에는 최대 메모리를 2배까지 쓸 수 있다. 

  처음에 fork를 했을 때에는 copy on write라고 해서 read만 하면 복사하지 않고, write가 일어나면 복사해서 더 써야 함. 이론적으로는 1.몇배에서 2배까지 쓸 수 있음 

- 메모리를 나누어 놓으면 관리하기는 귀찮지만 운영의 안정성은 더 높아진다. 굳이 쓰고 있는 것을 바꿀 필요는 없다. 

- 메모리 파편화가 발생할 수 있다. 

  `max memory` 설정하더라도 allocator 구현에 따라서 성능이 왔다갔다 할 수 있다. (jemalloc 사용)

  레디스는 사용하고 있는 메모리 양을 정확하게 알 수 없다. 해제했다고 하지만, 붙잡고 있을 수도 있음.

  - 3.x대 버전의 경우 실제 used memory는 2GB로 보고되지만, 11GB의 RSS를 사용하는 경우가 자주 발생했다. 
  - 4.x 버전부터 메모리 파편화 줄이도록 jemalloc에 힌트 주는 기능이 들어갔으나 jemalloc 버전에 따라서 다르게 동작할 수 있다. 

- 다양한 사이즈를 가지는 데이터 보다는 유사한 크기의 데이터를 가지는 경우가 유리하다. 메모리 파편화를 덜 일어나게 한다. 

### 메모리가 부족할 때는

- 캐시는 다 돈이다.
  - 좀더 메모리가 많은 장비로 migration 
  - 메모리가 빡빡하면 migration 중에 문제가 발생할 수도 있음. 70% 이상 쓰고 있으면, 메모리 업그레이드를 고려해야 한다. 
- 있는 데이터를 줄이기
  - 데이터를 일정 수준에서만 사용하도록 특정 데이터를 줄인다.
  - 만약 이미 swap을 사용중이라면, 프로세스를 재시작해야 한다. 

### 메모리를 줄이기 위한 설정

- 기본적으로 collection들은 다음과 같은 자료구조를 사용한다. 

  - Hash는 내부적으로 hash table을 하나 더 쓴다. 

  - Sorted set은 skiplist와 Hash table을 사용한다. 

    값으로도 찾아야 하고, 인덱스로도 찾아야 하기 떄문

  - Set도 Hash Table 사용

  이 자료구조들은 우리가 생각하는 것보다 메모리를 많이 쓴다. 포인터 할당, 메모리 단편화 일어날 확률 증가. 

- ziplist

  아이템 개수를 한 컬렉션에 몇십개, 몇백개 사용한다면 ziplist를 쓰는게 속도는 조금 느려지더라도 메모리를 훨씬 적게 쓴다.

  자료구조를 저장할 때 원래 쓰는 구조 대신 내부적으로 ziplist를 쓰도록 설정 바꿔야 한다. 

### Ziplist 

- In memory 구조상, 적당한 사이즈까지는 특정 알고리즘을 안쓰고 선형 탐색을 하더라도 빠른 편이다. 

  퀵 소트 최적화를 보면, 알고리즘 잘 만드는 것도 중요하지만, 마지막 100개 이내에서는 insert search를 사용해서 소트 시키는게 빠르다고 한다.

- List, hash, sorted set 등을 ziplist로 대체해서 처리하는 설정이 존재한다.

  `{DS}-max-ziplist-entries` -> 개수 몇개까지는 ziplist를 쓰겠다. 

  `{DS}-max-ziplist-value` -> value 얼마까지는 쓰겠다. 

- 100개 정도로 원소가 적으면 알고리즘 쓰는것과 비슷하게 빠르다.

- 메모리 사용량 2-30% 차이까지 날 수 있다. 

### O(N) 관련 명령어는 주의하자.

- Redis는 Single threaded이다.

  - 동시에 처리할 수 있는 명령 개수는 한번에 1개임

  - 단순한 get/set의 경우 초당 10만 TPS 이상 가능 (CPU 속도에 영향을 받는다.)

    1개의 요청이 1초 걸린다면 최악의 경우 9만9999개의 명령은 1초동안 대기해야 함. 죄다 타임아웃 날것이다. 서비스 터질 수 있다.

- packet이 다음 순서로 들어온다.

  1. `processInputBuffer`
  2. `processCommand`

  Packet으로 하나의 command가 완성되면, `processCommand`에서 실제로 실행된다. 처리되는 동안에는 다른 패킷이 쌓인다. 패킷이 커맨드로 실행되어 루프에서 탈출해야 다음 패킷이 처리된다. 

- 대표적인 O(N) 명령들

  - KEYS - 모든 키 가져오기

    Key가 백만개 이상인데, 확인을 위해서 명령을 사용하는 경우 (모니터링 스크립트가 계속 호출)

    `scan` 이라는 명령으로 대체 가능. 짧은 여러 번의 명령 사용. 사이사이에 다른 명령이 실행될 수 있다. 

  - FLUSHALL, FLUSHDB

    데이터 다날리기. 

  - Delete collections

  - Get All Collections

    collection의 일부만 가져오자. Sorted set은 부분을 끊어 가져올 수 있음. 

    큰 Collection을 작은 여러 개의 Collection으로 나눠서 저장.

    Collection 한개당 몇천개 안쪽으로 저장하는 게 좋음. 

  - 예전의 Spring security oauth `RedisTokenStore`

    Access Token의 저장을 List(O(N)) 자료 구조를 통해서 이루어진다.

    - 검색, 삭제 시에 모든 item을 매번 찾아봐야 한다. 100만개 정도 되면 전체 성능에 영향.
    - 현재는 Set(O(1))을 이용해서 검색, 삭제를 하도록 수정되어 있다. 

- 가장 실수 많이 하는 이슈임. 