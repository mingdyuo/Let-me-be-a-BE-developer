영문으로 된 글을 읽으면, 같은 말이지만 다른 예시와 단어를 사용하여 반복적으로 설명하는 경향이 있는데, 이 책도 비슷한 서술 방식을 가지고 있다. 어떻게 보면 동어 반복을 하고 있다고 볼 수 있고, 어떻게 보면 그만큼 강조하고자 하는 내용이 단순하고 명확하다고 볼 수 있다. 그래서 정신을 놓고 읽으면 어디까지 읽었는지 무슨 말을 하고자 하는지 헷갈릴 수 있다. 

나는 처음에는 책 읽듯이 쭉 읽다가 중간부터는 필기를 하며 읽었다. 무슨 말이냐면, 예시와 설명 부분은 묶어서 표시를 하고 결국 이 문장을 통해 말하고자 하는 개념이 무엇인지 반복적으로 체크를 하며 읽었다. 그런식으로 여러번 나오는 설명을 마주하고, 개념화 하다 보면 필자가 말하고자 하는 객체의 행위와 책임이 자연스럽게 중요하다고 인식하게 되고 굳이 노력하지 않아도 머릿속에 그려진다. 같은 말을 어떻게 다르게 하는지 확인하며 더욱 이해하는 것이다. (하지만 동어반복이 좀 심하다는 생각도 했다.)





### 5장, 책임과 메시지

- 책임이 너무 구체적이라면 수행 방법을 제한시키고 객체가 자율적이지 못하게 된다.

- 책임이 너무 추상적이라면 협력의 의도를 명확하게 표현할 수 없다. 

- 책임은 '어떻게'를 정해주는 것이 아니라 '무엇을' 할지 정해주는 것이다.

  어떻게 할지는 객체의 자유이고, private한 영역이다.

- 객체끼리의 유일한 의사소통 방법은 메시지를 주고 받는 것이다. 메시지에는 수신자와 행동, 인자가 들어 있다.

- 다형성

  - 같은 메시지를 받았지만 그 메시지를 처리하는 방식이 다를 수 있다.
  - 그러나 보낸 사람 입장에서는 처리하는 방식이 다른 각 개체를 구별할 필요가 없다. 즉, 동일한 책임을 갖는 객체들이다.
  - 다형성은 이와 같이 동일한 책임/역할을 갖는 객체들이 서로 대체될 수 있음을 암시한다. 수신자의 종류를 캡슐화하는 것이다.
  - 송신자와 수신자 간의 관계가 서로 결합되지 않고, 메시지를 매개로 사용하며 결합도를 낮춘다.

- 송신자가 수신자에 대해 알아야 하는 정보는 단지 **수신자가 해당 메시지를 이해하고 처리할 수 있는지의 여부**뿐이다.

- 오해 부시기

  - 객체지향 애플리케이션은 클래스의 집합이 아니다 !
  - 클래스 간의 상속 관계가 객체 지향 설계의 핵심 메커니즘이 아니다 !
  - 중요한 것은 **객체들이 주고받는 메시지**이다.
  - 클래스는 단지 **동적인 객체들의 특성과 행위**를 **정적인 텍스트로 표현**하기 위해 사용하는 추상화 도구이다.
  
- 객체 내부의 데이터를 중심으로 클래스 설계 X

  협력이라는 문맥 내에서 데이터 조작에 필요한 오퍼레이션을 먼저 고려 O

- What/Who Cycle

  어떤 행위를 수행할지 결정 → 누가 그 행위를 수행할지 결정

  객체의 행위를 결정하는 것은 객체 자체의 속성이 아니다.

- TDD (책임주도설계)

  어떤 객체가 어떤 특성을 가지고 있다고 해서 반드시 그와 관련된 행위를 수행할 것이라고 가정하지 않음

  행위를 먼저 식별한 후에, 행위를 수행할 적절한 개체를 찾음

- 묻지 말고 시켜라 (데메테르 법칙)

  - 객체는 일을 시킬 때 다른 객체의 상태를 묻지 말아야 한다.
  - 단지 메시지를 전송하고, 받는 객체가 스스로의 상태에 따라 처리하도록 해라.
  - 그러려면 결국 메시지는 '어떻게 해라'가 아닌 '무엇을 해라'를 담고 있어야 한다.

### 인터페이스

- 특징 3가지

  1. 인터페이스의 사용법을 알면 내부 구조를 몰라도 된다.
  2. 인터페이스 자체를 건들지 않는 한 내부 구성이나 작동 방식을 변경해도 사용자에게 영향을 미치지 않는다.
  3. 대상이 변경되어도 동일한 인터페이스를 제공한다면 상호작용에 문제가 생기지 않는다.

- 공용 인터페이스와 사적 인터페이스로 나눌 수 있다.

- 관련된 원칙 3가지

  1. 좀 더 추상적인 인터페이스

     수신자의 자율성을 보장해준다. 

  2. 최소 인터페이스

     외부에서 사용할 필요가 없다면 최대한 노출하지 않는다.

  3. 인터페이스와 구현 간에 차이가 있다는 점을 인식

- 객체의 외부와 내부를 분리한다는 것  == 객체의 공용 인터페이스와 구현을 분리하는 것

- 훌륭한 객체는 구현을 모른 채여도 상관없이 인터페이스만 알면 쉽게 상호작용할 수 있는 것이다.

  인터페이스와 구현을 분리하는 게 왜 중요하냐면 **소프트웨어는 항상 변경되기 때문**이다.

  (그리고 나는 내가 만든 녀석을 언제든 변경할 수 있다는 생각을 디폴트로 가지고 있어야겠다.)

- 공용 인터페이스는 외부에서 전송 가능한 메시지의 집합이다.

<br>

### 캡슐화

- 캡슐화는 두 가지 관점에서 사용된다.
  1. 상태와 행위의 캡슐화
  2. 사적인 비밀의 캡슐화

### 결론

객체의 책임이 자율적이도록 해라. 

<br>

### 6장, 객체 지도

