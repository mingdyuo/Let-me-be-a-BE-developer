### 객체지향 원칙

- 바뀌는 부분은 캡슐화한다.

- 상속보다는 구성(composition)을 활용한다.

  서브클래스를 만들어서 행동을 상속받으면 컴파일시에 완전히 결정되어야 한다. 구성을 통해서 행동을 확장하면 실행중에 동적으로 행동을 설정할 수 있다.

- 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.

- 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.

- OCP : 클래스는 확장에 대해서는 열려 있고, 코드 변경에 대해서는 닫혀 있어야 한다.

<br>

### Strategy 패턴

- 알고리즘군을 정의하고 캡슐화

- 필요한 알고리즘군을 교환하며 사용할 수 있다. 

- 사용하는 클라이언트와 독립적으로 알고리즘 변경 가능

- 예제

  오리의 속성을 상속받은 → 모형 오리, 진짜 오리

  모형 오리는 꽥꽥거리기 대신 삑삑거리기를 해야 하고, 진짜 오리와 달리 날 수 없다.

  → 오리의 행동을 분리하여 행동 인터페이스로 만들고 그 행동을 또다시 분류하여 구현

  → 오리 기반 클래스는 행동 인터페이스를 가지고 있고, 자식클래스는 그 인터페이스를 상속받는다. 행동 인터페이스를 상속받아서 만든 구현 클래스 객체를 가지고 있어서 실제 알맞는 행위 가능

- 행위(메소드)도 클래스로 구분할 수 있다.

  행위도 상태를 가질 수 있다. 예를 들면 `fly()`라는 행위의 경우에는 속도, 가속도, 방향과 같은 상태를 가지고 있을 수 있고, 이 상태는 행위에 또다시 영향을 미칠 수 있다.

<br>

### 옵저버 패턴

- 신문사와 정기구독자의 관계와 비슷하다

- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 간다.

  자동으로 그 내용이 갱신된다.

  일대다 관계를 나타낸다.

- 신문사는 subject, 정기구독자는 observer이다.

- 상태를 저장하고 있는 지배적인 객체는 subject 객체이다. (subject 객체가 데이터의 주인이다.)

  observer 객체는 상태를 꼭 가지고 있을 필요가 없다. (subject 객체를 의존한다.)

- 여러 객체에서 동일한 데이터를 제어하도록 할 때 좋은 디자인 패턴이다

- 옵저버들에게 **연락을 돌리는 순서에 의존**하면 **절대 안된다.**

### 느슨한 결합

- 두 객체가 느슨하게 결합되어 있다는 것은, 두 객체간에 상호작용이 있지만 서로에 대해 잘 모른다는 것이다.

- 옵저버 패턴에서는 subject와 observer가 느슨하게 결합되어 있다. 다음과 같은 이점들이 있기 때문이다.

  1. subject는 옵저버에 대해서 구현된 정보를 알 필요가 없다. 단지 "옵저버 인터페이스를 구현한다"는 것만 알면 된다.

  2. 옵저버는 언제든 새로 추가, 삭제할 수 있다. 실행중이라도 무관하다

  3. 새로운 형식의 옵저버를 추가해도, subject를 변경할 필요가 없다.

  4. subject와 옵저버는 독립적으로 재사용할 수 있다.

  5. subject와 옵저버가 바뀌더라도 서로에게 영향을 미치지 않는다.

     ↪ 결국 객체 사이의 상호 의존성을 최소화시킨다 !

### 자바의 `java.util.Observable`

- 옵저버 디자인 패턴을 구현한 라이브러리다.
- 인터페이스가 아닌 클래스고, 활용도와 재사용성 측면에서 문제점이 있다.
  1. `Observable` 자체가 클래스이므로 서브클래스를 만들어야 하고, 이미 다른 super class를 확장하고 있다면 기능을 추가할 수 없다. 재사용성 X
  2. `Observable` 인터페이스라는 것이 없으므로 자바에 내장된 `Observer API`와 잘 맞는 클래스를 직접 구현하는 것이 불가능하다. `java.util`의 구현을 다른 구현으로 바꿀 수도 없다. (멀티 스레드로 구현하거나 이런 것이 안됨)
  3. `Observable` 클래스의 핵심 메소드를 외부에서 호출할 수 없다. `protected`로 선언되어 있기 때문. 상속받은 클래스만 호출이 가능하다.

<br>

### Decorator 패턴

- 객체에 추가적인 요건을 **동적으로 첨가**한다.

  마치 객체에 휘핑크림을 바르듯이

- 데코레이터의 형식은 그 데코레이터로 감싸는 객체의 형식과 같다.

  따라서 상속을 이용해서 형식을 맞춘다.

  그러나 목적은 **형식을 맞추는 것**이지, **행동을 물려받는 것**이 아니다.

- 상속이 아닌 구성의 방법을 사용했기 때문에 실행중에 데코레이터를 마음대로 조합해서 사용할 수 있다. 

- 새로운 행동을 추가할 때에도 기존 코드를 변경할 필요가 없다.

<br>

### Decorator 패턴의 단점 & 사용시 주의할 점

- 자잘한 클래스들이 많이 추가되어, 다른 사람의 입장에서 이해하기 힘든 디자인이 만들어질 수 있다.
- 특정 형식에 의존하는 클라이언트 코드 내에 데코레이터 패턴을 적용하면 안된다. 
- 구성 요소를 초기화 하는 데에 필요한 코드가 복잡해진다. 구성 요소 인스턴스만 만드는 것이 아니라, 많은 데코레이터로 감싸야 하기도 한다.

<br>

### Factory 패턴

