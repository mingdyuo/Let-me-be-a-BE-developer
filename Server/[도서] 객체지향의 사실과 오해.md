영문으로 된 글을 읽으면, 같은 말이지만 다른 예시와 단어를 사용하여 반복적으로 설명하는 경향이 있는데, 이 책도 비슷한 서술 방식을 가지고 있다. 어떻게 보면 동어 반복을 하고 있다고 볼 수 있고, 어떻게 보면 그만큼 강조하고자 하는 내용이 단순하고 명확하다고 볼 수 있다. 그래서 정신을 놓고 읽으면 어디까지 읽었는지 무슨 말을 하고자 하는지 헷갈릴 수 있다. 

나는 처음에는 책 읽듯이 쭉 읽다가 중간부터는 필기를 하며 읽었다. 무슨 말이냐면, 예시와 설명 부분은 묶어서 표시를 하고 결국 이 문장을 통해 말하고자 하는 개념이 무엇인지 반복적으로 체크를 하며 읽었다. 그런식으로 여러번 나오는 설명을 마주하고, 개념화 하다 보면 필자가 말하고자 하는 객체의 행위와 책임이 자연스럽게 중요하다고 인식하게 되고 굳이 노력하지 않아도 머릿속에 그려진다. 같은 말을 어떻게 다르게 하는지 확인하며 더욱 이해하는 것이다. 

(킹치만 paraphrasing이 좀 심해서 중간에 정신이 약간 혼미해질 수 있다.)





### 5장, 책임과 메시지

- 책임이 너무 구체적이라면 수행 방법을 제한시키고 객체가 자율적이지 못하게 된다.

- 책임이 너무 추상적이라면 협력의 의도를 명확하게 표현할 수 없다. 

- 책임은 '어떻게'를 정해주는 것이 아니라 '무엇을' 할지 정해주는 것이다.

  어떻게 할지는 객체의 자유이고, private한 영역이다.

- 객체끼리의 유일한 의사소통 방법은 메시지를 주고 받는 것이다. 메시지에는 수신자와 행동, 인자가 들어 있다.

- 다형성

  - 같은 메시지를 받았지만 그 메시지를 처리하는 방식이 다를 수 있다.
  - 그러나 보낸 사람 입장에서는 처리하는 방식이 다른 각 개체를 구별할 필요가 없다. 즉, 동일한 책임을 갖는 객체들이다.
  - 다형성은 이와 같이 동일한 책임/역할을 갖는 객체들이 서로 대체될 수 있음을 암시한다. 수신자의 종류를 캡슐화하는 것이다.
  - 송신자와 수신자 간의 관계가 서로 결합되지 않고, 메시지를 매개로 사용하며 결합도를 낮춘다.

- 송신자가 수신자에 대해 알아야 하는 정보는 단지 **수신자가 해당 메시지를 이해하고 처리할 수 있는지의 여부**뿐이다.

- 오해 부시기

  - 객체지향 애플리케이션은 클래스의 집합이 아니다 !
  - 클래스 간의 상속 관계가 객체 지향 설계의 핵심 메커니즘이 아니다 !
  - 중요한 것은 **객체들이 주고받는 메시지**이다.
  - 클래스는 단지 **동적인 객체들의 특성과 행위**를 **정적인 텍스트로 표현**하기 위해 사용하는 추상화 도구이다.
  
- 객체 내부의 데이터를 중심으로 클래스 설계 X

  협력이라는 문맥 내에서 데이터 조작에 필요한 오퍼레이션을 먼저 고려 O

- What/Who Cycle

  어떤 행위를 수행할지 결정 → 누가 그 행위를 수행할지 결정

  객체의 행위를 결정하는 것은 객체 자체의 속성이 아니다.

- TDD (책임주도설계)

  어떤 객체가 어떤 특성을 가지고 있다고 해서 반드시 그와 관련된 행위를 수행할 것이라고 가정하지 않음

  행위를 먼저 식별한 후에, 행위를 수행할 적절한 개체를 찾음

- 묻지 말고 시켜라 (데메테르 법칙)

  - 객체는 일을 시킬 때 다른 객체의 상태를 묻지 말아야 한다.
  - 단지 메시지를 전송하고, 받는 객체가 스스로의 상태에 따라 처리하도록 해라.
  - 그러려면 결국 메시지는 '어떻게 해라'가 아닌 '무엇을 해라'를 담고 있어야 한다.

### 인터페이스

- 특징 3가지

  1. 인터페이스의 사용법을 알면 내부 구조를 몰라도 된다.
  2. 인터페이스 자체를 건들지 않는 한 내부 구성이나 작동 방식을 변경해도 사용자에게 영향을 미치지 않는다.
  3. 대상이 변경되어도 동일한 인터페이스를 제공한다면 상호작용에 문제가 생기지 않는다.

- 공용 인터페이스와 사적 인터페이스로 나눌 수 있다.

- 관련된 원칙 3가지

  1. 좀 더 추상적인 인터페이스

     수신자의 자율성을 보장해준다. 

  2. 최소 인터페이스

     외부에서 사용할 필요가 없다면 최대한 노출하지 않는다.

  3. 인터페이스와 구현 간에 차이가 있다는 점을 인식

- 객체의 외부와 내부를 분리한다는 것  == 객체의 공용 인터페이스와 구현을 분리하는 것

- 훌륭한 객체는 구현을 모른 채여도 상관없이 인터페이스만 알면 쉽게 상호작용할 수 있는 것이다.

  인터페이스와 구현을 분리하는 게 왜 중요하냐면 **소프트웨어는 항상 변경되기 때문**이다.

  (그리고 나는 내가 만든 녀석을 언제든 변경할 수 있다는 생각을 디폴트로 가지고 있어야겠다.)

- 공용 인터페이스는 외부에서 전송 가능한 메시지의 집합이다.

<br>

### 캡슐화

- 캡슐화는 두 가지 관점에서 사용된다.
  1. 상태와 행위의 캡슐화
  2. 사적인 비밀의 캡슐화

### 결론

객체의 책임이 자율적이도록 해라. 

<br>

### 6장, 객체 지도

- 유스케이스 - 도메인 모델간의 관계

- 일련의 흐름은 객체들의 협력으로 이어진다. 그 출발점은 유스케이스

- 객체지향은 모든 것을 객체로 바라본다. 큰 객체는 작은 객체로 나뉘어 질 수 있다. 크기와 관계 없이 이런 각 객체는 메시지를 전송하거나 수신할 수 있으며, 그 메시지에 응답하기 위해서 자율적으로 메소드를 선택할 수 있다.

  building block의 재귀적인 합성(composition) !

- 안정적인 도메인 모델을 기반으로 구현하면, 시스템의 기능이 변경되더라도 핵심 비즈니스 로직이 변경되지 않는 이상 전체적인 구조가 흔들리지 않는다.



5장까지는 그래도 대부분 이해하며 읽었는데 여기부터는 약간 난해하게 느껴진다 내공이 부족한 탓인겠지...? 조만간 다시 읽어봐야겠다.

<br>

### 7장, 함께 모으기

- 중요한 참고 사항

  1. 머릿속으로만 구상한 설계는 코드로 구현하는 단게에서 대부분 변경된다. 설계 작업은 구현을 위한 스케치를 작성하는 단계지 구현 그 자체가 아님

     중요한 것은 설계가 아니라 코드이며, 협력을 구상하는 단계에 너어어무 오랜 시간을 쏟지 말고 빨리 구현하면서 설계에 이상이 없는지, 설계가 구현 가능한지 판단해야 한다. 

     코드를 통해 피드백하며 깔끔한 설계를 얻을 수 있다.

  2. 객체에게 책임을 할당하고 인터페이스를 결정할 때에는 가급적 객체 내부의 구현에 대한 어떤 가정도 하지 말아야 한다. 객체의 속성과 그 속성이 어떤 자료 구조로 구현되었는지를 고려하지 않는 것이다.

     이렇게 해야 인터페이스와 구현을 깔끔하게 분리할 수 있다.

- 코드는 세 가지 관점을 모두 제공해야 한다.

  1. 개념 관점

  2. 명세 관점

     인터페이스는 구현에 대한 세부 사항을 노출해서는 안된다.

  3. 구현 관점

     클래스 내부의 속성과 구현은 변경이 되던 말던 절대 외부 객체에게 영향을 미쳐서는 안된다.

- **인터페이스와 구현을 분리해라 ! ! !** 

  명세 관점과 구현 관점이 뒤섞여지면 혼란스러워진다. 

<br>

### 부록 A 추상화 기법

- 추상화의 종류

  1. 분류와 인스턴스화
  2. 일반화와 특수화
  3. 집합과 분해

- 단일분류와 다중 분류

  단일 분류는 한 객체가 한 시점에 하나의 타입에만 속하는 것이다 (데스크톱 컴퓨터 / 노트북 컴퓨터)

  다중 분류는 한 객체가 한 시점에 여러 타입에 속할 수 있는 것이다. (데스크톱 컴퓨터이면서 사무용 컴퓨터)

- 대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다. 동시에 두 클래스의 인스턴스일 수 없다.

  (다중상속과 혼동하지 말자)

- 객체가 한 집합에서 다른 집합으로 속하는 타입을 변경할 수 있는 경우 동적분류라고 하며, 변경할 수 없는 경우 정적분류라고 한다. 대부분의 언어에서는 동적 분류를 구현할 수 없다. 한 객체 인스턴스의 타입은 변경될 수 없다.