# 데이터베이스

[KOCW 데이터베이스 강의](http://www.kocw.net/home/search/kemView.do?kemId=1064626)

- [x] 1차시 관계 대수와 SQL (21/06/01)
- [x] 2차시 관계 대수와 SQL (21/06/01)
- [x] 3차시 관계 대수와 SQL (21/06/01)
- [x] 3차시 관계 대수와 SQL 데이터베이스 설계와 ER 모델 (21/06/04)
- [x] 4차시 데이터베이스 설계와 ER 모델 (21/06/04)
- [ ] 5차시 데이터베이스 설계와 ER 모델
- [ ] 6차시 물리적 데이터베이스 설계
- [ ] 7차시 물리적 데이터베이스 설계
- [ ] 7차시 물리적 데이터베이스 설계, 릴레이션 정규화
- [ ] 8차시 릴레이션 정규화
- [ ] 9차시 릴레이션 정규화, 뷰와 시스템 카탈로그
- [ ] 10차시 뷰와 시스템 카탈로그
- [ ] 11차시 트랜잭션
- [ ] 12차시 트랜잭션
- [ ] 13차시 데이터베이스의 저장과 접근 : 해싱 빅테이터 관리 서론
- [ ] 14차시 빅테이터 관리 서론
- [ ] 15차시 NoSQL Database Patterns
- [ ] 15차시 NoSQL Database Patterns

<br>

### 공부 가능한 사이트

[SqlZoo](https://sqlzoo.net/)

[sql-ex](https://sql-ex.ru/)

<br>

## 관계 대수와 SQL

### 관계 대수

관계 데이터 모델에서 지원하는 두 가지 언어

1. 관계 해석 (relational caculus)
2. 관계 대수 (relational algebra)
   - 기존의 릴레이션으로부터 새로운 릴레이션을 생성
   - 피연산자와 연산이후의 결과 모두 릴레이션

- primitive operator : CPU가 바로 연산 가능

![image](https://user-images.githubusercontent.com/41130448/120252854-b02a3e80-c2c0-11eb-8300-e7b246a6e8a9.png)

- 세미 조인 - 반만 조인하는것?

- 카티션 곱 -> 양쪽의 튜플을 엮어서 가능한 모든 경우를 만드는 것

  튜플 수가 많은 경우 연산할때 시간이 겁나 많이 걸린다.

- Selection 연산자

  - 단항 연산자
  - 실렉션 조건을 predicate라고 한다. (true, false를 판단하는 기준)

- relation의 기본 원칙 : 모든 튜플들은 unique하다

- 임의의 relation으로 합집합을 만들 수는 없다. (의미가 없음)

  합집합 호환(union compatible)을 만족해야 한다.

  attribute의 수가 같고, 도메인이 같아야 함
  
- 프로젝션 할 때 중복 제거는 굉장히 오래걸리는 연산

  특별히 명령을 하지 않는 이상 중복이 허용되도록 연산이 이루어짐

- 카티션 곱

  임의의 두 릴레이션의 모든 가능한 조합을 만드는 릴레이션

  사용자가 실제로 원하는 것은 결과 릴레이션의 일부일 경우가 많다. 그래서 그 자체는 유용하지 않을 수 있다. 

  join을 하기 위한 연산이라서 중요한 것

- 관계 대수의 완전성

  관계 대수의 필수적인 연산자 : selection, projection, 합집합, 차집합, 카티션 곱 → 어떤 데이터 베이스 언어라도 이 연산자들은 꼭 표현할 수 있어야 한다.

  다른 관계 연산자 : 필수적인 관계 연산자를 두 개 이상 조합하여 표현 가능

  임의의 질의어가 적어도 필수적인 관계 대수 연산자들만큼의 표현력을 갖고 있으면 관계적으로 완전하다고 한다. (relationally complete)

- 조인 연산자

  두 개의 릴레이션으로 부터 **연관된 튜플**들을 결합함 (공통 attribute)

  릴레이션의 관계를 다루는 데에 매우 중요함

  종류

  → 세타 조인, 동등 조인(equi join), 자연 조인(natural join , 가장 많이 사용함), 외부 조인(outer join), 세미 조인

- 디비전 연산자

  나누어 지는 릴레이션이 나누는 릴레이션을 **모두** 포함하고 있어야 결과값에 포함됨

- 조인 연산은 disk에서 이루어지므로 시간이 많이 걸린다.

- 관계 대수의 한계

  - 산술 연산을 할 수 없음
  - 집단 함수 (aggregate function)을 지원하지 않음 (개별적인 검색만 가능, 통계 작업 불가)
  - 정렬을 나타낼 수 없음
  - 데이터베이스를 수정할 수 없음
  - 프로젝션의 연산 결과에 중복된 튜블을 나타내는 것이 필요할 때가 있는데 이를 명시하지 못함. 

- Data analysis

  그루핑하고, 통계 내는 것

  연도별, 부서별, 지역별 등등 다양한 기준을 가지고 한번에 그루핑하면 어렵다.

  multi dimension에서 dimension은 곧 attribute, 다차원의 경우 데이터가 많으므로 연산이 오래 걸림. 다 소팅해야 되기 때문에.

  그래서 수시로 하지 않고 주기적으로 정해놓고 가끔함

  이 분석을 batch로 (real-time으로) 처리하면 더 자주 작업을 진행할 수 있다.  

- 외부 조인

  left, right, full조인

  관련된 튜플은 모두 포함되고, 조인 조건을 만족하는 것을 넣는지 아닌지에 따라 나눔. 

<br>

### SQL

- SEQUEL부터 시작됨

- 비절차적 언어(선언적 언어)

  자신이 원하는 바만 명시, 처리하는 방법은 명시할 수 없음

- DBMS는 사용자가 SQL을 입력하면 그걸 번역해서 요구한 데이터를 찾아온다.

- 두 가지 인터페이스

  대화식(interactive), 내포된(embedded)

- 구성 요소

  데이터 정의어, 조작어, 제어어

- UPDATE DELETE INSERT

  릴레이션 하나에 대해서 수행됨. 단항 연산처럼

- SELECT

  여러 개의 릴레이션에 대해 수행 가능

- 데이터 정의어

  ![image](https://user-images.githubusercontent.com/41130448/120300552-015d2100-c307-11eb-9295-1839b1591830.png)

- 릴레이션, 도메인, 제약조건, 뷰, 권한 등을 그룹화하기 위해서 스키마 개념을 지원

  ```sql
  CREATE SCHEMA MY_DB AUTHORIZATION kim;
  
  DROP SCHEMA MY_DB RESTRICT; # 내부에 다른 릴레이션이 많이 존재하면 안삭제
  DROP SCHEMA MY_DB CASCADE; # 내부에 연결된 릴레이션 삭제
  ```

- 무결성 제약조건

  ```
  NOT NULL
  UNIQUE
  DEFAULT
  CHECK
  FOREIGN KEY REFERENCES
  ON
  (CASCADE UPDATE 등)
  ```

  DBMS 시스템 자체가 보장해주도록 설정할 수 있다.

  제약조건에 이름 붙혀서 추가 가능

  ```sql
  ALTER TABLE STUDENT ADD CONTRAINT STUDENT_PK
  	PRIMARY KEY(STNO);
  ```

- SELECT문

  정보를 검색하는 질의문

  관계 대수의 실렉션과 의미가 완전히 다르다.

  관계 대수의 실렉션, 프로젝션, 조인, 카티션 곱을 조합한 것

  ```sql
  SELECT [DISTINCT] ATTRIBUTES
  FROM RELATIONS
  [WHERE CONDITIONS]
  [GROUP BY ATTRIBUTES]
  [HAVING CONDITIONS]
  [ORDER BY ATTRIBUTES [ASC|DESC]];
  ```

- SIMILAR MATCH

  `%`를 사용

  ```SQL
  WHERE EMPNAME LIKE '이%' # 이씨 성을 갖는 사람 찾기
  ```

- 부정 검색 조건

  `<>`를 사용

  ```SQL
  WHERE DNO <> 1
  ```

- 리스트를 사용한 검색

  ```SQL
  WHERE DNO IN (1, 3)
  ```

- `NULL`과 비교를 하기 위해서는 `=`가 아닌 `IS`를 사용하자

  ```sql
  WHERE DNO IS NULL
  ```

- 집단 함수 - aggregate  function

  COUNT, SUM, AVG, MAX, MIN

- 그룹화

  `GROUP BY`절에 사용된 attribute에 동일한 값을 갖는 튜플들이 각각 하나의 그룹으로 묶임

  이 attribute를 그룹화 애트리뷰트 (grouping attribute)라고 한다.

  각 그룹에 대해서 하나의 튜플이 생성된다.

- HAVING

  그룹핑된 애트리뷰트에 조건 걸기

- 집합 연산

  UNION, EXCEPT, INTERSECT, UNION ALL, EXCEPT ALL, INTERSECT ALL

- 서브쿼리, 중첩 질의(NESTED QUERY)

  쿼리 속에 쿼리를 표현할 수 있다.

- SELF JOIN

  한 릴레이션에 속하는 튜플을 동일한 릴레이션에 속하는 튜플들과 조인하는 것

  실제로는 한 릴레이션이 접근되지만 FROM  절에 두 릴레이션이 참조되는 것처럼 나타내기 위해서 그 릴레이션에 대한 별칭을 두 개 지정해야 함.

  ```sql
  SELECT E.EMPNAME, M.EMPNAME
  FROM EMPLOYEE E, EMPLOYEE M
  WHERE E.MANAGER = M.EMPNO;
  ```

- SELECT의 WHERE절에 사용할 수 있는 연산자

  ```SQL
  IN, NOT IN, ANY(SOME), ALL, EXISTS
  ```

  EXIST → 조건을 만족하는 컬럼이 있는 경우

- 조인도 사실은 루프를 두개 도는 것이다.

- INSERT 명령을 할 때에는 무결성 제약 조건을 위배하는지 확인한다. 

  쿼리의 결과값을 INSERT문으로 삽입할 수 있다.

- 트리거

  명시적인 이벤트가 발생할 때마다 DBMS가 자동으로 사용자 정의 프로시저를 수행하도록 하는 것

  데이터베이스의 무결성을 유지하기 위한 일반적이고 강력한 도구임

  테이블 정의 시 표현할 수 없는 기업의 비즈니스 규칙들을 시행할 수 있다. (어플리케이션 대신)

  이벤트-조건-동작(ECA, Event, Condition, Action)이라고도 한다.

  조회, 검색에 대한 보고도 시킬 수 있다.

  ```sql
  CREATE TRIGGER <NAME>
  AFTER <EVENTS> ON <RELATION>
  [WHEN <CONDITION>]
  BEGIN
  	<SQLS>
  END
  ```

  연쇄적으로 트리거가 일어날 수 있음. 마치 핵분열이 일어나듯이...

- ASSERTION

  ```sql
  CREATE ASSERTION <NAME>
  CHECK <CONDITION>;
  ```

  일종의 룰이면서, 데이터베이스가 반드시 지켜야 하는 조건이다.

  predicate를 검사해서 참인 경우에만 DB 수정이 허용된다.

  무결성 제약 조건으로 볼 수 있다.

  ```sql
  CREATE ASSERTION EnrollStudentIntegrity
  CHECK (NOT EXISTS # 이런 건 있어서는 안된다
  	(SELECT	*
  	 FROM ENROLL
  	 WHERE STNO NOT IN
  	 	(SELECT STNO FROM STUDENT)));
  ```

- Embedded SQL

  모든 질의를 sql로 표현할 수는 없음 프로그래밍 언어의 개념을 사용해서 만든것

  호스트 언어(프로그래밍 언어)에 포함된 SQL문을 의미한다.

  요즘에는 SQL에 다 포함되어 있음.

  프로그래밍 언어는 릴레이션 단위로 처리하는 것이 아니라 레코드(튜플) 단위로 처리함. 따라서 데이터 구조가 불일치하는 문제(impedance mismatch)가 발생할 수 있음

  공용으로 사용하는 변수 host variable이 있다.
  
- 불일치 문제

  SQL과 호스트 언어의 처리 단위가 달라서 발생함

  이를 해결하기 위해서 커서(cursor)를 사용, 한번에 한 튜플씩 가져오는 수단

  `OPEN cursor`가 질의를 수행하고 그 결과의 첫번째 튜플 이전을 가르킴

  `FETCH`문으로 다음 튜플로 이동하고 attribute값을 명시된 호스트 변수에 복사함

  ```sql
  EXEC SQL BEGIN DECLARE SECTION;
  char name[] = "엄준식";
  char title[10];
  EXEC SQL END DECLARE SECTION;
  
  EXEC SQL
  	DECLARE title_cursor CURSOR FOR
  	SELECT title FROM employee WHERE empname = :name;
  
  EXEC SQL OPEN title_cursor;
  EXEC SQL FETCH title_cursor INTO :title;
  ```

- SQL 통신 영역(SQL Communications Area)

  C 프로그램에 내포된 sql문에 발생하는 에러를 알려줌

  SQLCA 데이터 구조의 에러 필드와 상태 표시자를 검사, 잘 수행되었는지 확인

  에러 핸들링 목적

  데이터를 성공적으로 가져오면 `SQLCODE` 값이 `0`이다.

  > 미국 도요타 급발진 원인 분석 시
  >
  > 이 프로그램이 잘못됬다는걸 증명함
  >
  > 에러 핸들링 부분이 잘못됬었다는데 그게 내포 SQL인지는 잘 머르겠네요?

<br>

### 리눅스와 MySQL 접속 방법

```shell
$ mysql -u {ID} -p
```

<br>

### 데이터베이스 설계

- 두 가지로 구분

  1. 개념적 DB 설계

     정보 사용의 모델을 개발

     실세계의 엔티티, 관계, 프로세스, 무결성 제약 조건 등을 나타내는 추상화 모델을 구축

     > 엔티티 : 서로 구분이 되면서 조직체에서 DB에 나타내려는 객체
     >
     > 관계 : 두 개 이상의 엔티티 간의 연관성
     >
     > 프로세스 : 관련된 활동
     >
     > 무결성 제약 조건 : 데이터의 정확성과 비즈니스 규칙

  2. 물리적 DB 설계

     실제로 DB를 어떻게 구현할 것인가

     물리적인 저장 장치와 접근 방식을 다룸

     DBMS 선정

- 개념적 수준의 모델

  - 이 범주에서 많이 쓰는게 바로 ER(Entity-Relationship) 모델임

    세계적으로 자연스럽게 통일된 느낌 (de facto standard)

  - 개념적 데이터 모델인 ER모델을 구현할 수 있는 구현 데이터 모델(implementation data model)이 존재함

    1. 관계 데이터 모델
    2. 계층 데이터 모델
    3. 네트워크 데이터 모델

- 설계에 필요한것

  탑다운 과정으로 내려감

  이 회사에서 사용하는 응용 프로그램이 뭔가?

  그 응용 프로그램이 사용하는 데이터가 뭔가?

  이 데이터들은 서로 어떤 관계가 있는가?

- 설계시 중요한 것

  시간의 흐름에 따른 데이터의 측면을 나타낼 수 있어야 함

  중복 최소화

  효율적인 접근 제공

  무결성 제공

  이해하기 쉬워야 함

- 설계 과정

  개념적 설계(ER 모델링) - 논리적 설계(스키마) - 스키마 정제(정규화 등) - 물리적 설계(인덱싱 등) - 보안 설계 - 구현 단계

- 요구사항 수집과 분석

  제일 어려운 것이다. 설계 변경을 최소화 하기 위해서 이 단계를 잘 해야 함

  고객들은 자기가 뭘 필요로 하는 지 잘 모름. 고객들을 잘 가이드 해야 함. 이 부분을 컨설턴트들이 하는데, 부가 가치가 높은 부분임. 분석된 결과를 가지고 설계를 의뢰 할 수 있음

  요구사항에 대한 지식을 기반으로 관련된 엔티티, 관계, 애트리뷰트 등을 파악해야 함

  데이터 처리 시 전형적인 연산, 연산들의 의미, 접근하는 데이터의 양을 분석

- 물리적 설계 시 성능상 고려할 점

  1. 응답 시간 : 질의와 갱신이 평균 / 피크 시간 때 얼마나 오래 걸릴 것인가

  2. 트랜잭션 처리율 : 1초당 얼마나 많은 트랜잭션들이 평균 / 피크시간 때 처리될 수 있는가?

     벤치마킹해서 성능 평가

  3. 전체 DB에 대핸 보고서를 생성하는 데 얼마나 오래 걸릴 것인가?

  → 평균 / 피크 시간을 모두 고려해야 함

  → 튜닝을 위한 SW를 사용할 수도 있음

- 트랜잭션 설계

  - 요구사항 수집과 분석 후, DB 설계에 대해 별도로 진행
  - 완성될 데이터베이스에서 동작할 응용 프로그램에 대한 것
  - DB 스키마는 트랜잭션에서 요구하는 모든 정보를 포함해야 한다.
  - 검색, 갱신, 혼합 으로 구분하고 입력, 출력, 동작 등을 식별
  - 트랜잭션의 종류별 빈도 수도 고려해야 한다. 주요 트랜잭션을 잘 처리할 수 있도록 데이터를 튜닝할 필요성이 있음

<br>

## ER 모델

- DB 설계를 용이하게 하기 위해 제안된 것

  현재는 EER(Enhanced Entity Relationship)모델 사용

- 기본 구문 : 엔티티, 관계, 애트리뷰트

  기타 구문 : 카디날리티 비율, 참여 제약 조건 등

- CASE 도구들에서는 ER 설계를 자동적으로 DB 스키마로 변환 가능

<br>

### 엔티티

- 엔티티

  - 설계자가 결정하는 것

  - 독립적으로 존재해서, 고유하게 식별 가능한 객체

  - 사원처럼 실체가 있을 수도 있고, 생각이나 개념처럼 추상적일 수도 있음

  - 같은 타입을 묶어서 엔티티 타입/집합 이라고 함, 엄격하게 구분할 필요는 X

    1. 엔티티 타입(스키마)

       동일한 애트리뷰트를 가진 엔티티의 틀 → 같은 애트리뷰트는 같은 종류의 실체라는 것

       관계 모델의 릴레이션의 내포에 해당

       ER 다이어그램에서 직사각형으로 나타냄

    2. 엔티티 집합(인스턴스)

       동일한 애트리뷰트를 가진 엔티티들의 모임

       관계 모델의 릴레이션의 외연에 해당

  - 하나의 엔티티는 한 개 이상의 엔티티 집합에 속할 수 있음

- 엔티티의 두 가지 타입

  1. 강한 엔티티 타입
     - 독자적으로 존재
     - 자신의 키 애트리뷰트 사용하며 고유하게 식별 가능
  2. 약한 엔티티 타입
     - 키를 형성하기에 충분한 애트리뷰트 X
     - 소유 엔티티 타입이 있어야 존재 가능 (dependent)
     - 소유 엔티티 타입의 키 애트리뷰트를 결합해서 식별, 따라댕겨야 함

<br>

### 약한 엔티티 타입

- 키를 형성하기에 충분한 애트리뷰트 X

- 소유 엔티티/식별 엔티티 타입으로부터 키 애트리뷰트를 제공받음

  > 회사 입장에서 [사원 - 부양 가족] 관계에서 부양 가족은 사원에 딸려 있는 것
  >
  > 사원이 없어지면 의미 없는 정보

- ER 다이어그램에서 이중선 직사각형으로 표현

- 부분 키 (partial key)

  부양 가족의 이름처럼 한 사원에 속한 부양 가족 내에서는 서로 다르지만, 회사 전체 사원들의 부양가족 전체에서는 같은 경우가 생길 수 있는 애트리뷰트

  점선 밑줄을 그어서 표기

<br>

### 애트리뷰트

- 하나의 엔티티를 설명하는 집합들
-  애트리뷰트의 도메인 : 그 애트리뷰트가 가질 수 있는 가능한 값들의 집합
- ER 다이어그램에서 타원형으로 나타내며, 기본 키 애트리뷰트는 밑줄 그어 표시
- 요구사항 명세에서 명사나 형용사로 표현
- 엔티티와 달리 독립적인 의미를 갖지 않음, 그 자체로 어떤 의미가 있지는 않음
- 엔티티 타입과 실선으로 연결
  1. 단순 애트리뷰트
     - 더 이상 다른 애트리뷰트로 나눌 수 없음
     - 실선과 타원으로 표시함
     - ER 애트리뷰트에서 대부분임
  2. 복합 애트리뷰트
     - 두 개 이상의 애트리뷰트로 이루어짐
     - 동일한 엔티티 타입이나 관계 타입에 속하는 애트리뷰트 중에서 밀접하게 연관된 것을 모아놓은 것 
     - 계층 구조
  3. 단일 값 애트리뷰트(single-valued attribute)
     - 각 엔티티마다 정확히 하나의 값을 갖는다, 여러 개의 값을 갖지 않음
     - 단순 애트리뷰트와 동일하게 표현
     - ER 다이어그램에서 대부분임
  4. 다치 애트리뷰트(multi-valued attribute)
     - 각 엔티티마다 여러 개의 값을 가질 수 있음
     - ER 다이어그램에서 이중선 타원으로 표시함
     - 관계형 DB에서 여러 개의 애트리뷰트 값을 가질 수 없음, 어케 표현할까용?
  5. 저장된 애트리뷰트(stored attribute)
     - 다른 애트리뷰트와 독립적으로 존재
     - 표현은 단순 애트리뷰트와 동일
     - ER 다이어그램의 대부분
     - 사원의 이름, 급여 등
  6. 유도된 애트리뷰트 (derived attribute)
     - 다른 애트리뷰트의 값으로부터 얻어짐
     - 관계형 DB에서 릴레이션의 애트리뷰트로 포함시키지 않는 게 좋다.
     - ER 다이어그램에서 점선 타원으로 표현함
     - 나이 같은 것

<br>

### 관계와 관계 타입

- 엔티티들 사이에 존재하는 연관, 연결

- 관계 집합은 동질의 관계들의 집합

  관계 타입은 동질의 관계들의 틀

  > 엄격히 구분할 필요는 없다.

- 요구사항 명세에서 주로 동사를 표현한다.

- ER 다이어그램에서 다이아몬드로 표현

- 엔티티를 관계 타입에 실선으로 연결

- 관계도 특징을 기술하는 애트리뷰트가 존재 가능

  키 애트리뷰트를 갖지 않음 (WHY?????)

  관계는 키를 갖는다는 게 의미가 없다. 키의 역할은 엔티티의 기본 키들이 한다. (참조키들)

  > 관계를 supply chain 자동화 할 때 사용 가능. 많은 부품을 관리할 때 납기, 장소, 수량 등을 잘 관리해야 함

- 차수 (degree)

  - 어떤 관계로 연결된 엔티티 타입들의 개수
  - 실세계에서는 두 개의 엔티티 타입을 연결하는 2진 관계가 제일 많다.

- 카디날리티

  - 카디날리티 비율 : 한 엔티티가 다른 엔티티와 맺을 수 있는 관계의 수

  - 관계 타입에 참여하는 엔티티들의 가능한 조합을 제한. 반드시 참여하도록 할 수도 있음

  - 1:1, 1:N, M:N으로 구분

    > 1 to many는 보통 계층 구조가 많음

  - 간선 위에 카디날리티 정보를 표시

  - 카디날리티 비율의 최소값과 최대값

    `(min, max)`로 표시함. mandatory/optional을 표현할 수 있음

- 역할(role)

  - 관계를 명확히 하는 역할
  - 간선 위에 표시

- 전체 참여와 부분 참여 (total/partial participiation)

  - 모든 엔티티가 관계에 참여하는지의 여부에 따라 나눔

  - 약한 엔티티 타입은 항상 관계에 전체 참여함

    ER 다이어그램에서 이중 실선으로 표시

  - 관계에 대한 중요한 제약 조건임

- 기타 관계

  1. 다중 관계 (multiple relationship)

     두 엔티티 타입 사이에 두 개 이상의 관게타입이 존재할 수 있다.

  2. 순환적 관계 (recursive)

     하나의 엔티티 타입이 동일한 관계 타입에 두 번 이상 참여

- ER 스키마 작성 지침

  - 엔티티는 키 이외에 설명 정보가 추가로 필요함
  - 다치 애트리뷰트는 엔티티로 분류해야 한다.
  - 가능한 복합 식별자는 피하자.
  - 관계는 독자적으로 존재할 수 없지만, 엔티티 타입과 관계 타입을 엄밀하게 구분하는 것은 어렵다.

<br>

### 논리적 설계
