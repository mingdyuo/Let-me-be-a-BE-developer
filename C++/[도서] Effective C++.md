## Chapter 1 C++에 왔으면 C++의 법에 따릅시다.

### 항목 0 용어 설명

- 암시적 타입 변환에 생성자가 사용될 여지를 남겨둬야 할 필요성이 있지 않으면 가능한 `explicit` 으로 선언하자.

### 항목 1 C++를 언어의 연합체로 바라보는 안목은 필수

C++을 다음 4가지 항목의 연합체로 보자.

1. C

   아무튼 C++의 기본은 C에 있다.

2. 객체 지향 개념의 C++

3. 템플릿 C++

   TMP가 나온 배경이 되는 기능. 근데 주류로 쓰지는 않나보다.

4. STL

   컨테이너, 반복자, 알고리즘, 함수 객체가 얽혀 있다.

C++을 사용해서 잘 프로그래밍 하려면 어떤 규칙을 적용해야 할까? 그건 위의 4가지 항목 중 어떤 부분을 사용하느냐에 따라 달라진다!

예를 들어서 값/객체를 넘길때 C style에서는 값 전달이, 객체 지향 C++에서는 상수 객체 참조자 전달이, 템플릿에서는 어떤 객체인지도 알 수 없으므로 특히 상수 객체 참조자 전달이, STL에서는 포인터를 본떠 만든 반복자와 값 전달이 좋다.

### 항목 2 `#define`을 쓰려거든 `const`, `enum`, `inline`을 떠올리자.

- 핵심은 **선행 처리자**보다 **컴파일러**를 더 가까이 하자는 것이다.

- `#define`은 컴파일러에게 넘어가기 전에 밀려버리고 다른 값으로 대체된다. 컴파일러의 기호 테이블에도 들어가지 않는다.

- `const` 상수는 여러 번 쓰이더라도 사본은 한개만 생긴다.

- `#define`을 `const` 상수로 바꿀 때 이 점은 주의하자.

  1. 상수 포인터를 정의하는 경우

     포인터는 꼭 `const`로 선언해 주어야 한다.

     보통 포인터가 가리키는 대상까지 `const`로 선언해준다.

     예를 들면

     ```c++
     const char* const authorName = "Justin Bieber";
     ```

     문자열 상수를 쓸 때에는 `string` 객체를 사용하는 것이 더 좋다.

     ```c++
     const std::string authorName("Justin Bieber");
     ```

  2. 클래스 멤버로 상수를 정의하는 경우

     해당 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 `static`으로 선언하자.

     헤더 파일에 선언하고 구현 파일에 정의한다.

     구식 컴파일러의 경우, 클래스 컴파일 시 클래스 상수가 필요한 경우에는 열거형을 쓸 수 있다. (`enum hack`이라고 부른다. 그만큼 꼼수라는거지~ )

     ```c++
     class ExampleClass {
     private:
     	enum { TestNum = 5 };
     }
     ```

- 매크로 함수 노노 인라인 함수 예스예스

- `enum`은 메모리 할당 안함. `#define`은 하는가본데??? 모지 

### 항목 3 낌새만 보이면 `const`를 들이대 보자!

- `const`를 쓸 수 있는 범위는 다양하다.

  1. 클래스 밖에서 전역/네임스페이스 유효범위의 상수를 선언/정의 할 수 있음

  2. 파일, 함수, 블록 유효 범위에서 `static`으로 선언한 객체에도 `const`를 붙일 수 있다.

  3. 클래수 내부의 정적, 비정적 데이터 멤버를 모두 상수로 선언할 수 있다.

  4. 포인터 자체 / 포인터가 가르키는 데이터를 상수로 선언할 수 있다.

     ```c++
     void f1(const Widget *pw);
     void f1(Widget const *pw);
     ```

     이 둘은 같은 매개변수 타입을 갖는다. `*`포인터의 왼쪽에 있으면 상수 포인터

- 반복자에 `const` 쓰기

  `const iterator`는 `iterator`가 가르키는 대상의 값은 변경 가능하나 가르키는 대상은 변경할 수 없다.

  ```c++
  const std::vector<int>::iterator iter = vec.begin(); // T* const 처럼 동작
  *iter = 10; 	// 가능
  ++iter; 		// 불가능
  ```

  `container::const_iterator`는 가르키는 대상의 값을 변경할 수 없으나, 가르키는 대상은 변경할 수 있다.

  ```c++
  std::vector<int>::const_iterator iter = vec.begin(); // const T* 처럼 동작
  *iter = 10;		// 불가능
  ++iter;			// 가능
  ```

- 함수 반환 값에 `const` 쓰기

  안전성이나 효율을 포기하지 않고 사용자측의 에러 및 돌발상황을 예방할 수 있다.

  ```c++
  // 곱하기 함수
  const Rational operator*(const Rational& lhs, const Rational& rhs);
  ```

  반환값이 상수 객체일 이유가 있을까? 

  만약 반환값이 상수 객체가 아니라면 아래의 실수들을 저질렀을 때 쉽게 잡을 수 없다.

  ```c++
  // 1
  Rational a, b, c;
  (a * b) = c; 		// 띠용
  // 2
  if (a * b = c)		// 띠용2 (원래 비교 구문이 의도)
  ```

  가능한 항상 `const`를 사용하자.

- 상수 **멤버 함수**

  - 왜 중요한가?

    1. 클래스의 인터페이스를 이해하기 좋게 해줌

       객체를 변경할 수 있는 함수 / 변경할 수 없는 함수 파악

    2. 이 키워드를 통해 상수 객체를 사용할 수 있도록 해줌

  - `const`키워드가 있고/없고의 차이가 있는 함수들도 오버로딩이 가능하다 !

    (`const` 함수는 `const` 객체를 사용할 때 호출, 비상수는 비상수 객체 사용 시 호출)

### 항목 4 객체를 사용하기 전에 반드시 그 객체를 초기화하자

<br>

## Chatper 4 설계 및 선언

### 항목 20 '값에 의한 전달'보다는 '상수 객체 참조자에 의한 전달 방식이 대개 낫다.

- 복사 손실(slicing problem) 

  - 파생 클래스 객체가 전달될 때 기본 클래스 객체로 전달되는 경우. 가끔 일어난다.

  - 이게 일어나면 파생 클래스 객체로 동작하는 특징들이 잘려 나간다. 그래서 slicing problem

  - `const reference`로 매개변수를 넘기면 이 문제를 걱정하지 않아도 된다.

  - 예)

    A 클래스를 상속받은 클래스 B가 있다. A에는 가상함수 `a()`가 있으며, B에도 구현되어 있다. 

    이 때 A를 값의 의한 전달로 받는 함수에 B로 만든 객체를 넣으면 생성자 A만 호출되고 B의 특성을 갖는 영역은 사라진다. `B::a()`는 사용하지 못한다.

    이 때 A를 const reference로 받는 함수에 B로 만든 객체를 넣으면 `B::a()`가 잘리지 않는다.

- 레퍼런스는 내부에서 포인터를 써서 구현된다.

  레퍼런스를 전달한다는 것은 결국 포인터를 전달하는 것과 일맥상통하다.

- 전달하는 객체의 타입이 `int`와 같이 built-in인 경우에는 값으로 넘기는 편이 대체로 더 효율적이다.

  1. **단순히 타입 크기가 작은 경우를 의미하는 것이 아니다.** 작더라도 user-defined 객체라면 복사하는 비용이 클 수 있다. 

     컴파일러 중에는 built-in과 user-defined 타입을 아예 다르게 취급하는 것도 있다. 

  2. 또한 user-defined 타입은 언제든 크기가 변할 수 있으므로 call by value로 사용하는 것은 권장되지 않을 것이다.

- STL의 `iterator`와 `functor`는 call by value로 설계되어 있다.

- 다음 3가지 타입은 call by value를 사용해도 저비용이라고 여겨질 수 있는 것들이다. 이외는 가능하면 상수 레퍼런스를 사용하자.

  1. built-in type
  2. STL iterator
  3. 함수 객체

<br>

### 항목 27 캐스팅은 절약, 또 절약! 잊지 말자

