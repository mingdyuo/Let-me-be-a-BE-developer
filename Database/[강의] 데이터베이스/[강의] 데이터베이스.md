# 데이터베이스

[KOCW 데이터베이스 강의](http://www.kocw.net/home/search/kemView.do?kemId=1064626)

- [x] 1차시 관계 대수와 SQL (21/06/01)
- [x] 2차시 관계 대수와 SQL (21/06/01)
- [x] 3차시 관계 대수와 SQL (21/06/01)
- [x] 3차시 관계 대수와 SQL 데이터베이스 설계와 ER 모델 (21/06/04)
- [x] 4차시 데이터베이스 설계와 ER 모델 (21/06/04)
- [x] 5차시 데이터베이스 설계와 ER 모델 (21/06/05)
- [x] 6차시 물리적 데이터베이스 설계 (21/06/05)
- [x] 7차시 물리적 데이터베이스 설계 (21/06/05)
- [x] 7차시 물리적 데이터베이스 설계, 릴레이션 정규화 (21/06/08)
- [x] 8차시 릴레이션 정규화 (21/06/08)
- [x] 9차시 릴레이션 정규화, 뷰와 시스템 카탈로그 (21/06/08, 09)
- [x] 10차시 뷰와 시스템 카탈로그 (21/06/09)
- [x] 11차시 트랜잭션 (21/06/09)
- [x] 12차시 트랜잭션 (21/07/04)
- [ ] 13차시 데이터베이스의 저장과 접근 : 해싱 빅테이터 관리 서론 (21/07/11)
- [ ] 14차시 빅테이터 관리 서론
- [ ] 15차시 NoSQL Database Patterns
- [ ] 15차시 NoSQL Database Patterns

<br>

### 공부 가능한 사이트 / 소스

[SqlZoo](https://sqlzoo.net/)
[sql-ex](https://sql-ex.ru/)
[공공데이터포털](https://www.data.go.kr/)

<br>

## 목차

### [관계 대수와 SQL](#관계 대수와 SQL)

[관계 대수](# 관계 대수)
[SQL](# SQL)
[리눅스와 MySQL 접속 방법](#리눅스와 MySQL 접속 방법)
[데이터베이스 설계](#데이터베이스 설계)

### [ER 모델](#ER 모델)

[엔티티](#엔티티)
[약한 엔티티 타입](#약한 엔티티 타입)
[애트리뷰트](#애트리뷰트)
[관계와 관계 타입](#관계와 관계 타입)
[논리적 설계](#논리적 설계)

### [물리적 데이터베이스 설계](#물리적 데이터베이스 설계)

[보조 기억 장치](#보조 기억 장치)
[보조 기억 장치 - 자기 디스크](#보조 기억 장치 - 자기 디스크)
[버퍼 관리와 운영 체제](#버퍼 관리와 운영 체제)
[디스크 상에서 file의 레코드 배치](#디스크 상에서 file의 레코드 배치)
[file structure](#file structure)

<br>

<br>

## 데이터베이스의 저장과 접근 : 해싱 빅데이터 관리 서론

### 해싱

- 다른 레코드의 참조 없이 목표 레코드의 접근을 직접 지원한다. -> direct file (직접 액세스)

- 키(key) 값과 레코드 주소(address) 사이의 매핑 관계를 함수로 설정

  보조기억장치 내의 주소를 output으로 설정

- 해싱 함수

  - 키 값으로부터 레코드 주소를 계산
  - 매핑 함수 : 키 -> 주소
  - 삽입, 검색에 모두 이용

- overflow만 일어나지 않으면 ideal함. 키값의 분포에 의존하지 않는게 좋다. 완벽히 분산되는 것 -> perfect hasing

### 버킷 해싱

- 버킷
  - 하나의 주소를 가지면서 하나 이상의 레코드를 저장할 수 있는 파일의 한 구역
  - 버킷 크기 : 저장 장치의 물리적 특성과 한번 접근으로 체취 가능한 레코드 수를 고려
- 버킷 해싱 : f(키) = 버킷 주소
- 충돌 (collision)
  - 상이한 레코드들을 같은 주소(버킷)로 변환
  - 동거자(synonym)
  - 오버플로 버킷을 다른 곳으로 저장해야 한다.
  - 한번의 I/O가 추가된다.

### 확장성 해싱 (extendible hashing)

- 충돌에 대처하기 위해 제안됨

  데이터베이스 내 레코드 개수가 최대 몇개가 들어올 지 모른다. 따라서 확장이 될 수 있어야 한다.

- 버킷의 개수를 무한히 늘릴 수 있음

  2배씩 늘어난다는게 단점. linear hashing이 제일 이상적이다.

- 레코드 검색은 최대 2번의 디스크 접근만 필요

- 모조 키(pseudokey)

  - 확장성 해싱 함수

    키 값이 들어오면 비트스트링으로 간주한다. (1101101.....)

    현재의 depth를 정한다. 그리고, 2^d까지 키로 취급한다. 해당 depth 크기만큼까지 버킷으로 취급한다.

  - pseudokey의 처음 d 비트를 디렉터리의 인덱스로 사용

- 디렉터리 (directory)

  - 헤더에 현재의 디렉터리 전역 깊이(global depth)를 유지
  - 2^d개의 버킷들을 지시할 수 있는 포인터 엔트리로 구성
  - 디스크에 저장

![image](https://user-images.githubusercontent.com/41130448/125194812-c814bb00-e28d-11eb-8ef5-21a8feca3bac.png)

- 버킷
  - 헤더에 현재의 버킷 깊이(local depth)를 유지
  - 각 버킷에 저장된 레코드들의 모조 키들은 처음 p 비트가 모두 동일
- 검색
  - 모조 키의 처음 d 비트를 디렉터리에 대한 인덱스로 사용
  - 접근된 디렉터리 엔트리는 목표 버킷에 대한 포인터를 제공



29:47
