# Concurrency in Go

## 1장. 동시성 소개

- 동시성이라는 단어는 사람마다 받아들이는게 다르다, 비슷하게 여겨지는 용어로 비동기, 병렬, 스레드 등이 있다
- 컴퓨터 과학에서는 동시성 개념에서 출발한 폭 넓은 주제가 많다.
  - 이 책에서는 Go의 컨텍스트 내에서 동시성을 이해하는 데 필요한 실제 문제들에 초점을 맞춘다.
  - 예를 들면 다음과 같은 것들이다.
    - 동시성 위해서 선택한 모델
    - 그 모델 때문에 발생하는 문제
    - 그 문제를 해결하기 위해서 기본 요소들을 구성하는 방식
- 동시성***Concurrent***의 정의를 이해하고, 왜 어렵고 중요한 주제인지 알아보자. 

### 무어의 법칙, 웹 스케일. 그리고 혼란

- 무어가 무어라 했냐면 (무어의 법칙)
  - 집적 회로의 구성 요소가 매년(1965)/2년(1975)마다 두배가 될 것 이라고 예측했다. 
  - 거의 들어맞았으나 2012년부터 둔화되기 시작. 그 대안으로 찾은 것이 멀티코어 프로세스이다.
- 하지만 암달의 법칙이라는 한계에 직면했다
  - 프로그램에서 **순차적인 방식**으로 작성할 수 밖에 없는 부분이, **성능 향상의 한계**를 결정한다.
    1. GUI 기반 프로그램
       - 인터페이스에서의 순차적인 상호작용에 의해 성능이 제한
    2. 파이의 자릿수 계산하는 프로그램
       - 스피곳 알고리즘을 사용하면 병렬 작업으로 **지나치게** 나눌 수 있음
       - 이 병렬 처리된 **결과를 어떻게 결합하고 저장**하느냐가 새로운 문제
- 클라우드 컴퓨팅이라는 패러다임
  - 애플리케이션 배포, 스케일 아웃에 대한 새로운 접근 방식 
  - 저렴한 비용으로 방대한 컴퓨팅 성능에 접근 가능해짐
  - 그러나 새로운 문제들 발생
    - 자원들을 프로비저닝하는 것
    - 장비 인스턴스 간에 통신하는 것
    - 결과를 집계하고 저장하는 문제
    - **코드를 동시적으로 모델링하는 방법을 이해하는 것**
- 문제들이 해결되면서 웹 스케일 이라는 유형의 브랜드로 이어짐
  - https://www.nutanix.com/blog/understanding-web-scale-properties

### 동시성이 어려운 이유

#### 레이스 컨디션

- 둘 이상의 작업이 올바른 순서로 수행되어야 하나, 그 순서가 보장되지 않는 상황
- 동시성 코드를 작성할 때에는 가능한 시나리오를 세심하게 반복해야 한다.
  - 소스 코드에 나열된 순서대로 실행되리라는 보장이 없다.
  - 연산들 사이에 시간적 공백이 있다고 상상해보자.
  - 코드 전체에 `sleep`을 뿌리는 것은 좋지 않다. 심지어 레이스 컨디션을 해결할 수도 없다.
- **언제나 논리의 정확성을 추구해야 한다.**
- 레이스 컨디션은 숨어있다가 코드 실행 환경이 바뀔 때 버그가 발생할 수 있다.

#### 원자성

#### 메모리 접근 동기화

#### 데드락, 라이브락, 기아 상태

#### 데드락

#### 라이브락

#### 동시실행 안전성 판단



### 복잡성 속의 단순함

#### 

```go
var wg sync.WaitGroup

wg.Add(1)
go func (){
  defer wg.Done()
}

wg.Wait()
fmt.Println("All goroutines complete")
```

