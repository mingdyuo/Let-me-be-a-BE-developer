### 게임 서버의 역할

- 유저간의 동기화
- 아이템 시스템 운영
- NPC의 인공지능

<br>

### 서버 부하 분산

- 접속 유저 늘어나면서 부하가 급격히 증가함

1. NPC 서버

   - 몬스터도 여기에 속함

   - 인공지능 부분 처리

   - 코드 복잡하고 처리량이 많음 

   - 단점: 소켓 통신 비용 소모

     장점: 서버 리소스 절약

2. 동기화 서버

3. 채팅 서버

<br>

### 분산 게임 서버의 구조

![image](https://user-images.githubusercontent.com/41130448/110605735-c3030a80-81cc-11eb-946b-ed996245d1a9.png)

- 동기화 서버와 맵 서버 사이에서는 UDP 이용해서 송수신
- 두개의 맵서버는 물리적으로는 분리되어 있지만 논리적으로는 같은 서버에 존재
- 동기화 서버는 캐릭터의 동기화 작업만 수행하므로 디스크 I/O가 없음. 부하 적음. 많은 유저 수용 가능

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F26246D45556D4F1E178626)

<br>

### 서버 분리 시 주의사항

- NPC 서버를 분리한다면, 서버 간의 동기화와 서버 간 통신으로 인한 네트워크 오버헤드를 고려해야 함.

  각 서버와 또한 동기화 서버의 권한을 명확히 해야 함

  

### 분산처리 서버 제작 학습

[분산처리 - 서버 제작의 여러 방식](https://12bme.tistory.com/278)

- 네트워크 이슈

  서버를 제작할 때 가장 크게 오버헤드 걸리는 것은 `Accept`와 `Disconnect`이다. 

  현재 `Accept` 핸들링은 `AcceptEx`가 최선의 선택이라는 것이 학계의 정설이라고 한다. 

  하지만 `AcceptEx`를 어떻게 사용하는지에 대해서는 의견이 갈린다. (Pooling 하거나, 하지 않거나)

- 메모리 관리 이슈

  1. `malloc`/`free` 혹은 `new`/`delete`를 할 때의 성능

     `new`보다 `delete` 호출 시 더 많은 시간이 소요된다고 알려져 있다.

  2. `Static Allocation`

     이건 `C`에서 많이 사용된 방식인데 `C++`로 넘어오며 객체 지향 언어에는 어울리지 않지만 성능을 위해서 구조를 버리면서 사용하고 있다. 속도 면에서 많은 이득이 있다.

  3. Memory Pooling

     구조는 정적 할당이나 사용 방식은 동적 할당처럼 사용함

- 데이터베이스에 대한 이슈

  데이터베이스 설계 및 쿼리에 대한 이슈보다는 데이터베이트 프로토콜 이슈와 벤치마크에 대한 내용

