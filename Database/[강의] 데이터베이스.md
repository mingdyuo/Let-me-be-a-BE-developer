# 데이터베이스

[KOCW 데이터베이스 강의](http://www.kocw.net/home/search/kemView.do?kemId=1064626)

- [x] 1차시 관계 대수와 SQL (21/06/01)
- [x] 2차시 관계 대수와 SQL (21/06/01)
- [x] 3차시 관계 대수와 SQL (21/06/01)
- [ ] 3차시 관계 대수와 SQL 데이터베이스 설계와 ER 모델 
- [ ] 4차시 데이터베이스 설계와 ER 모델
- [ ] 5차시 데이터베이스 설계와 ER 모델
- [ ] 6차시 물리적 데이터베이스 설계
- [ ] 7차시 물리적 데이터베이스 설계
- [ ] 7차시 물리적 데이터베이스 설계, 릴레이션 정규화
- [ ] 8차시 릴레이션 정규화
- [ ] 9차시 릴레이션 정규화, 뷰와 시스템 카탈로그
- [ ] 10차시 뷰와 시스템 카탈로그
- [ ] 11차시 트랜잭션
- [ ] 12차시 트랜잭션
- [ ] 13차시 데이터베이스의 저장과 접근 : 해싱 빅테이터 관리 서론
- [ ] 14차시 빅테이터 관리 서론
- [ ] 15차시 NoSQL Database Patterns
- [ ] 15차시 NoSQL Database Patterns

<br>

## 관계 대수

관계 데이터 모델에서 지원하는 두 가지 언어

1. 관계 해석 (relational caculus)
2. 관계 대수 (relational algebra)
   - 기존의 릴레이션으로부터 새로운 릴레이션을 생성
   - 피연산자와 연산이후의 결과 모두 릴레이션

- primitive operator : CPU가 바로 연산 가능

![image](https://user-images.githubusercontent.com/41130448/120252854-b02a3e80-c2c0-11eb-8300-e7b246a6e8a9.png)

- 세미 조인 - 반만 조인하는것?

- 카티션 곱 -> 양쪽의 튜플을 엮어서 가능한 모든 경우를 만드는 것

  튜플 수가 많은 경우 연산할때 시간이 겁나 많이 걸린다.

- Selection 연산자

  - 단항 연산자
  - 실렉션 조건을 predicate라고 한다. (true, false를 판단하는 기준)

- relation의 기본 원칙 : 모든 튜플들은 unique하다

- 임의의 relation으로 합집합을 만들 수는 없다. (의미가 없음)

  합집합 호환(union compatible)을 만족해야 한다.

  attribute의 수가 같고, 도메인이 같아야 함
  
- 프로젝션 할 때 중복 제거는 굉장히 오래걸리는 연산

  특별히 명령을 하지 않는 이상 중복이 허용되도록 연산이 이루어짐

- 카티션 곱

  임의의 두 릴레이션의 모든 가능한 조합을 만드는 릴레이션

  사용자가 실제로 원하는 것은 결과 릴레이션의 일부일 경우가 많다. 그래서 그 자체는 유용하지 않을 수 있다. 

  join을 하기 위한 연산이라서 중요한 것

- 관계 대수의 완전성

  관계 대수의 필수적인 연산자 : selection, projection, 합집합, 차집합, 카티션 곱 → 어떤 데이터 베이스 언어라도 이 연산자들은 꼭 표현할 수 있어야 한다.

  다른 관계 연산자 : 필수적인 관계 연산자를 두 개 이상 조합하여 표현 가능

  임의의 질의어가 적어도 필수적인 관계 대수 연산자들만큼의 표현력을 갖고 있으면 관계적으로 완전하다고 한다. (relationally complete)

- 조인 연산자

  두 개의 릴레이션으로 부터 **연관된 튜플**들을 결합함 (공통 attribute)

  릴레이션의 관계를 다루는 데에 매우 중요함

  종류

  → 세타 조인, 동등 조인(equi join), 자연 조인(natural join , 가장 많이 사용함), 외부 조인(outer join), 세미 조인

- 디비전 연산자

  나누어 지는 릴레이션이 나누는 릴레이션을 **모두** 포함하고 있어야 결과값에 포함됨

- 조인 연산은 disk에서 이루어지므로 시간이 많이 걸린다.

- 관계 대수의 한계

  - 산술 연산을 할 수 없음
  - 집단 함수 (aggregate function)을 지원하지 않음 (개별적인 검색만 가능, 통계 작업 불가)
  - 정렬을 나타낼 수 없음
  - 데이터베이스를 수정할 수 없음
  - 프로젝션의 연산 결과에 중복된 튜블을 나타내는 것이 필요할 때가 있는데 이를 명시하지 못함. 

- Data analysis

  그루핑하고, 통계 내는 것

  연도별, 부서별, 지역별 등등 다양한 기준을 가지고 한번에 그루핑하면 어렵다.

  multi dimension에서 dimension은 곧 attribute, 다차원의 경우 데이터가 많으므로 연산이 오래 걸림. 다 소팅해야 되기 때문에.

  그래서 수시로 하지 않고 주기적으로 정해놓고 가끔함

  이 분석을 batch로 (real-time으로) 처리하면 더 자주 작업을 진행할 수 있다.  

- 외부 조인

  left, right, full조인

  관련된 튜플은 모두 포함되고, 조인 조건을 만족하는 것을 넣는지 아닌지에 따라 나눔. 

<br>

### SQL

- SEQUEL부터 시작됨

- 비절차적 언어(선언적 언어)

  자신이 원하는 바만 명시, 처리하는 방법은 명시할 수 없음

- DBMS는 사용자가 SQL을 입력하면 그걸 번역해서 요구한 데이터를 찾아온다.

- 두 가지 인터페이스

  대화식(interactive), 내포된(embedded)

- 구성 요소

  데이터 정의어, 조작어, 제어어

- UPDATE DELETE INSERT

  릴레이션 하나에 대해서 수행됨. 단항 연산처럼

- SELECT

  여러 개의 릴레이션에 대해 수행 가능

- 데이터 정의어

  ![image](https://user-images.githubusercontent.com/41130448/120300552-015d2100-c307-11eb-9295-1839b1591830.png)

- 릴레이션, 도메인, 제약조건, 뷰, 권한 등을 그룹화하기 위해서 스키마 개념을 지원

  ```sql
  CREATE SCHEMA MY_DB AUTHORIZATION kim;
  
  DROP SCHEMA MY_DB RESTRICT; # 내부에 다른 릴레이션이 많이 존재하면 안삭제
  DROP SCHEMA MY_DB CASCADE; # 내부에 연결된 릴레이션 삭제
  ```

- 무결성 제약조건

  ```
  NOT NULL
  UNIQUE
  DEFAULT
  CHECK
  FOREIGN KEY REFERENCES
  ON
  (CASCADE UPDATE 등)
  ```

  DBMS 시스템 자체가 보장해주도록 설정할 수 있다.

  제약조건에 이름 붙혀서 추가 가능

  ```sql
  ALTER TABLE STUDENT ADD CONTRAINT STUDENT_PK
  	PRIMARY KEY(STNO);
  ```

- SELECT문

  정보를 검색하는 질의문

  관계 대수의 실렉션과 의미가 완전히 다르다.

  관계 대수의 실렉션, 프로젝션, 조인, 카티션 곱을 조합한 것

  ```sql
  SELECT [DISTINCT] ATTRIBUTES
  FROM RELATIONS
  [WHERE CONDITIONS]
  [GROUP BY ATTRIBUTES]
  [HAVING CONDITIONS]
  [ORDER BY ATTRIBUTES [ASC|DESC]];
  ```

- SIMILAR MATCH

  `%`를 사용

  ```SQL
  WHERE EMPNAME LIKE '이%' # 이씨 성을 갖는 사람 찾기
  ```

- 부정 검색 조건

  `<>`를 사용

  ```SQL
  WHERE DNO <> 1
  ```

- 리스트를 사용한 검색

  ```SQL
  WHERE DNO IN (1, 3)
  ```

- `NULL`과 비교를 하기 위해서는 `=`가 아닌 `IS`를 사용하자

  ```sql
  WHERE DNO IS NULL
  ```

- 집단 함수 - aggregate  function

  COUNT, SUM, AVG, MAX, MIN

- 그룹화

  `GROUP BY`절에 사용된 attribute에 동일한 값을 갖는 튜플들이 각각 하나의 그룹으로 묶임

  이 attribute를 그룹화 애트리뷰트 (grouping attribute)라고 한다.

  각 그룹에 대해서 하나의 튜플이 생성된다.

- HAVING

  그룹핑된 애트리뷰트에 조건 걸기

- 집합 연산

  UNION, EXCEPT, INTERSECT, UNION ALL, EXCEPT ALL, INTERSECT ALL

- 서브쿼리, 중첩 질의(NESTED QUERY)

  쿼리 속에 쿼리를 표현할 수 있다.

- SELF JOIN

  한 릴레이션에 속하는 튜플을 동일한 릴레이션에 속하는 튜플들과 조인하는 것

  실제로는 한 릴레이션이 접근되지만 FROM  절에 두 릴레이션이 참조되는 것처럼 나타내기 위해서 그 릴레이션에 대한 별칭을 두 개 지정해야 함.

  ```sql
  SELECT E.EMPNAME, M.EMPNAME
  FROM EMPLOYEE E, EMPLOYEE M
  WHERE E.MANAGER = M.EMPNO;
  ```

- SELECT의 WHERE절에 사용할 수 있는 연산자

  ```SQL
  IN, NOT IN, ANY(SOME), ALL, EXISTS
  ```

  EXIST → 조건을 만족하는 컬럼이 있는 경우

- 조인도 사실은 루프를 두개 도는 것이다.

- INSERT 명령을 할 때에는 무결성 제약 조건을 위배하는지 확인한다. 

  쿼리의 결과값을 INSERT문으로 삽입할 수 있다.

- 트리거

  명시적인 이벤트가 발생할 때마다 DBMS가 자동으로 사용자 정의 프로시저를 수행하도록 하는 것

  데이터베이스의 무결성을 유지하기 위한 일반적이고 강력한 도구임

  테이블 정의 시 표현할 수 없는 기업의 비즈니스 규칙들을 시행할 수 있다. (어플리케이션 대신)

  이벤트-조건-동작(ECA, Event, Condition, Action)이라고도 한다.

  조회, 검색에 대한 보고도 시킬 수 있다.

  ```sql
  CREATE TRIGGER <NAME>
  AFTER <EVENTS> ON <RELATION>
  [WHEN <CONDITION>]
  BEGIN
  	<SQLS>
  END
  ```

  연쇄적으로 트리거가 일어날 수 있음. 마치 핵분열이 일어나듯이...

- ASSERTION

  ```sql
  CREATE ASSERTION <NAME>
  CHECK <CONDITION>;
  ```

  일종의 룰이면서, 데이터베이스가 반드시 지켜야 하는 조건이다.

  predicate를 검사해서 참인 경우에만 DB 수정이 허용된다.

  무결성 제약 조건으로 볼 수 있다.

  ```sql
  CREATE ASSERTION EnrollStudentIntegrity
  CHECK (NOT EXISTS # 이런 건 있어서는 안된다
  	(SELECT	*
  	 FROM ENROLL
  	 WHERE STNO NOT IN
  	 	(SELECT STNO FROM STUDENT)));
  ```

- Embedded SQL

  모든 질의를 sql로 표현할 수는 없음 프로그래밍 언어의 개념을 사용해서 만든것

  호스트 언어(프로그래밍 언어)에 포함된 SQL문을 의미한다.

  요즘에는 SQL에 다 포함되어 있음.

  프로그래밍 언어는 릴레이션 단위로 처리하는 것이 아니라 레코드 단위로 처리함. 따라서 데이터 구조가 불일치하는 문제(impedance mismatch)가 발생할 수 있음

  공용으로 사용하는 변수 host variable이 있다.
