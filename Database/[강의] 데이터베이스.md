# 데이터베이스

[KOCW 데이터베이스 강의](http://www.kocw.net/home/search/kemView.do?kemId=1064626)

- [x] 1차시 관계 대수와 SQL (21/06/01)
- [x] 2차시 관계 대수와 SQL (21/06/01)
- [x] 3차시 관계 대수와 SQL (21/06/01)
- [x] 3차시 관계 대수와 SQL 데이터베이스 설계와 ER 모델 (21/06/04)
- [x] 4차시 데이터베이스 설계와 ER 모델 (21/06/04)
- [x] 5차시 데이터베이스 설계와 ER 모델 (21/06/05)
- [x] 6차시 물리적 데이터베이스 설계 (21/06/05)
- [x] 7차시 물리적 데이터베이스 설계 (21/06/05)
- [ ] 7차시 물리적 데이터베이스 설계, 릴레이션 정규화
- [ ] 8차시 릴레이션 정규화
- [ ] 9차시 릴레이션 정규화, 뷰와 시스템 카탈로그
- [ ] 10차시 뷰와 시스템 카탈로그
- [ ] 11차시 트랜잭션
- [ ] 12차시 트랜잭션
- [ ] 13차시 데이터베이스의 저장과 접근 : 해싱 빅테이터 관리 서론
- [ ] 14차시 빅테이터 관리 서론
- [ ] 15차시 NoSQL Database Patterns
- [ ] 15차시 NoSQL Database Patterns

<br>

### 공부 가능한 사이트 / 소스

[SqlZoo](https://sqlzoo.net/)
[sql-ex](https://sql-ex.ru/)
[공공데이터포털](https://www.data.go.kr/)

<br>

## 목차

### [관계 대수와 SQL](#관계 대수와 SQL)

[관계 대수](# 관계 대수)
[SQL](# SQL)
[리눅스와 MySQL 접속 방법](#리눅스와 MySQL 접속 방법)
[데이터베이스 설계](#데이터베이스 설계)

### [ER 모델](#ER 모델)

[엔티티](#엔티티)
[약한 엔티티 타입](#약한 엔티티 타입)
[애트리뷰트](#애트리뷰트)
[관계와 관계 타입](#관계와 관계 타입)
[논리적 설계](#논리적 설계)

### [물리적 데이터베이스 설계](#물리적 데이터베이스 설계)

[보조 기억 장치](#보조 기억 장치)
[보조 기억 장치 - 자기 디스크](#보조 기억 장치 - 자기 디스크)
[버퍼 관리와 운영 체제](#버퍼 관리와 운영 체제)
[디스크 상에서 file의 레코드 배치](#디스크 상에서 file의 레코드 배치)
[file structure](#file structure)

<br>

## 관계 대수와 SQL

### 관계 대수

관계 데이터 모델에서 지원하는 두 가지 언어

1. 관계 해석 (relational caculus)
2. 관계 대수 (relational algebra)
   - 기존의 릴레이션으로부터 새로운 릴레이션을 생성
   - 피연산자와 연산이후의 결과 모두 릴레이션

- primitive operator : CPU가 바로 연산 가능

![image](https://user-images.githubusercontent.com/41130448/120252854-b02a3e80-c2c0-11eb-8300-e7b246a6e8a9.png)

- 세미 조인 - 반만 조인하는것?

- 카티션 곱 -> 양쪽의 튜플을 엮어서 가능한 모든 경우를 만드는 것

  튜플 수가 많은 경우 연산할때 시간이 겁나 많이 걸린다.

- Selection 연산자

  - 단항 연산자
  - 실렉션 조건을 predicate라고 한다. (true, false를 판단하는 기준)

- relation의 기본 원칙 : 모든 튜플들은 unique하다

- 임의의 relation으로 합집합을 만들 수는 없다. (의미가 없음)

  합집합 호환(union compatible)을 만족해야 한다.

  attribute의 수가 같고, 도메인이 같아야 함
  
- 프로젝션 할 때 중복 제거는 굉장히 오래걸리는 연산

  특별히 명령을 하지 않는 이상 중복이 허용되도록 연산이 이루어짐

- 카티션 곱

  임의의 두 릴레이션의 모든 가능한 조합을 만드는 릴레이션

  사용자가 실제로 원하는 것은 결과 릴레이션의 일부일 경우가 많다. 그래서 그 자체는 유용하지 않을 수 있다. 

  join을 하기 위한 연산이라서 중요한 것

- 관계 대수의 완전성

  관계 대수의 필수적인 연산자 : selection, projection, 합집합, 차집합, 카티션 곱 → 어떤 데이터 베이스 언어라도 이 연산자들은 꼭 표현할 수 있어야 한다.

  다른 관계 연산자 : 필수적인 관계 연산자를 두 개 이상 조합하여 표현 가능

  임의의 질의어가 적어도 필수적인 관계 대수 연산자들만큼의 표현력을 갖고 있으면 관계적으로 완전하다고 한다. (relationally complete)

- 조인 연산자

  두 개의 릴레이션으로 부터 **연관된 튜플**들을 결합함 (공통 attribute)

  릴레이션의 관계를 다루는 데에 매우 중요함

  종류

  → 세타 조인, 동등 조인(equi join), 자연 조인(natural join , 가장 많이 사용함), 외부 조인(outer join), 세미 조인

- 디비전 연산자

  나누어 지는 릴레이션이 나누는 릴레이션을 **모두** 포함하고 있어야 결과값에 포함됨

- 조인 연산은 disk에서 이루어지므로 시간이 많이 걸린다.

- 관계 대수의 한계

  - 산술 연산을 할 수 없음
  - 집단 함수 (aggregate function)을 지원하지 않음 (개별적인 검색만 가능, 통계 작업 불가)
  - 정렬을 나타낼 수 없음
  - 데이터베이스를 수정할 수 없음
  - 프로젝션의 연산 결과에 중복된 튜블을 나타내는 것이 필요할 때가 있는데 이를 명시하지 못함. 

- Data analysis

  그루핑하고, 통계 내는 것

  연도별, 부서별, 지역별 등등 다양한 기준을 가지고 한번에 그루핑하면 어렵다.

  multi dimension에서 dimension은 곧 attribute, 다차원의 경우 데이터가 많으므로 연산이 오래 걸림. 다 소팅해야 되기 때문에.

  그래서 수시로 하지 않고 주기적으로 정해놓고 가끔함

  이 분석을 batch로 (real-time으로) 처리하면 더 자주 작업을 진행할 수 있다.  

- 외부 조인

  left, right, full조인

  관련된 튜플은 모두 포함되고, 조인 조건을 만족하는 것을 넣는지 아닌지에 따라 나눔. 

<br>

### SQL

- SEQUEL부터 시작됨

- 비절차적 언어(선언적 언어)

  자신이 원하는 바만 명시, 처리하는 방법은 명시할 수 없음

- DBMS는 사용자가 SQL을 입력하면 그걸 번역해서 요구한 데이터를 찾아온다.

- 두 가지 인터페이스

  대화식(interactive), 내포된(embedded)

- 구성 요소

  데이터 정의어, 조작어, 제어어

- UPDATE DELETE INSERT

  릴레이션 하나에 대해서 수행됨. 단항 연산처럼

- SELECT

  여러 개의 릴레이션에 대해 수행 가능

- 데이터 정의어

  ![image](https://user-images.githubusercontent.com/41130448/120300552-015d2100-c307-11eb-9295-1839b1591830.png)

- 릴레이션, 도메인, 제약조건, 뷰, 권한 등을 그룹화하기 위해서 스키마 개념을 지원

  ```sql
  CREATE SCHEMA MY_DB AUTHORIZATION kim;
  
  DROP SCHEMA MY_DB RESTRICT; # 내부에 다른 릴레이션이 많이 존재하면 안삭제
  DROP SCHEMA MY_DB CASCADE; # 내부에 연결된 릴레이션 삭제
  ```

- 무결성 제약조건

  ```
  NOT NULL
  UNIQUE
  DEFAULT
  CHECK
  FOREIGN KEY REFERENCES
  ON
  (CASCADE UPDATE 등)
  ```

  DBMS 시스템 자체가 보장해주도록 설정할 수 있다.

  제약조건에 이름 붙혀서 추가 가능

  ```sql
  ALTER TABLE STUDENT ADD CONTRAINT STUDENT_PK
  	PRIMARY KEY(STNO);
  ```

- SELECT문

  정보를 검색하는 질의문

  관계 대수의 실렉션과 의미가 완전히 다르다.

  관계 대수의 실렉션, 프로젝션, 조인, 카티션 곱을 조합한 것

  ```sql
  SELECT [DISTINCT] ATTRIBUTES
  FROM RELATIONS
  [WHERE CONDITIONS]
  [GROUP BY ATTRIBUTES]
  [HAVING CONDITIONS]
  [ORDER BY ATTRIBUTES [ASC|DESC]];
  ```

- SIMILAR MATCH

  `%`를 사용

  ```SQL
  WHERE EMPNAME LIKE '이%' # 이씨 성을 갖는 사람 찾기
  ```

- 부정 검색 조건

  `<>`를 사용

  ```SQL
  WHERE DNO <> 1
  ```

- 리스트를 사용한 검색

  ```SQL
  WHERE DNO IN (1, 3)
  ```

- `NULL`과 비교를 하기 위해서는 `=`가 아닌 `IS`를 사용하자

  ```sql
  WHERE DNO IS NULL
  ```

- 집단 함수 - aggregate  function

  COUNT, SUM, AVG, MAX, MIN

- 그룹화

  `GROUP BY`절에 사용된 attribute에 동일한 값을 갖는 튜플들이 각각 하나의 그룹으로 묶임

  이 attribute를 그룹화 애트리뷰트 (grouping attribute)라고 한다.

  각 그룹에 대해서 하나의 튜플이 생성된다.

- HAVING

  그룹핑된 애트리뷰트에 조건 걸기

- 집합 연산

  UNION, EXCEPT, INTERSECT, UNION ALL, EXCEPT ALL, INTERSECT ALL

- 서브쿼리, 중첩 질의(NESTED QUERY)

  쿼리 속에 쿼리를 표현할 수 있다.

- SELF JOIN

  한 릴레이션에 속하는 튜플을 동일한 릴레이션에 속하는 튜플들과 조인하는 것

  실제로는 한 릴레이션이 접근되지만 FROM  절에 두 릴레이션이 참조되는 것처럼 나타내기 위해서 그 릴레이션에 대한 별칭을 두 개 지정해야 함.

  ```sql
  SELECT E.EMPNAME, M.EMPNAME
  FROM EMPLOYEE E, EMPLOYEE M
  WHERE E.MANAGER = M.EMPNO;
  ```

- SELECT의 WHERE절에 사용할 수 있는 연산자

  ```SQL
  IN, NOT IN, ANY(SOME), ALL, EXISTS
  ```

  EXIST → 조건을 만족하는 컬럼이 있는 경우

- 조인도 사실은 루프를 두개 도는 것이다.

- INSERT 명령을 할 때에는 무결성 제약 조건을 위배하는지 확인한다. 

  쿼리의 결과값을 INSERT문으로 삽입할 수 있다.

- 트리거

  명시적인 이벤트가 발생할 때마다 DBMS가 자동으로 사용자 정의 프로시저를 수행하도록 하는 것

  데이터베이스의 무결성을 유지하기 위한 일반적이고 강력한 도구임

  테이블 정의 시 표현할 수 없는 기업의 비즈니스 규칙들을 시행할 수 있다. (어플리케이션 대신)

  이벤트-조건-동작(ECA, Event, Condition, Action)이라고도 한다.

  조회, 검색에 대한 보고도 시킬 수 있다.

  ```sql
  CREATE TRIGGER <NAME>
  AFTER <EVENTS> ON <RELATION>
  [WHEN <CONDITION>]
  BEGIN
  	<SQLS>
  END
  ```

  연쇄적으로 트리거가 일어날 수 있음. 마치 핵분열이 일어나듯이...

- ASSERTION

  ```sql
  CREATE ASSERTION <NAME>
  CHECK <CONDITION>;
  ```

  일종의 룰이면서, 데이터베이스가 반드시 지켜야 하는 조건이다.

  predicate를 검사해서 참인 경우에만 DB 수정이 허용된다.

  무결성 제약 조건으로 볼 수 있다.

  ```sql
  CREATE ASSERTION EnrollStudentIntegrity
  CHECK (NOT EXISTS # 이런 건 있어서는 안된다
  	(SELECT	*
  	 FROM ENROLL
  	 WHERE STNO NOT IN
  	 	(SELECT STNO FROM STUDENT)));
  ```

- Embedded SQL

  모든 질의를 sql로 표현할 수는 없음 프로그래밍 언어의 개념을 사용해서 만든것

  호스트 언어(프로그래밍 언어)에 포함된 SQL문을 의미한다.

  요즘에는 SQL에 다 포함되어 있음.

  프로그래밍 언어는 릴레이션 단위로 처리하는 것이 아니라 레코드(튜플) 단위로 처리함. 따라서 데이터 구조가 불일치하는 문제(impedance mismatch)가 발생할 수 있음

  공용으로 사용하는 변수 host variable이 있다.
  
- 불일치 문제

  SQL과 호스트 언어의 처리 단위가 달라서 발생함

  이를 해결하기 위해서 커서(cursor)를 사용, 한번에 한 튜플씩 가져오는 수단

  `OPEN cursor`가 질의를 수행하고 그 결과의 첫번째 튜플 이전을 가르킴

  `FETCH`문으로 다음 튜플로 이동하고 attribute값을 명시된 호스트 변수에 복사함

  ```sql
  EXEC SQL BEGIN DECLARE SECTION;
  char name[] = "엄준식";
  char title[10];
  EXEC SQL END DECLARE SECTION;
  
  EXEC SQL
  	DECLARE title_cursor CURSOR FOR
  	SELECT title FROM employee WHERE empname = :name;
  
  EXEC SQL OPEN title_cursor;
  EXEC SQL FETCH title_cursor INTO :title;
  ```

- SQL 통신 영역(SQL Communications Area)

  C 프로그램에 내포된 sql문에 발생하는 에러를 알려줌

  SQLCA 데이터 구조의 에러 필드와 상태 표시자를 검사, 잘 수행되었는지 확인

  에러 핸들링 목적

  데이터를 성공적으로 가져오면 `SQLCODE` 값이 `0`이다.

  > 미국 도요타 급발진 원인 분석 시
  >
  > 이 프로그램이 잘못됬다는걸 증명함
  >
  > 에러 핸들링 부분이 잘못됬었다는데 그게 내포 SQL인지는 잘 머르겠네요?

<br>

### 리눅스와 MySQL 접속 방법

```shell
$ mysql -u {ID} -p
```

<br>

### 데이터베이스 설계

- 두 가지로 구분

  1. 개념적 DB 설계

     정보 사용의 모델을 개발

     실세계의 엔티티, 관계, 프로세스, 무결성 제약 조건 등을 나타내는 추상화 모델을 구축

     > 엔티티 : 서로 구분이 되면서 조직체에서 DB에 나타내려는 객체
     >
     > 관계 : 두 개 이상의 엔티티 간의 연관성
     >
     > 프로세스 : 관련된 활동
     >
     > 무결성 제약 조건 : 데이터의 정확성과 비즈니스 규칙

  2. 물리적 DB 설계

     실제로 DB를 어떻게 구현할 것인가

     물리적인 저장 장치와 접근 방식을 다룸

     DBMS 선정

- 개념적 수준의 모델

  - 이 범주에서 많이 쓰는게 바로 ER(Entity-Relationship) 모델임

    세계적으로 자연스럽게 통일된 느낌 (de facto standard)

  - 개념적 데이터 모델인 ER모델을 구현할 수 있는 구현 데이터 모델(implementation data model)이 존재함

    1. 관계 데이터 모델
    2. 계층 데이터 모델
    3. 네트워크 데이터 모델

- 설계에 필요한것

  탑다운 과정으로 내려감

  이 회사에서 사용하는 응용 프로그램이 뭔가?

  그 응용 프로그램이 사용하는 데이터가 뭔가?

  이 데이터들은 서로 어떤 관계가 있는가?

- 설계시 중요한 것

  시간의 흐름에 따른 데이터의 측면을 나타낼 수 있어야 함

  중복 최소화

  효율적인 접근 제공

  무결성 제공

  이해하기 쉬워야 함

- 설계 과정

  개념적 설계(ER 모델링) - 논리적 설계(스키마) - 스키마 정제(정규화 등) - 물리적 설계(인덱싱 등) - 보안 설계 - 구현 단계

- 요구사항 수집과 분석

  제일 어려운 것이다. 설계 변경을 최소화 하기 위해서 이 단계를 잘 해야 함

  고객들은 자기가 뭘 필요로 하는 지 잘 모름. 고객들을 잘 가이드 해야 함. 이 부분을 컨설턴트들이 하는데, 부가 가치가 높은 부분임. 분석된 결과를 가지고 설계를 의뢰 할 수 있음

  요구사항에 대한 지식을 기반으로 관련된 엔티티, 관계, 애트리뷰트 등을 파악해야 함

  데이터 처리 시 전형적인 연산, 연산들의 의미, 접근하는 데이터의 양을 분석

- 물리적 설계 시 성능상 고려할 점

  1. 응답 시간 : 질의와 갱신이 평균 / 피크 시간 때 얼마나 오래 걸릴 것인가

  2. 트랜잭션 처리율 : 1초당 얼마나 많은 트랜잭션들이 평균 / 피크시간 때 처리될 수 있는가?

     벤치마킹해서 성능 평가

  3. 전체 DB에 대핸 보고서를 생성하는 데 얼마나 오래 걸릴 것인가?

  → 평균 / 피크 시간을 모두 고려해야 함

  → 튜닝을 위한 SW를 사용할 수도 있음

- 트랜잭션 설계

  - 요구사항 수집과 분석 후, DB 설계에 대해 별도로 진행
  - 완성될 데이터베이스에서 동작할 응용 프로그램에 대한 것
  - DB 스키마는 트랜잭션에서 요구하는 모든 정보를 포함해야 한다.
  - 검색, 갱신, 혼합 으로 구분하고 입력, 출력, 동작 등을 식별
  - 트랜잭션의 종류별 빈도 수도 고려해야 한다. 주요 트랜잭션을 잘 처리할 수 있도록 데이터를 튜닝할 필요성이 있음

<br>

## ER 모델

- DB 설계를 용이하게 하기 위해 제안된 것

  현재는 EER(Enhanced Entity Relationship)모델 사용

- 기본 구문 : 엔티티, 관계, 애트리뷰트

  기타 구문 : 카디날리티 비율, 참여 제약 조건 등

- CASE 도구들에서는 ER 설계를 자동적으로 DB 스키마로 변환 가능

- 또다른 표기법 : 새발 표기법

  좀더 컴팩트하게 표기하기 위해서 사용

  ![image](https://user-images.githubusercontent.com/41130448/120877970-585b4280-c5f4-11eb-8621-7f080b5ed8e5.png)

  ![image](https://user-images.githubusercontent.com/41130448/120877978-690bb880-c5f4-11eb-96c1-165c3aeeacb1.png)

  ![image](https://user-images.githubusercontent.com/41130448/120877987-75901100-c5f4-11eb-8681-43783a5dd563.png)

  

<br>

### 엔티티

- 엔티티

  - 설계자가 결정하는 것

  - 독립적으로 존재해서, 고유하게 식별 가능한 객체

  - 사원처럼 실체가 있을 수도 있고, 생각이나 개념처럼 추상적일 수도 있음

  - 같은 타입을 묶어서 엔티티 타입/집합 이라고 함, 엄격하게 구분할 필요는 X

    1. 엔티티 타입(스키마)

       동일한 애트리뷰트를 가진 엔티티의 틀 → 같은 애트리뷰트는 같은 종류의 실체라는 것

       관계 모델의 릴레이션의 내포에 해당

       ER 다이어그램에서 직사각형으로 나타냄

    2. 엔티티 집합(인스턴스)

       동일한 애트리뷰트를 가진 엔티티들의 모임

       관계 모델의 릴레이션의 외연에 해당

  - 하나의 엔티티는 한 개 이상의 엔티티 집합에 속할 수 있음

- 엔티티의 두 가지 타입

  1. 강한 엔티티 타입
     - 독자적으로 존재
     - 자신의 키 애트리뷰트 사용하며 고유하게 식별 가능
  2. 약한 엔티티 타입
     - 키를 형성하기에 충분한 애트리뷰트 X
     - 소유 엔티티 타입이 있어야 존재 가능 (dependent)
     - 소유 엔티티 타입의 키 애트리뷰트를 결합해서 식별, 따라댕겨야 함

<br>

### 약한 엔티티 타입

- 키를 형성하기에 충분한 애트리뷰트 X

- 소유 엔티티/식별 엔티티 타입으로부터 키 애트리뷰트를 제공받음

  > 회사 입장에서 [사원 - 부양 가족] 관계에서 부양 가족은 사원에 딸려 있는 것
  >
  > 사원이 없어지면 의미 없는 정보

- ER 다이어그램에서 이중선 직사각형으로 표현

- 부분 키 (partial key)

  부양 가족의 이름처럼 한 사원에 속한 부양 가족 내에서는 서로 다르지만, 회사 전체 사원들의 부양가족 전체에서는 같은 경우가 생길 수 있는 애트리뷰트

  점선 밑줄을 그어서 표기

<br>

### 애트리뷰트

- 하나의 엔티티를 설명하는 집합들
-  애트리뷰트의 도메인 : 그 애트리뷰트가 가질 수 있는 가능한 값들의 집합
- ER 다이어그램에서 타원형으로 나타내며, 기본 키 애트리뷰트는 밑줄 그어 표시
- 요구사항 명세에서 명사나 형용사로 표현
- 엔티티와 달리 독립적인 의미를 갖지 않음, 그 자체로 어떤 의미가 있지는 않음
- 엔티티 타입과 실선으로 연결
  1. 단순 애트리뷰트
     - 더 이상 다른 애트리뷰트로 나눌 수 없음
     - 실선과 타원으로 표시함
     - ER 애트리뷰트에서 대부분임
  2. 복합 애트리뷰트
     - 두 개 이상의 애트리뷰트로 이루어짐
     - 동일한 엔티티 타입이나 관계 타입에 속하는 애트리뷰트 중에서 밀접하게 연관된 것을 모아놓은 것 
     - 계층 구조
  3. 단일 값 애트리뷰트(single-valued attribute)
     - 각 엔티티마다 정확히 하나의 값을 갖는다, 여러 개의 값을 갖지 않음
     - 단순 애트리뷰트와 동일하게 표현
     - ER 다이어그램에서 대부분임
  4. 다치 애트리뷰트(multi-valued attribute)
     - 각 엔티티마다 여러 개의 값을 가질 수 있음
     - ER 다이어그램에서 이중선 타원으로 표시함
     - 관계형 DB에서 여러 개의 애트리뷰트 값을 가질 수 없음, 어케 표현할까용?
  5. 저장된 애트리뷰트(stored attribute)
     - 다른 애트리뷰트와 독립적으로 존재
     - 표현은 단순 애트리뷰트와 동일
     - ER 다이어그램의 대부분
     - 사원의 이름, 급여 등
  6. 유도된 애트리뷰트 (derived attribute)
     - 다른 애트리뷰트의 값으로부터 얻어짐
     - 관계형 DB에서 릴레이션의 애트리뷰트로 포함시키지 않는 게 좋다.
     - ER 다이어그램에서 점선 타원으로 표현함
     - 나이 같은 것

<br>

### 관계와 관계 타입

- 엔티티들 사이에 존재하는 연관, 연결

- 관계 집합은 동질의 관계들의 집합

  관계 타입은 동질의 관계들의 틀

  > 엄격히 구분할 필요는 없다.

- 요구사항 명세에서 주로 동사를 표현한다.

- ER 다이어그램에서 다이아몬드로 표현

- 엔티티를 관계 타입에 실선으로 연결

- 관계도 특징을 기술하는 애트리뷰트가 존재 가능

  키 애트리뷰트를 갖지 않음 (WHY?????)

  관계는 키를 갖는다는 게 의미가 없다. 키의 역할은 엔티티의 기본 키들이 한다. (참조키들)

  > 관계를 supply chain 자동화 할 때 사용 가능. 많은 부품을 관리할 때 납기, 장소, 수량 등을 잘 관리해야 함

- 차수 (degree)

  - 어떤 관계로 연결된 엔티티 타입들의 개수
  - 실세계에서는 두 개의 엔티티 타입을 연결하는 2진 관계가 제일 많다.

- 카디날리티

  - 카디날리티 비율 : 한 엔티티가 다른 엔티티와 맺을 수 있는 관계의 수

  - 관계 타입에 참여하는 엔티티들의 가능한 조합을 제한. 반드시 참여하도록 할 수도 있음

  - 1:1, 1:N, M:N으로 구분

    > 1 to many는 보통 계층 구조가 많음

  - 간선 위에 카디날리티 정보를 표시

  - 카디날리티 비율의 최소값과 최대값

    `(min, max)`로 표시함. mandatory/optional을 표현할 수 있음

- 역할(role)

  - 관계를 명확히 하는 역할
  - 간선 위에 표시

- 전체 참여와 부분 참여 (total/partial participiation)

  - 모든 엔티티가 관계에 참여하는지의 여부에 따라 나눔

  - 약한 엔티티 타입은 항상 관계에 전체 참여함

    ER 다이어그램에서 이중 실선으로 표시

  - 관계에 대한 중요한 제약 조건임

- 기타 관계

  1. 다중 관계 (multiple relationship)

     두 엔티티 타입 사이에 두 개 이상의 관게타입이 존재할 수 있다.

  2. 순환적 관계 (recursive)

     하나의 엔티티 타입이 동일한 관계 타입에 두 번 이상 참여

- ER 스키마 작성 지침

  - 엔티티는 키 이외에 설명 정보가 추가로 필요함
  - 다치 애트리뷰트는 엔티티로 분류해야 한다.
  - 가능한 복합 식별자는 피하자.
  - 관계는 독자적으로 존재할 수 없지만, 엔티티 타입과 관계 타입을 엄밀하게 구분하는 것은 어렵다.

<br>

### 논리적 설계

- ER 스키마를 관계형 DBMS의 릴레이션으로 사상시키기

- ER 스키마에서는 엔티티 타입과 관계 타입이 존재하지만, 관계형 DB에는 엔티티 타입과 관계 타입을 구분하지 않고 릴레이션들만 있음

- 릴레이션으로 사상할 대상이 ER 스키마에서 엔티티 타입인지, 관계 타입인지

  엔티티 타입이라면 정규 엔티티 타입인지, 약한 엔티티 타입인지

  관계 타입이라면 2진 관계 타입인지 3진 이상의 관계 타입인지

  애트리뷰트가 단일 값 애트리뷰트인지, 다치 애트리뷰트인지

  등에 따라서 사상하는 방법이 달라진다.

- ER 모델을 릴레이션으로 사상하는 7 단계의 알고리즘이 있다.

1. 정규 엔티티 타입과 단일 값 애트리뷰트

   - ER 스키마의 각 정규 엔티티 타입 E에 대해서 하나의 릴레이션 R을 생성한다.
   - E에 있던 단순 애트리뷰트들을 릴레이션 R에 모두 포함시킨다.
   - E에서 복합 애트리뷰트는 그 복합 애트리뷰트를 구성하는 단순(leaf) 애트리뷰트들만 릴레이션 R에 포함시킨다.
   - E의 기본 키가 릴레이션 R의 기본 키가 된다.

2. 약한 엔티티 타입과 단일 값 애트리뷰트

   - ER 스키마에서 소유 엔티티 타입 E를 갖는 각 약한 엔티티 타입 W에 대하여 릴레이션 R을 생성한다.
   - W에 있던 모든 단순 애트리뷰트들을 릴레이션 R에 포함시킨다.
   - 소유 엔티티 타입에 해당하는 릴레이션의 기본 키를 약한 엔티티 타입에 해당하는 릴레이션에 외래 키로 포함시킨다.
   - 약한 엔티티 타입에 해당하는 **릴레이션 R의 기본 키**는 **약한 엔티티 타입의 부분 키**와 **소유 엔티티 타입에 해당하는 릴레이션을 참조하는 외래 키**의 조합으로 이루어진다.

3. 2진 1:1 관계 타입

   - ER 스키마의 각 2진 1:1 관계 타입 R에 대하여, R에 참여하는 엔티티 타입에 대응되는 릴레이션 S와 T를 찾음

   - 릴레이션으로 바꾸는 방법들

     1. S와 T 중에서 한 릴레이션을 선택하여, 만일 S를 선택했다면 T의 기본 키를 S의 외래키로 포함시킨다. (외래키 자체가 관계를 표현)

        S와 T 중에서 관계 타입에 완전하게 참여하는 릴레이션을 S의 역할을 하는 릴레이션으로 선택한다.

        관계 타입 R이 가지고 있는 모든 단순 애트리뷰트(복합 애트리뷰트를 갖고 있는 경우에는 복합 애트리뷰트를 구성하는 단순 애트리뷰트)들을 S에 대응되는 릴레이션에 포함시킨다.

        > 하지만 이 외래키가 관계를 포함하는 것인지 의도를 쉽게 알 수 없다는 문제가 있음
        >
        > 참조 관계이기 때문에 외래키를 어디에 넣느냐에 따라서 조인 방식이 달라질 수 있다. 한쪽은 인덱스가 안되어 있는 경우도 있고 이런 요인에 따라서 방향성이 달라짐.

     2. 관계를이한 릴레이션 R을 생성함. 양쪽 S, T의 기본 키를 각각 외래 키로 갖는다. 관계에 해당하는 애트리뷰트도 R에 포함한다. (복합 애트리뷰트인 경우 복합 애트리뷰트를 구성하는 단순 애트리뷰트)

        > 이 방법이 제일 중립적이고 일반적인 방법이다. 하지만 항상 릴레이션의 join을 두번 해야 하므로 오버헤드가 커질 수 있다.
        >
        > 조인 오버헤드를 줄이기 위해서 1번 방법을 사용할 수 있다.

     3. 두 엔티티 타입이 관계 타입 R에 완전하게 (모두) 참여할 때는 두 엔티티 타입과 관게타입을 하나의 릴레이션으로 합칠 수도 있다. (예외적인 케이스이긴 하다.)

        > 두 엔티티는 의미적으로 독립적인 엔티티이기 때문에, 합쳤을 때 의미상으로 애매해진다. 실질적인 퍼포먼스 측면에서는 제일 좋을 수 있다.

4. 정규 2진 1:N 관계 타입

   - 관계 타입 R에 대해서 N측(참여 엔티티 타입)에 대응되는 릴레이션 S를 찾는다.
   - 관계 타입 R에 참여하는 1측(엔티티 타입)에 대응되는 릴레이션 T의 기본 키를 릴레이션 S에 외래 키로 포함시킨다.
   - S의 기본 키를 T의 외래 키로 포함시키면 애트리뷰트에 값의 집합이 들어가거나 정보의 중복이 많이 발생할 수 있다.
   - 관계 타입 R이 가지고 있는 모든 단순 애트리뷰트를 S 릴레이션에 포함시킨다.

5. 2진 M:N 관계 타입

   - 관계 타이에 해당하는 릴레이션 R을 생성한다.
   - 참여 엔티티 타입에 해당하는 릴레이션들의 기본 키를 R의 외래 키로 포함시킨다. 이들의 조합이 R의 기본 키가 된다.
   - 관계 타입 R의 단순 애트리뷰트는 릴레이션 R에 포함시킨다. 

6. 3진 이상의 관계 타입

   - 각 관계 타입 R에 대하여 릴레이션 R을 생성한다.
   - 관계 타입 R에 참여하는 모든 엔티티 타입에 대응되는 릴레이션들의 기본 키를 R에 외래 키로 포함시킨다.
   - 관계 타입 R의 단순 애트리뷰트는 릴레이션 R에 포함시킨다.
   - 일반적으로 외래 키들의 조합이 릴레이션 R의 기본 키가 된다.
   - 관계 타입 R에 참여하는 엔티티 타입들의 카디날리티가 1:N:N인 경우, 카디날리티가 1인 릴레이션의 기본 키를 참조하는 외래 키를 제외한 나머지 외래 키들의 조합이 릴레이션 R의 기본 키가 된다. 

7. 다치 애트리뷰트

   - 각 다치 애트리뷰트에 대하여 릴레이션 R을 생성한다.
   - 다치 애트리뷰트에 해당하는 애트리뷰트를 릴레이션 R에 포함시키고, 다치 애트리뷰트를 애트리뷰트로 갖는 엔티티 타입이나 관계 타입에 해당하는 릴레이션의 기본 키를 릴레이션 R에 외래 키로 포함시킨다.
   - 릴레이션 R의 기본 키는 다치 애트리뷰트와 외래 키의 조합이다.

<br>

## 물리적 데이터베이스 설계

- 데이터에 대한 효율적인 접근을 제공하기 위해서 저장 구조와 접근 방법을 다룬다. 

  storage structure에 따라서 접근 방식이 달라진다. 

- 파일 구조 (storage structure) / OS와 관련이 있다.

  논리적 설계의 데이터 구조를 보조 기억 장치 상의 file로 사상한다.

- 예상 빈도, 데이터베이스 질의와 트랜잭션을 분석한다. 

  질의를 효율적으로 지원하기 위해서 인덱스 구조를 적절히 사용할 수 있다.

  요즘은 솔루션을 통해서 질의 자체를 통계낼 수도 있다.

- 특정 DBMS의 특성을 고려해서 설계를 진행할 수 있다.

- 원래는 하드 디스크에 저장했지만 요즘은 flash memory에 저장

  flash memory에 어떻게 파일을 저장하는지가 중요함

  기본 원리는 비슷하기 때문에 하드 기준으로 살펴보자.

- optimal solution을 찾는 것은 아주 어렵다. 그래서 optimal에 가까운 것을 찾는다.

### 보조 기억 장치

- 데이터들이 저장되는 공간. 장기간 보관하기 위해서 주로 디스크를 사용함.

  옛~날에는 테이프를 사용함. 용량이 크고 싸다.

- 검색을 할 때에는 디스크 상에서 원하는 데이터를 포함하고 있는 블록을 읽는다. 주기억장치에 가지고 와서 찾는다.

- 데이터가 변경된 경우에는 해당 블록을 디스크에 다시 기록한다.

- 블록 단위는 다양함. 512byte ~ 수 kb

  현재는 통상 4kb 정도, 더 클 수도 있음

- 각 file은 고정된 크기의 블록으로 나뉘어서 저장된다.

- 무선 통신 속도는 빠르지만 저장 장치에 기록하는 속도가 느려서 다운로드가 느릴 수 있음

### 보조 기억 장치 - 자기 디스크

- 자기 물질로 만들어진 여러 개의 판으로 이루어짐

  각 판은 트랙과 섹터로 구분

  정보는 디스크 표면 상의 동심원(트랙)을 따라서 저장됨

- 각 면마다 디스크 헤드가 존재

- 실린더 : 여러 개의 디스크 면 중에서 같은 지름을 갖는 트랙들

- 블록은 한 개 이상의 섹터로 이루어진다.

- 디스크에서 임의의 블록을 읽어오거나 기록하는 데 걸리는 시간

  seek time + rotational delay(회전 지연 시간) + transfer time

  > seek time : 헤드가 트랙을 따라서 움직이는 시간
  >
  > 하드 디스크 도는 속도 : 1분에 만번 정도 (빨리 돌수록 비쌈)

- 플래시 메모리는 ㄹㅇ 랜덤 액세스가 된다.

  데이터가 어디에 있던간에 읽어 오는 시간이 똑같은걸 보장함

  디스크에서는 헤드를 실린더마다 만들 수가 없어서 그게 안됨.

  > 한 파일(relation)을 한 실린더에다가 저장하면 움직이지 않고 빠르게 읽을 수 있음

### 버퍼 관리와 운영 체제

- 디스크 입출력은 컴퓨터 시스템에서 가장 속도가 느린 작업임

  따라서 입출력 횟수를 줄이는 것이 DBMS의 성능을 향상시키는 데에 중요하다.

  > 매직 넘버 : 이론적으로는 알 수 없지만 실제 실험적으로 했을 때 가장 좋은 숫자 (엔지니어링 넘버)
  >
  > 몇 번 읽어오면 가장 좋은지 알아내기

- 가능하면 많은 블록을 혹은, 자주 참조되는 블록을 메모리 상에 유지해 놓으면 블록 전송 횟수를 줄일 수 있다.

- 버퍼는 디스크 블록을 저장하는 데 사용되는 주기억 장치 공간

- 버퍼 관리자는 운영체제의 구성요소이다. 주기억 장치 내에서 버퍼 공간을 할당하과 관리하는 일을 맡는다.

- 운영체제에서 버퍼 관리를 위해서 LRU 알고리즘을 사용하는데, 이는 데이터 베이스에 대해서는 항상 우수한 성능을 갖지는 않는다. 

  DBMS가 관리하는 메타 데이타는 스키마 정보가 된다. 스키마 정보는 자주 액세스하니까 이런건 버퍼에 올려 놓는 것이 좋다. 

  OS는 이런 어플리케이션의 특징점을 잘 모른다. 

### 디스크 상에서 file의 레코드 배치

- 릴레이션의 애트리뷰트는 고정 길이 또는 가변 길이의 필드로 표현 된다.

  > 고정 길이의 경우에는 overwrite도 좀 편한 편이다. 
  >
  > 가변길이의 경우에는 내용물이 변경되었을 때 핸들링하는 알고리즘이 복잡해질 수 있다. 

- 연관된 필드들이 모여서 고정 길이 또는 가변 길이의 레코드가 된다.

- 한 **릴레이션**을 구성하는 **레코드들의 모임**이, **file**이라고 부르는 **블록들의 모임**에 저장된다. 

- 파일, 블록, 레코드의 구조도

  보통 가장 첫번째 블록에 제어 정보(control block)을 저장한다. 헤더라고도 부름.

  ![image](https://user-images.githubusercontent.com/41130448/120881679-d37d2280-c60d-11eb-88c0-dc19a91b183c.png)

- 위와 같은 블록이 실제 물리적으로 연속되어 있지는 않다. 

  튜플은 다이나믹한 구조이므로 계속 변화하기 때문에 연속성을 유지시켜 줄 수 가 없음

- 인접한 블록들을 읽는 경우에는 seek time과 rotation delay가 걸리지 않으므로 입출력 속도가 빠름. 따라서 블록들이 인접하도록 한 file의 블록들을 재조직할 수 있다. 

  이게 디스크 조각모음인듯??

- BLOB(Binary Large Object)

  - 이미지(GIF, JPG), 동영상(MPEG, AVI) 등의 대규모 크기의 데이터를 저장하는 데 사용
  - BLOB의 최대 크기는 MS SQL에서 2GB 가능

- 채우기 인수 (fill factor)

  - 각 블록에 레코드를 채우는 공간의 비율,  한 블럭을 레코드로 몇 %를 채울 것인가.

  - 나중에 레코드가 삽입될 때 기존의 레코드를 이동하는 가능성을 줄이기 위해서 사용한다.

    무조건 꽉꽉 채워서 저장한다고 좋은 것은 아님

  - 이 비율은 application 성격에 따라서 달라짐. 엔지니어링 value임. 현장 지식이 반영되어야 한다.

- 고정 길이 레코드

  i번째 레코드를 접근하기 쉽다.

  레코드 삭제 시 채워넣는 방법들

  1. 여러 개의 레코드를 쭉 올린다.
  2. 한 개의 레코드를 빼서 채워 넣는다. (가변 길이 레코드는 이런 작업이 불가능함)

- 파일 내의 클러스터링 (intra-file clustering)

  한 file 내에서 함께 검색될 가능성이 높은 레코드들을 디스크 상에서 물리적으로 가까운 곳에 모아 두는 것 (연속적으로 저장)

  데이터 마이닝에서 많이 사용함

- 파일 간의 클러스터링 (inter-file clustering)

  논리적으로 연관되어 함께 검색될 가능성이 높은 두 개 이상의 file에 속한 레코드들을 디스크 상에서 물리적으로 가까운 곳에 저장하는 것

  서로 다른 레코드들을 클러스터링 할 수 있음

### file structure

1. heap file

   - 레코드가 삽입되는 순서대로 저장함. 가장 단순한 형태

   - 새로 들어오면 맨 끝에 넣고(append), 검색하기 위해서는 모든 레코드를 순차적으로 접근해야 함. 삭제하는 경우 검색 후 삭제 처리하고, 해당 공간을 재사용하지 않음(다 이동시키지 않기 위해서)

   - 고속으로 데이터를 입력받는 경우 좋다. 

   - 성능을 좋게 유지하려면 주기적으로 파일을 재조직 해야 한다. 삭제 작업이 많이 이루어진 경우 빈 공간이 많아지기 때문이다.

   - 성능에 대해서

     1. 모든 레코드를 참조하고, 레코드 접근 순서는 중요하지 않는 질의의 경우 쓰기 좋다.

     2. 특정 레코드를 검색하는 경우에는 비효율적이다.

        삽입만 빠르고 나머지는 다 속도가 구림

        그래서 특수한 경우가 아니면 잘 쓰지 않는다.

2. sequential file

   - 하나 이상의 필드의 값(search key)을 기준으로 정렬해놓음
   - 삽입 연산은 레코드의 순서를 고려해야 하므로 시간이 많이 걸림
   - 삭제 시에도 heap file처럼 빈 공간으로 남김
   - 키를 기반으로 하므로 탐색시에만 빠르고 나머지 연산은 다 구리다.
   - DB 응용 시 거의 쓰지 않음

3. indexed sequential file - 단일 단계 인덱스

   - 인덱스를 통해서 임의의 레코드를 접근할 수 있음

   - 각 엔트리는 <search key, record pointer>로 구성도미

   - 엔트리들은 탐색 키 값의 오름차순으로 정렬된다.

     ![image](https://user-images.githubusercontent.com/41130448/120883246-07a91100-c617-11eb-8eac-4874a3bb2ae0.png)

   - 인덱스는 데이터 file 과는 별도의 file로 저장됨

   - 인덱스의 크기는 데이터 파일보다 훨씬 작음

   - 하나의 파일에 여러 개의 인덱스를 정의할 수 있음

     ![image](https://user-images.githubusercontent.com/41130448/120883284-4dfe7000-c617-11eb-989b-9c9b0de4e0e9.png)

   - 인덱스가 정의된 필드를 탐색 키라고 부른다.

     탐색 키의 값들은 후보 키처럼 각 튜플마다 고유하지는 않음

   - 탐색 키는 어떤 애트리뷰트도 다 쓸 수 있음

     하지만 카디널리티를 고려해서 효율적인 것을 선택해야 함. 안그러면 인덱싱하는 의미가 없다.

   - 탐색 키 값을 기준으로 오름차순 정렬되어 있으므로 이진 탐색 가능

   - 기본 인덱스 (primary index)

     - 탐색 키가 데이터 파일의 PK인 경우 기본 인덱스라고 한다.

     - 기본 인덱스는 PK 값에 따라서 정렬된 데이터 파일에 대해서 정의된다.

     - 기본 인덱스는 보통 희소(sparse) 인덱스로 유지가능하다. 

       희소 인덱스는 특정 범위로 분절해서 대표값만 추려서 만드는 것

       희소 인덱스로 만드려면 무조건 데이터 파일이 정렬이 되어 있어야 한다. 

     - 각 릴레이션마다 최대 한개의 기본 인덱스를 가질 수 있다.

   ![image](https://user-images.githubusercontent.com/41130448/120883463-4a1f1d80-c618-11eb-80d2-557e4ae43d29.png)

   - 클러스터링 인덱스 (clusteting index) 7-48:51
     - 탐색 키 값에 따라 정렬된 데이터 파일에 대해 정의된다.
     
     - 각각의 상이한 키 값마다 하나의 인덱스 엔트리가 인덱스에 포함된다.
     
     - 범위에 대한 질의(Range query)에 유용하다.
     
       범위의 시작 값에 해당하는 인덱스 엔트리를 먼저 찾고, 범위에 속하는 인덱스 엔트리들을 따라가면서 레코드를 검색할 때 디스크에서 읽어오는 블록 수가 최소화된다.
     
     - 어떤 인덱스 엔트리에서 참조되는 데이터 블록을 읽어 오면 그 데이터 블록에 들어 있는 대부분의 레코드들은 범위를 만족한다.
     
   - 보조 인덱스 (secondary index)

     - 한 file은 한 가지 필드의 조합에만 대해서 정렬할 수 있음

     - 보조 인덱스는 탐색 키 값에 따라 정렬되지 않은 데이터 파일에 대해 정의된다.

     - 보조 인덱스는 보통 밀집 인덱스이다. 따라서 같은 수의 레코드들을 접근할 때 보조 인덱스를 통하면, 기본 인덱스보다 디스크 접근 횟수가 증가할 수 있다. 

       entry가 더 많아짐.

   - 희소 인덱스와 밀집 인덱스 비교

     - 희소 인덱스는 각 데이터 블록마다 한 개의 엔트리를 갖는다.

       밀집 인덱스는 각 레코드마다 한 개의 엔트리를 갖는다.

     - 레코드의 길이가 블록 크기보다 훨씬 작은 일반적인 경우에는, 희소 인덱스의 엔트리 수가 밀집 인덱스의 엔트리 수보다 훨씬 적다. 

     - 희소 인덱스는 일반적으로 밀집 인덱스에 비해 인덱스 단계 수가 1 정도 적다. 따라서 인덱스 탐색 시 디스크 접근 수가 1만큼 적을 수 있다. 

     - 희소 인덱스는 밀집 인덱스에 비해 모든 갱신과 대부분의 질의에 대해 더 효율적이고 성능이 좋다.

       하지만 질의에서 인덱스가 정의된 애트리뷰트만 검색하는 경우에는 (COUNT 질의 등), 데이터 파일을 접근할 필요 없이 인덱스만 접근해서 질의를 수행할 수 있기 때문에 밀집 인덱스가 더 유리하다.

     - 한 파일은 한 개의 희소 인덱스와 여러 개의 밀집 인덱스를 가질 수 있다. 

   - 클러스터링 인덱스와 보조 인덱스의 비교

     - 클러스터링 인덱스는 희소 인덱스일 경우가 많고, 범위를 질의할 때 좋다.
     - 보조 인덱스는 밀집 인덱스이므로, 일부 질의에 대해서는 파일을 접근할 필요 없이 처리할 수 있다.

   - 다단계 인덱스

     - 인덱스 자체가 클 경우에는 인덱스를 탐색하는 시간도 오래 걸릴 수 있다.

     - 인덱스 엔트리를 탐색하는 시간을 줄이기 위해서 단일 단계 인덱스를 디스크 상의 하나의 순서 파일로 간주하고, 단일 단계 인덱스에 대해서 다시 인덱스를 정의할 수 있다.

     - 다단계 인덱스는 가장 상위 단계의 모든 인덱스 엔트리들이 한 블록에 들어갈 수 있을 때까지 이런 과정을 반복한다.

     - 가장 상위 단계 인덱스를 마스터 인덱스라고 부른다.

       마스터 인덱스는 한 블록으로 이루어지므로 주기억장치에 상주할 수 있다.

     - 대부분의 다단계 인덱스는 B+ tree를 사용한다. 

4. hash file

