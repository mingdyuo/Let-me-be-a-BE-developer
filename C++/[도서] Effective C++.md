## Chapter 1 C++에 왔으면 C++의 법에 따릅시다.

### 항목 0 용어 설명

- 암시적 타입 변환에 생성자가 사용될 여지를 남겨둬야 할 필요성이 있지 않으면 가능한 `explicit` 으로 선언하자.

### 항목 1 C++를 언어의 연합체로 바라보는 안목은 필수

C++을 다음 4가지 항목의 연합체로 보자.

1. C

   아무튼 C++의 기본은 C에 있다.

2. 객체 지향 개념의 C++

3. 템플릿 C++

   TMP가 나온 배경이 되는 기능. 근데 주류로 쓰지는 않나보다.

4. STL

   컨테이너, 반복자, 알고리즘, 함수 객체가 얽혀 있다.

C++을 사용해서 잘 프로그래밍 하려면 어떤 규칙을 적용해야 할까? 그건 위의 4가지 항목 중 어떤 부분을 사용하느냐에 따라 달라진다!

예를 들어서 값/객체를 넘길때 C style에서는 값 전달이, 객체 지향 C++에서는 상수 객체 참조자 전달이, 템플릿에서는 어떤 객체인지도 알 수 없으므로 특히 상수 객체 참조자 전달이, STL에서는 포인터를 본떠 만든 반복자와 값 전달이 좋다.

### 항목 2 `#define`을 쓰려거든 `const`, `enum`, `inline`을 떠올리자.

### 항목 3 낌새만 보이면 `const`를 들이대 보자!

### 항목 4 객체를 사용하기 전에 반드시 그 객체를 초기화하자

<br>

## Chatper 4 설계 및 선언

### 항목 20 '값에 의한 전달'보다는 '상수 객체 참조자에 의한 전달 방식이 대개 낫다.

- 복사 손실(slicing problem) 

  - 파생 클래스 객체가 전달될 때 기본 클래스 객체로 전달되는 경우. 가끔 일어난다.

  - 이게 일어나면 파생 클래스 객체로 동작하는 특징들이 잘려 나간다. 그래서 slicing problem

  - `const reference`로 매개변수를 넘기면 이 문제를 걱정하지 않아도 된다.

  - 예)

    A 클래스를 상속받은 클래스 B가 있다. A에는 가상함수 `a()`가 있으며, B에도 구현되어 있다. 

    이 때 A를 값의 의한 전달로 받는 함수에 B로 만든 객체를 넣으면 생성자 A만 호출되고 B의 특성을 갖는 영역은 사라진다. `B::a()`는 사용하지 못한다.

    이 때 A를 const reference로 받는 함수에 B로 만든 객체를 넣으면 `B::a()`가 잘리지 않는다.

- 레퍼런스는 내부에서 포인터를 써서 구현된다.

  레퍼런스를 전달한다는 것은 결국 포인터를 전달하는 것과 일맥상통하다.

- 전달하는 객체의 타입이 `int`와 같이 built-in인 경우에는 값으로 넘기는 편이 대체로 더 효율적이다.

  1. **단순히 타입 크기가 작은 경우를 의미하는 것이 아니다.** 작더라도 user-defined 객체라면 복사하는 비용이 클 수 있다. 

     컴파일러 중에는 built-in과 user-defined 타입을 아예 다르게 취급하는 것도 있다. 

  2. 또한 user-defined 타입은 언제든 크기가 변할 수 있으므로 call by value로 사용하는 것은 권장되지 않을 것이다.

- STL의 `iterator`와 `functor`는 call by value로 설계되어 있다.

- 다음 3가지 타입은 call by value를 사용해도 저비용이라고 여겨질 수 있는 것들이다. 이외는 가능하면 상수 레퍼런스를 사용하자.

  1. built-in type
  2. STL iterator
  3. 함수 객체