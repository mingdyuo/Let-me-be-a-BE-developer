# 데이터베이스

[KOCW 데이터베이스 강의](http://www.kocw.net/home/search/kemView.do?kemId=1064626)

- [x] 6차시 물리적 데이터베이스 설계 (21/06/05)
- [x] 7차시 물리적 데이터베이스 설계 (21/06/05)
- [x] 7차시 물리적 데이터베이스 설계, 릴레이션 정규화 (21/06/08)
- [x] 8차시 릴레이션 정규화 (21/06/08)
- [x] 9차시 릴레이션 정규화, 뷰와 시스템 카탈로그 (21/06/08, 09)
- [x] 10차시 뷰와 시스템 카탈로그 (21/06/09)



## 물리적 데이터베이스 설계

- 데이터에 대한 효율적인 접근을 제공하기 위해서 저장 구조와 접근 방법을 다룬다. 

  storage structure에 따라서 접근 방식이 달라진다. 

- 파일 구조 (storage structure) / OS와 관련이 있다.

  논리적 설계의 데이터 구조를 보조 기억 장치 상의 file로 사상한다.

- 예상 빈도, 데이터베이스 질의와 트랜잭션을 분석한다. 

  질의를 효율적으로 지원하기 위해서 인덱스 구조를 적절히 사용할 수 있다.

  요즘은 솔루션을 통해서 질의 자체를 통계낼 수도 있다.

- 특정 DBMS의 특성을 고려해서 설계를 진행할 수 있다.

- 원래는 하드 디스크에 저장했지만 요즘은 flash memory에 저장

  flash memory에 어떻게 파일을 저장하는지가 중요함

  기본 원리는 비슷하기 때문에 하드 기준으로 살펴보자.

- optimal solution을 찾는 것은 아주 어렵다. 그래서 optimal에 가까운 것을 찾는다.

### 보조 기억 장치

- 데이터들이 저장되는 공간. 장기간 보관하기 위해서 주로 디스크를 사용함.

  옛~날에는 테이프를 사용함. 용량이 크고 싸다.

- 검색을 할 때에는 디스크 상에서 원하는 데이터를 포함하고 있는 블록을 읽는다. 주기억장치에 가지고 와서 찾는다.

- 데이터가 변경된 경우에는 해당 블록을 디스크에 다시 기록한다.

- 블록 단위는 다양함. 512byte ~ 수 kb

  현재는 통상 4kb 정도, 더 클 수도 있음

- 각 file은 고정된 크기의 블록으로 나뉘어서 저장된다.

- 무선 통신 속도는 빠르지만 저장 장치에 기록하는 속도가 느려서 다운로드가 느릴 수 있음

### 보조 기억 장치 - 자기 디스크

- 자기 물질로 만들어진 여러 개의 판으로 이루어짐

  각 판은 트랙과 섹터로 구분

  정보는 디스크 표면 상의 동심원(트랙)을 따라서 저장됨

- 각 면마다 디스크 헤드가 존재

- 실린더 : 여러 개의 디스크 면 중에서 같은 지름을 갖는 트랙들

- 블록은 한 개 이상의 섹터로 이루어진다.

- 디스크에서 임의의 블록을 읽어오거나 기록하는 데 걸리는 시간

  seek time + rotational delay(회전 지연 시간) + transfer time

  > seek time : 헤드가 트랙을 따라서 움직이는 시간
  >
  > 하드 디스크 도는 속도 : 1분에 만번 정도 (빨리 돌수록 비쌈)

- 플래시 메모리는 ㄹㅇ 랜덤 액세스가 된다.

  데이터가 어디에 있던간에 읽어 오는 시간이 똑같은걸 보장함

  디스크에서는 헤드를 실린더마다 만들 수가 없어서 그게 안됨.

  > 한 파일(relation)을 한 실린더에다가 저장하면 움직이지 않고 빠르게 읽을 수 있음

### 버퍼 관리와 운영 체제

- 디스크 입출력은 컴퓨터 시스템에서 가장 속도가 느린 작업임

  따라서 입출력 횟수를 줄이는 것이 DBMS의 성능을 향상시키는 데에 중요하다.

  > 매직 넘버 : 이론적으로는 알 수 없지만 실제 실험적으로 했을 때 가장 좋은 숫자 (엔지니어링 넘버)
  >
  > 몇 번 읽어오면 가장 좋은지 알아내기

- 가능하면 많은 블록을 혹은, 자주 참조되는 블록을 메모리 상에 유지해 놓으면 블록 전송 횟수를 줄일 수 있다.

- 버퍼는 디스크 블록을 저장하는 데 사용되는 주기억 장치 공간

- 버퍼 관리자는 운영체제의 구성요소이다. 주기억 장치 내에서 버퍼 공간을 할당하과 관리하는 일을 맡는다.

- 운영체제에서 버퍼 관리를 위해서 LRU 알고리즘을 사용하는데, 이는 데이터 베이스에 대해서는 항상 우수한 성능을 갖지는 않는다. 

  DBMS가 관리하는 메타 데이타는 스키마 정보가 된다. 스키마 정보는 자주 액세스하니까 이런건 버퍼에 올려 놓는 것이 좋다. 

  OS는 이런 어플리케이션의 특징점을 잘 모른다. 

### 디스크 상에서 file의 레코드 배치

- 릴레이션의 애트리뷰트는 고정 길이 또는 가변 길이의 필드로 표현 된다.

  > 고정 길이의 경우에는 overwrite도 좀 편한 편이다. 
  >
  > 가변길이의 경우에는 내용물이 변경되었을 때 핸들링하는 알고리즘이 복잡해질 수 있다. 

- 연관된 필드들이 모여서 고정 길이 또는 가변 길이의 레코드가 된다.

- 한 **릴레이션**을 구성하는 **레코드들의 모임**이, **file**이라고 부르는 **블록들의 모임**에 저장된다. 

- 파일, 블록, 레코드의 구조도

  보통 가장 첫번째 블록에 제어 정보(control block)을 저장한다. 헤더라고도 부름.

  ![image](https://user-images.githubusercontent.com/41130448/120881679-d37d2280-c60d-11eb-88c0-dc19a91b183c.png)

- 위와 같은 블록이 실제 물리적으로 연속되어 있지는 않다. 

  튜플은 다이나믹한 구조이므로 계속 변화하기 때문에 연속성을 유지시켜 줄 수 가 없음

- 인접한 블록들을 읽는 경우에는 seek time과 rotation delay가 걸리지 않으므로 입출력 속도가 빠름. 따라서 블록들이 인접하도록 한 file의 블록들을 재조직할 수 있다. 

  이게 디스크 조각모음인듯??

- BLOB(Binary Large Object)

  - 이미지(GIF, JPG), 동영상(MPEG, AVI) 등의 대규모 크기의 데이터를 저장하는 데 사용
  - BLOB의 최대 크기는 MS SQL에서 2GB 가능

- 채우기 인수 (fill factor)

  - 각 블록에 레코드를 채우는 공간의 비율,  한 블럭을 레코드로 몇 %를 채울 것인가.

  - 나중에 레코드가 삽입될 때 기존의 레코드를 이동하는 가능성을 줄이기 위해서 사용한다.

    무조건 꽉꽉 채워서 저장한다고 좋은 것은 아님

  - 이 비율은 application 성격에 따라서 달라짐. 엔지니어링 value임. 현장 지식이 반영되어야 한다.

- 고정 길이 레코드

  i번째 레코드를 접근하기 쉽다.

  레코드 삭제 시 채워넣는 방법들

  1. 여러 개의 레코드를 쭉 올린다.
  2. 한 개의 레코드를 빼서 채워 넣는다. (가변 길이 레코드는 이런 작업이 불가능함)

- 파일 내의 클러스터링 (intra-file clustering)

  한 file 내에서 함께 검색될 가능성이 높은 레코드들을 디스크 상에서 물리적으로 가까운 곳에 모아 두는 것 (연속적으로 저장)

  데이터 마이닝에서 많이 사용함

- 파일 간의 클러스터링 (inter-file clustering)

  논리적으로 연관되어 함께 검색될 가능성이 높은 두 개 이상의 file에 속한 레코드들을 디스크 상에서 물리적으로 가까운 곳에 저장하는 것

  서로 다른 레코드들을 클러스터링 할 수 있음

### file structure

1. heap file

   - 레코드가 삽입되는 순서대로 저장함. 가장 단순한 형태

   - 새로 들어오면 맨 끝에 넣고(append), 검색하기 위해서는 모든 레코드를 순차적으로 접근해야 함. 삭제하는 경우 검색 후 삭제 처리하고, 해당 공간을 재사용하지 않음(다 이동시키지 않기 위해서)

   - 고속으로 데이터를 입력받는 경우 좋다. 

   - 성능을 좋게 유지하려면 주기적으로 파일을 재조직 해야 한다. 삭제 작업이 많이 이루어진 경우 빈 공간이 많아지기 때문이다.

   - 성능에 대해서

     1. 모든 레코드를 참조하고, 레코드 접근 순서는 중요하지 않는 질의의 경우 쓰기 좋다.

     2. 특정 레코드를 검색하는 경우에는 비효율적이다.

        삽입만 빠르고 나머지는 다 속도가 구림

        그래서 특수한 경우가 아니면 잘 쓰지 않는다.

2. sequential file

   - 하나 이상의 필드의 값(search key)을 기준으로 정렬해놓음
   - 삽입 연산은 레코드의 순서를 고려해야 하므로 시간이 많이 걸림
   - 삭제 시에도 heap file처럼 빈 공간으로 남김
   - 키를 기반으로 하므로 탐색시에만 빠르고 나머지 연산은 다 구리다.
   - DB 응용 시 거의 쓰지 않음

3. indexed sequential file - 단일 단계 인덱스

   - 인덱스를 통해서 임의의 레코드를 접근할 수 있음

   - 각 엔트리는 <search key, record pointer>로 구성도미

   - 엔트리들은 탐색 키 값의 오름차순으로 정렬된다.

     ![image](https://user-images.githubusercontent.com/41130448/120883246-07a91100-c617-11eb-8eac-4874a3bb2ae0.png)

   - 인덱스는 데이터 file 과는 별도의 file로 저장됨

   - 인덱스의 크기는 데이터 파일보다 훨씬 작음

   - 하나의 파일에 여러 개의 인덱스를 정의할 수 있음

     ![image](https://user-images.githubusercontent.com/41130448/120883284-4dfe7000-c617-11eb-989b-9c9b0de4e0e9.png)

   - 인덱스가 정의된 필드를 탐색 키라고 부른다.

     탐색 키의 값들은 후보 키처럼 각 튜플마다 고유하지는 않음

   - 탐색 키는 어떤 애트리뷰트도 다 쓸 수 있음

     하지만 카디널리티를 고려해서 효율적인 것을 선택해야 함. 안그러면 인덱싱하는 의미가 없다.

   - 탐색 키 값을 기준으로 오름차순 정렬되어 있으므로 이진 탐색 가능

   - 기본 인덱스 (primary index)

     - 탐색 키가 데이터 파일의 PK인 경우 기본 인덱스라고 한다.

     - 기본 인덱스는 PK 값에 따라서 정렬된 데이터 파일에 대해서 정의된다.

     - 기본 인덱스는 보통 희소(sparse) 인덱스로 유지가능하다. 

       희소 인덱스는 특정 범위로 분절해서 대표값만 추려서 만드는 것

       희소 인덱스로 만드려면 무조건 데이터 파일이 정렬이 되어 있어야 한다. 

     - 각 릴레이션마다 최대 한개의 기본 인덱스를 가질 수 있다.

   ![image](https://user-images.githubusercontent.com/41130448/120883463-4a1f1d80-c618-11eb-80d2-557e4ae43d29.png)

   - 클러스터링 인덱스 (clusteting index) 7-48:51

     - 탐색 키 값에 따라 정렬된 데이터 파일에 대해 정의된다.

     - 각각의 상이한 키 값마다 하나의 인덱스 엔트리가 인덱스에 포함된다.

     - 범위에 대한 질의(Range query)에 유용하다.

       범위의 시작 값에 해당하는 인덱스 엔트리를 먼저 찾고, 범위에 속하는 인덱스 엔트리들을 따라가면서 레코드를 검색할 때 디스크에서 읽어오는 블록 수가 최소화된다.

     - 어떤 인덱스 엔트리에서 참조되는 데이터 블록을 읽어 오면 그 데이터 블록에 들어 있는 대부분의 레코드들은 범위를 만족한다.

   - 보조 인덱스 (secondary index)

     - 한 file은 한 가지 필드의 조합에만 대해서 정렬할 수 있음

     - 보조 인덱스는 탐색 키 값에 따라 정렬되지 않은 데이터 파일에 대해 정의된다.

     - 보조 인덱스는 보통 밀집 인덱스이다. 따라서 같은 수의 레코드들을 접근할 때 보조 인덱스를 통하면, 기본 인덱스보다 디스크 접근 횟수가 증가할 수 있다. 

       entry가 더 많아짐.

   - 희소 인덱스와 밀집 인덱스 비교

     - 희소 인덱스는 각 데이터 블록마다 한 개의 엔트리를 갖는다.

       밀집 인덱스는 각 레코드마다 한 개의 엔트리를 갖는다.

     - 레코드의 길이가 블록 크기보다 훨씬 작은 일반적인 경우에는, 희소 인덱스의 엔트리 수가 밀집 인덱스의 엔트리 수보다 훨씬 적다. 

     - 희소 인덱스는 일반적으로 밀집 인덱스에 비해 인덱스 단계 수가 1 정도 적다. 따라서 인덱스 탐색 시 디스크 접근 수가 1만큼 적을 수 있다. 

     - 희소 인덱스는 밀집 인덱스에 비해 모든 갱신과 대부분의 질의에 대해 더 효율적이고 성능이 좋다.

       하지만 질의에서 인덱스가 정의된 애트리뷰트만 검색하는 경우에는 (COUNT 질의 등), 데이터 파일을 접근할 필요 없이 인덱스만 접근해서 질의를 수행할 수 있기 때문에 밀집 인덱스가 더 유리하다.

     - 한 파일은 한 개의 희소 인덱스와 여러 개의 밀집 인덱스를 가질 수 있다. 

   - 클러스터링 인덱스와 보조 인덱스의 비교

     - 클러스터링 인덱스는 희소 인덱스일 경우가 많고, 범위를 질의할 때 좋다.
     - 보조 인덱스는 밀집 인덱스이므로, 일부 질의에 대해서는 파일을 접근할 필요 없이 처리할 수 있다.

   - 다단계 인덱스

     - 인덱스 자체가 클 경우에는 인덱스를 탐색하는 시간도 오래 걸릴 수 있다.

     - 인덱스 엔트리를 탐색하는 시간을 줄이기 위해서 단일 단계 인덱스를 디스크 상의 하나의 순서 파일로 간주하고, 단일 단계 인덱스에 대해서 다시 인덱스를 정의할 수 있다.

     - 다단계 인덱스는 가장 상위 단계의 모든 인덱스 엔트리들이 한 블록에 들어갈 수 있을 때까지 이런 과정을 반복한다.

     - 가장 상위 단계 인덱스를 마스터 인덱스라고 부른다. 단계의 개수는 제한이 딱히 없음

       마스터 인덱스는 한 블록으로 이루어지므로 주기억장치에 상주할 수 있다. 버퍼를 금방 비우지 말고 올려놓음

     - 대부분의 다단계 인덱스는 B+ tree를 사용한다. 

       > de facto 느낌. 세계적으로 걍 이거 쓰자 함
       >
       > B+ - tree는 꼭 알아야 함니더

     - B+ tree

       → Balanced (root에서 leaf까지 깊이가 균형 잡힌 것을 보장)

       → 모든 node들이 갖는 child의 개수를 일정하게 유지해준다.

     ![image](https://user-images.githubusercontent.com/41130448/121208628-2b898280-c8b5-11eb-8386-0f856aebf64a.png)

     - 이거슨 B+ tree 아니고 그냥 다단계 인덱스. 목차의 목차의 목차 느낌

       값에 대해 sorting이 반드시 되어 있어야 한다잉

       특정 키 값의 검색이 빠르게 가능

     - 레코드 삽입/삭제 시 인덱스를 전체 다 재점검해야 할 수도 있음

       **index maintenance overhead**라고 한다. 모든 것은 다 trade off임

       이걸 항상 감안해야 함. 모든 attribute에 대해서 다 인덱스를 만들 수 없음

       인덱스를 만드는 것이 좋은지 아닌지 항상 고민해야 한다

     - 1. tree는 root에서 leaf 노드까지의 길이가 다를 수 있음.

          skewed tree의 경우 편향된 형태의 트리가 생성될 수 있다.

       2. child의 개수도 다를 수 있다.

          그러면 전체적인 효율성이 떨어짐

   - SQL의 인덱스 정의문

     - `CREATE TABLE`문에서 `PRIMARY KEY`절로 명시하면 해당 애트리뷰트에 대해서 DBMS가 자동으로 기본 인덱스 생성

     - `UNIQUE`로 명시한 애트리뷰트에 대해서는 DBMS가 자동으로 보조 인덱스 생성

     - SQL2는 인덱스 정의 및 제거에 관한 표준 SQL문을 제공하지 않는다.

     - 다른 애트리뷰트에 추가적으로 인덱스를 정의하기 위해서는 DBMS마다 각자 구문에 맞춰서 `CREATE INDEX`문을 사용한다. 

       ```sql
       CREATE INDEX EmpIndex ON EMPLOYEE (DNO, SALARY);
       # 두개 이상의 애트리뷰트를 묶어서 인덱스를 만들 수 있다.
       ```

       인덱스의 활용 예

       ```SQL
       # 아래와 같은 쿼리에 할용 가능 (실제 수행해보면 쥰내 빨라진다.)
       SELECT *
       FROM EMPLOYEE
       WHERE DNO = 3 AND SALARY = 4000000;
       # RANGE QUERY에도 활용하기 좋음
       SELECT *
       FROM EMPLOYEE
       WHERE DNO >= 2 AND DNO <= 3 
       	AND SALARY >= 3000000 AND SALARY <= 4000000;
       # 여기에도 사용 가능
       SELECT *
       FROM EMPLOYEE
       WHERE DNO = 2; # 혹은 DNO에 대한 범위 질의
       ```

       이런 질의에는 위의 인덱스를 활용할 수 없다.

       ```sql
       SELECT *
       FROM EMPLOYEE
       WHERE SALARY >= 3000000 AND SALARY <= 4000000; # 혹은 SALARY에 대한 동등 조건
       ```

       `DNO`에 대한 조건이 없음. 이 경우에는 사용 불가

     - 인덱스의 사용 여부는 DBMS가 결정한다. 써서 빠르겠다 싶으면 쓰는 것. 

       쿼리 처리 후 인덱스 사용 여부는 확인할 수 있음

   - 인덱스의 장점과 단점

     - 검색 속도를 향상

       저장하기 위한 공간이 추가로 필요함, 삽입/삭제/수정의 연산 속도 저하

     - 소수의 레코드 수정/삭제하는 연산의 속도는 향상

     - 릴레이션이 매우 크고, 질의에서 튜플들 중에 일부(예를 들어 2~4%)를 검색하는 경우, `WHERE`절이 잘 표현되는 경우 특히 성능에 도움이 된다. 

   - 인덱스 선정 지침과 데이터베이스 튜닝

     - 다음과 같은 것들에 대해서 바람직한 성능을 고려해서 인덱스를 선정한다.

       1. 가장 중요한 질의와 이들의 수행 빈도
       2. 가장 중요한 갱신과 이들의 수행 빈도

     - Workload 내의 각 질의에 대해서, 해당 질의가

       1. 어떤 릴레이션을 접근하는지
       2. 어떤 애트리뷰트들을 검색하는지
       3. `WHERE`절의 선택/조인 조건에 어떤 애트리뷰트가 포함되는지
       4. 이 조건들의 선별력은 얼마인지

       등을 고려한다.

     - Workload 내의 각 갱신에 대해서, 해당 갱신이

       1. 어떤 릴레이션들을 접근하는지
       2. `WHERE`절의 선택/조인 조건에 대해 어떤 애트리뷰트가 포함되는지
       3. 이 조건들의 선별력은 얼마인지
       4. 갱신의 유형(`INSERT/DELETE/UPDATE`)
       5. 갱신의 영향을 받는 애트리뷰트

       등을 고려한다.

     - Workload란 어떠한 작업을 얼마나 하느냐를 통틀어서 본 것

     - 선별력이란 Selectivity 이 조건을 만족하는 튜플들이 몇%인지를 의미한다.

       그 애트리뷰트의 cardinality와 관련이 있다. 

     > 예) 우리나라 이름에서 성의 selectivity는 굉장히 낮다. 

     - 그 외에 고려할 것
       1. 어떤 릴레이션에 인덱스를 생성할지
       2. 어떤 애트리뷰트를 탐색 키로 선정할지
       3. 몇 개의 인덱스를 생성할지
       4. 각 인덱스에 대해 클러스터링/밀집/희소 인덱스 중 어느 유형을 선택할지
     - 물리적 데이터베이스 설계는 끊임없이 이루어지는 작업이다.

   - 인덱스 선정에 참고할 지침

     1. 기본 키는 클러스터링 인덱스를 정의할 훌륭한 후보이다.

     2. 외래 키도 인덱스를 정의할 훌륭한 후보이다.

     3. 한 애트리뷰트에 들어 있는 값들이 거의 서로 다르고, 그 애트리뷰트가 동등 조건에 사용된다면 비 클러스터링 인덱스를 생성하는 것이 좋다.

     4. 튜플이 많이 들어 있는 릴레이션 내에서 행해지는 검색 질의의 대부분이 2%~4% 미만의 튜플이라면 인덱스를 생성

     5. 자주 갱신되는 *애트리뷰트*에는 인덱스를 정의하지 않는 것이 좋다.

     6. 갱신이 빈번하게 이루어지는 *릴레이션*에는 인덱스를 많이 만드는 것을 피한다.

        (static, dynamic relation에 따라 구분)

     7. 후보 키는 기본 키가 갖는 모든 특성을 함께 갖기 때문에 인덱스를 생성할 훕이다.

     8. 인덱스는 파일의 레코드들을 충분히 분할할 수 있어야 한다.

     9. 정수형 애트리뷰트에 인덱스를 생성하는 것이 좋다. (실수형에는 부적절)

     10. `VARCHAR` 애트리뷰트에는 인덱스를 만들지 말자 (값이 크면 공간을 너무 많이 차지함)

     11. 작은 파일에는 인덱스를 만들 필요가 없다.

     12. 대량의 데이터(bulk data)를 삽입할 때는 모든 인덱스를 제거하고, 데이터 삽입이 끝난 후에 인덱스를 다시 생성하는 것이 좋다. (좋은 가이드라인인듯)

     13. `ORDER BY`절, `GROUP BY`절에 자주 사용되는 애트리뷰트는 인덱스를 정의할 후보이다. (이 두 연산은 오버헤드가 제일 큰 연산 중에 하나임)

   - 인덱스가 사용되지 않는 경우 

     - 시스템 카탈로그가 오래 전의 데이터베이스 상태를 나타낼 때

       > 카탈로그 : db 시스템의 상황을 기록하는 메타 데이터 
       >
       > 대부분의 시스템은 메타 데이터 업데이트를 real-time으로 하지 않는다. 
       >
       > delay를 두고 주기적으로 실행함 
       >
       > 따라서 인덱스를 만들었는데도 그 메타 데이터에 바로 반영이 안되었을 수 있음
       >
       > 그럼 사용 못하는거임. DBMS가 인덱스 만들어졌는지 모르기 때문에 못쓴다.

     - DBMS의 질의 최적화 모듈이, 릴레이션의 크기가 작아서 인덱스가 필요 없다고 판단하는 경우

     - 인덱스가 정의된 애트리뷰트에 산술 연산자가 사용되는 경우 (오!!!헐)

       ```sql
       SELECT *
       FROM EMPLOYEE
       WHERE SALARY * 12 > 4000000;
       ```

     - DBMS가 제공하는 내장 함수가 집단 함수 대신 사용되는 경우

       ```sql
       SELECT *
       FROM EMPLOYEE
       WHERE SUBSTRING(EMPNAME, 1, 1) = '김';
       ```

     - 널 값에 대해서는 인덱스 사용하지 않음

       ```sql
       SELECT *
       FROM EMPLOYEE
       WHERE MANAGER IS NULL;
       ```

   - 질의 튜닝을 위한 추가 지침

     1. `DISTINCT`절의 사용을 최소화하라

        > 시간이 많이 걸리므로 꼭 필요한 거 아니면 쓰지 마셈

     2. `GROUP BY`절과 `HAVING`절의 사용을 최소화하라

     3. 임시 릴레이션의 사용을 피하라

        > 복잡한 쿼리 하나 대신 임시 테이블을 만들어서 쓸 수 있지만, 가능하면 하지 말어라

     4. `SELECT *` 대신 `SELECT` 절에 애트리뷰트 이름을 구체적으로 명시하라 

4. hash file

<br>

### B+ TREE

- 최대 child의 개수는 key 값의 크기에 따라서 달라진다. 노드 자체가 디스크의 block 하나를 뜻함

  ![image](https://user-images.githubusercontent.com/41130448/121215528-10217600-c8bb-11eb-875c-9caf8aea7acf.png)

  얘는 최대 child 수가 4개인 B+ tree

- 통상 50% 이상의 fill factor를 가지고 있음 

  노드 하나 안에서 50% 이상은 채워야 함

  수정/삭제 시 매번 이 채우는 정도를 유지시킴

- `INSERTION` 수행하는 경우

  1. 사이에 쏙 넣음

     ![image](https://user-images.githubusercontent.com/41130448/121215755-3fd07e00-c8bb-11eb-9f4c-a0994a9ffa74.png)

  2. leaf가 꽉 찬 경우 → split (propagation)

     ![image](https://user-images.githubusercontent.com/41130448/121215882-5bd41f80-c8bb-11eb-9907-6343d78fb17f.png)

     leaf를 둘로 쪼갠 후 새로 넣는다.

     여기서는 50에 있는 애를 쪼개서 70을 오른쪽에 넣는다.

     ![image](https://user-images.githubusercontent.com/41130448/121216081-8920cd80-c8bb-11eb-819f-3d4bee62f781.png)

     여기서 95를 또 넣는 경우에 또 꽉차있음

     ![image](https://user-images.githubusercontent.com/41130448/121216233-ac4b7d00-c8bb-11eb-8431-6ed8b9b5d25b.png)

     75짜리를 또 반띵해서 95를 오른쪽에 넣는다. 근데 인덱스 노드가 꽉참

     인덱스를 반띵한다.

     ![image](https://user-images.githubusercontent.com/41130448/121216536-ef0d5500-c8bb-11eb-9657-94add416ca9d.png)

     ![image](https://user-images.githubusercontent.com/41130448/121216570-faf91700-c8bb-11eb-8959-cc64e077a70d.png)

     암튼 leaf 노드의 깊이는 다 똑같아진다 이말이야 *밸런-쓰*

<br>

## 릴레이션 정규화

- 정규화는 정규형(Normal form)을 만드는 것

- 함수 종속성을 알고 분해해주어야 relation 설계가 끝나는 것임

- 때로는 융통성있게 역정규화도 할 줄 알아야 한다.

  어떤 때 필요한지 살펴보자.

### 정규화 개요

- 데이터베이스 설계를 부주의하게 설게하면 데이터 중복이 커져서 여러 가지 갱신 이상을 발생시킨다. (update anomaly)

- 좋은 데이터베이스 설계를 위해서 생각할 것

  어떤 릴레이션들을 생성할 것인가?

  각 릴레이션에 어떤 애트리뷰트를 둘 것 인가?

- 좋은 RDB 스키마를 설계하는 목적

  - 정보의 중복과 갱신 이상 생기지 않도록 함
  - 정보의 손실을 막는다
  - 실세게를 훌륭하게 나타낸다.
  - 애트리뷰트들 간의 관계를 잘 표현
  - 무결성 제약 조건의 시행을 간단하게 한다.
  - 효율성도 높이도록

- 우선순위

  갱신 이상 → 효율성

- 정규화는 릴레이션 스키마를 함수적 종속성과 기본 키를 기반으로 분석한다. 이를 원래의 릴레이션으로 분해한다.

  → 중복, 갱신이상 3가지(수정, 삽입, 삭제)를 최소화

  > 정보의 중복은 저장 공간을 낭비한다. 
  >
  > 변경 시 일부 중복된 튜플에 적용하는 것을 빼먹으면 불일치 문제가 발생한다. 중복을 방지하기 위해 딱 한 곳에서만 변경하면 되도록 하는 게 좋음

- 갱신 이상

  1. 수정 이상(modification anomaly)

     반복된 데이터 중에 일부만 수정하면, 데이터의 불일치가 발생(inconsistency)

  2. 삽입 이상(insertion anomaly)

     불필요한 정보를 함께 저장하지 않고는 어떤 정보를 저장하는 것이 불가능

     어떤 정보를 넣기 위해서는 부수적으로 다른 정보도 함께 넣어야만 삽입이 가능한 것

  3. 삭제 이상(deletion anomaly)

     유용한 정보를 함께 삭제하지 않고는 어떤 정보를 삭제하는 것이 불가능

     특정 정보를 삭제할 때 다른 정보까지 의도하지 않았지만 딸려서 삭제되는 것

- 릴레이션의 분해 (Decompose)

  - 하나의 릴레이션을 두 개 이상의 릴레이션으로 나누는 것이다.
  - 갱신 이상을 해결하는 방법이다
  - 릴레이션을 분해할 때에는, 분해된 릴레이션으로부터 원래의 릴레이션을 다시 구할 수 있음을 보장해야 한다.
  - 분해를 잘못하면 분해된 두 릴레이션으로부터 얻을 수 있는 정보가 원래의 릴레이션이 나타내던 정보보다 적거나 많다.
  - 릴레이션에 존재하는 함수적 종속성에 관한 지식을 기반으로 분해한다. 

- 정규형의 종류

  일반적으로 산업게에서 설계할 때에는 BCNF까지 고려함, 굳이 이 이상으로는 알 필요는 읎다.

  1. 제1정규형
  2. 제2정규형
  3. 제3정규형
  4. BCNF(Boyce-Codd normal form)
  5. 제4정규형
  6. 제5정규형

- RDB 설계 시 비공식적인 지침

  1. 이해하기 쉽고 명확한 스키마를 만들자.

     여러 엔티티 타입이나 관계 타입에 속한 애트리뷰트를 하나의 릴레이션에 포함 ㄴㄴ

  2. 널값을 피하자

  3. 가짜 튜플이 생기지 않도록 하자

     가짜 튜플은 실제 발생할 수 없는 튜플을 의미함

  4. 스키마를 정제하자

     다듬고 최적화하자.

<br>

### 함수적 종속성

- 함수적 종속성은 정규화 이론의 핵심이다.

- 릴레이션의 애트리뷰트들의 의미에서 결정된다.

- 릴레이션 스키마 자체에 대한 것이며, 특정 인스턴스에 대한 것이 아님

  릴레이션의 가능한 모든 인스턴스들이 만족해야 한다.

- 실세계에 대한 지식과 응용의 의미를 기반으로 어떤 함수적 종속성들이 존재하는지 파악해야 한다.

- 함수적 종속성은 제2정규형부터 BCNF까지 적용된다. 

- 결정자 (Determinant)

  - 어떤 애트리뷰트의 값은 다른 애트리뷰트의 값을 고유하게 결정, 그렇게 고유하게 결정시키는 하나 이상의 애트리뷰트가 결정자이다.

    > 사원 번호 → 사원 이름 (고유히 결정 O)
    >
    > 주소 → 사원 이름 (고유히 결정 X)
    >
    > 부서 번호 → 부서 이름 (고유히 결정 O)

  - "A가 B를 결정한다", "A는 B의 결정자이다", "B가 A에 함수적으로 종속한다"를 다음과 같이 표현한다.

    A → B

    > A쪽에 집합이 올 수도 있음

    주어진 릴레이션 R내에서 각 A 값에 대해 반드시 한 개의 B가 대응되어야 한다.

    > 걍 함수같네 함수도 정의역 내의 특정 값에 대해서 반드시 하나의 값만 나와야지 함수라고 하는디 

- 완전 함수적 종속성 (FFD: Full Functional Dependency)

  - 릴레이션 R, 복합(set) 애트리뷰트 A, 그냥 애트리뷰트 B

    주어진 R에서 B가 A에 함수적으로 종속하면서, A의 어떠한 진부분 집합(부분 집합 아무거나)에도 함수적으로 종속하지 않으면

    → B가 A에 완전하게 함수적으로 종속한다

    ![image](https://user-images.githubusercontent.com/41130448/121147393-cbc2b580-c87b-11eb-966b-004fc50fdb1a.png)

    fd3는 완전 함수적 종속성을 가짐

    fd1, fd2는 부분 함수적 종속성을 가짐 

    > 직책은 사원번호 + 부서번호로 인해 결정됨
    >
    > 이 회사는 한 사원이 여러 부서에 속할 수 있는 부서라서 그럼 

    부분 함수적 종속성을 없애기 위해서 분해해야 깔끔

- 이행적 함수적 종속성 (transitive FD)

  - 릴레이션 R, 애트리뷰트 A, B, C에서

    "C가 이행적으로 A에 종속한다"는

    A→B ∧ B→C 가 성립하는 것이다. 

  - A가 릴레이션의 PK라면 키의 정의에 따라서 A→B, A→C가 성립한다.

    만약에 C가 A 외에 B에도 함수적으로 종속한다면 C는 A에 직접 합수적으로 종속하면서 B를 거쳐서 A에 이행적으로 종속

  ![image](https://user-images.githubusercontent.com/41130448/121148245-91a5e380-c87c-11eb-9782-53f817db666f.png)

<br>

### 릴레이션 분해

- 하나의 릴레이션을 두 개 이상의 릴레이션으로 나누는 것

- 장점 : 중복이 감소되고, 갱신 이상이 줄어든다.

  단점 : 잠재적인 문제를 야기할 수 있음

  > 조인이 필요 없는 질의였다가, 분해한 후에는 조인이 필요하도록 변화. 성능이 감소할 수도 있다.
  >
  > 분해된 릴레이션으로 기존의 릴레이션을 재구성하지 못할 수도 있다.

  > 공학은 현재 시점에서 어떤 것이 최선인지 trade off를 고려해서 적절히 선택하는 것.
  >
  > 비용과 서비스 품질을 잘 고려하자

- 무손실 분해 (lossless decomposition)

  - 여기서 말하는 손실이란 정보의 손실이다.

    분해된 릴레이션 조인 시 원래의 릴레이션에 있던 정보보다 적거나 많은 것을 모두 포함한다. 

  - 분해된 두 릴레이션을 조인하면 원래의 릴레이션에 있던 정보를 완전히 얻을 수 있게 분해하는 것.

  ![image](https://user-images.githubusercontent.com/41130448/121149245-75567680-c87d-11eb-840e-29c5a75de626.png)

  잘한 것

  ![image](https://user-images.githubusercontent.com/41130448/121149300-81423880-c87d-11eb-941f-76de58e5c470.png)

  무손실 분해지만 쓸데 없는 분해

  binary relation(attribute가 2개인 것)으로 모든 정보를 표현하면 중복을 제일 최소화 할 수 있다. 하지만 그만큼 조인 해야 하므로 항상 권장되는 것은 XXX

  ![image](https://user-images.githubusercontent.com/41130448/121149489-aa62c900-c87d-11eb-9142-3f6f6ad58643.png)

  과목과 학점이 합쳐져야지 의미 있는 정보임. 이걸 부시면 안됨. 합쳤을 때 말이 안되는 정보 (가짜  튜플)이 생성된다.

<br>

### 제 1 정규형

- 릴레이션 R의 모든 애트리뷰트가 원자값만을 갖는다는 것이다.
- 모든 애트리뷰트에 반복 그룹(repeating group)이 나타나지 않으면 제 1정규형을 만족함

![image](https://user-images.githubusercontent.com/41130448/121149790-eb5add80-c87d-11eb-836c-750a5e616cbf.png)

표현하기에는 좋지만 반복 그룹(집합값)이 존재함 (객체 관계 모델에서는 이걸 할 수 있다는듯?)

집합값이 들어갈 수 있으면 자연스럽게 설계할 수 있음. 하지만 디비에는 그렇게 표현 안됨.

nested relation으로 표현한다링

![image](https://user-images.githubusercontent.com/41130448/121149844-f9106300-c87d-11eb-875a-6661f002187a.png)

제1 정규형을 만족하지만 중복 정보가 많음  

- 제 1정규형만 만족 시 발생할 수 있는 문제

  예시) 릴레이션 내에 학생, 학과, 학과의 전화번호가 존재

  ![image](https://user-images.githubusercontent.com/41130448/121170794-a55b4500-c890-11eb-8869-74f8d15eb161.png)

  1. 수정 이상

     특정 카테고리에 속한 원소(특정 학과의 연결 전화번호)가 변경되었을 때 이 원소를 갖고 있는 모든 튜플(해당 학과에 속한 학생 튜플)을 모두 변경시켜야 한다.

  2. 삽입 이상

     특정 정보가 없으면 새로운 튜플을 넣을 수 없다.

     (새로운 학과를 신설할 수 없다, 소속되어 있는 학생이 없으므로)

  3. 삭제 이상

     특정 정보를 삭제 시 의도하지 않은 다른 정보까지 함께 삭제

     (어떤 학과에 소속된 마지막 학생 튜플을 삭제하면 이 학생이 소속된 학과 정보도 함께 삭제)

<br>

### 제 2 정규형

- 릴레이션 R이 제1정규형을 만족하면서, 어떤 후보 키에도 속하지 않는 모든 애트리뷰트들이 R의 **기본 키에 완전하게 함수적으로 종속**하는 것

- 기본 키가 두 개 이상의 애트리뷰트로 구성되었을 경우에만 제1정규형이 제2정규형을 만족하는가를 고려할 필요가 있다. 

  ![image](https://user-images.githubusercontent.com/41130448/121175547-236e1a80-c896-11eb-972e-b77bf20270f9.png)

- 제2 정규형에 존재하는 이상

  1. 수정 이상

     여러 학생이 소속된 학과의 전화번호가 변경되었을 때 그 학과에 속한 모든 학생들의 튜플에서 전화번호 수정해야 함

  2. 삽입 이상

     학과 신설 시 소속 학생이 없으면 정보 입력 불가. 학번이 PK이기 때문에 무결성 제약 조건에 따라서 널값을 입력할 수 없음

  3. 삭제 이상

     어떤 학과에서 마지막 학생의 튜플 삭제 시 그 학과의 전화번호도 함께 삭제

- 갱신 이상이 생기는 이유

  이행적 종속성이 존재하기 때문 

  학과 전화번호는 학과 이름에도 종속됨

<br>

### 제 3정규형

- 릴레이션 R이 제2정규형을 만족시키면서, 키가 아닌 모든 애트리뷰트가 R의 기본 키에 이행적으로 종속하지 않는 것

- 제 3정규형에 존재하는 갱신 이상

  ![image](https://user-images.githubusercontent.com/41130448/121203633-393d0900-c8b1-11eb-973e-83d8555d8da2.png)

  강사가 결정되면 과목이 결정됨

  1. 수정 이상

     여러 학생이 수강 중인 어떤 과목의 강사가 변경되었을 때 그 과목을 수강하는 모든 학생들의 튜플에서 강사를 다 수정해야 함. (data consistency)

  2. 삽입 이상

     어떤 과목을 신설할 때 아직 수강생이 없으면, (학번이 PK이므로) 어떤 강사가 그 과목을 가르친다는 정보 입력 불가능

  3. 삭제 이상

     어떤 과목의 수강생이 1명일 때, 이 학생의 튜플 삭제 시 그 과목의 강사에 대한 정보도 삭제됨

- 갱신 이상이 생기는 이유

  - 키가 아닌 애트리뷰트가 다른 애트리뷰트를 결정함

  > 모든 애트리뷰트에서 결정자는 꼭 기본키, 혹은 후보 키가 되어야 한다. 

<br>

### BCNF

- 릴레이션 R이 제 3정규형을 만족하고, 모든 결정자가 후보 키어야 한다.

- 제 3정규형을 만족하는 릴레이션은 대부분 BCNF를 만족한다.

- 하나의 후보 키만을 가진 릴레이션이 제3정규형을 만족하면 동시에 BCNF도 만족한다.

- 제 3정규형을 만족하는 릴레이션을 BCNF로 정규화하기 위해서는, 키가 아니면서 결정자 역할을 하는 애트리뷰트(갱신 이상을 발생시키는 녀석)와 그 결정자에 함수적으로 종속하는 애트리뷰트를 하나의 테이블에 넣는다.

  이 릴레이션(테이블)에서 결정자 역할을 하던 녀석은 곧 기본 키가 된다.

  기존 릴레이션에는 결정자를 남겨서 기본 키의 구성 요소가 되도록 한다. 동시에 이 결정자는 새로운 릴레이션에 대한 외래키 역할도 한다. 

  ![image](https://user-images.githubusercontent.com/41130448/121205130-5e7e4700-c8b2-11eb-91a1-2ed157405191.png)

- 하지만 릴레이션이 너무 많아지면 그것도 문제다.

![image](https://user-images.githubusercontent.com/41130448/121205259-78b82500-c8b2-11eb-9ac8-fbc5ccf51e5f.png)

<br>

### 역정규화

- 정규화 단계가 진행될수록 

  1. 중복과 갱신 이상도 감소된다.
  2. 무결성 제약 조건을 시행하기 위해 필요한 코드의 양도 감소된다.
  3. 하나의 릴레이션이 최소한 두 개의 릴레이션으로 분해된다.

- 정규화가 DB 설계의 중요한 요소이지만, 성능상의 관점에서만 보았을 때 높은 정규형을 만족한다고 항상 그 스키마가 최적인 것은 아니다.

- 릴레이션을 분해하면서 같은 정보를 얻기 위해 조인 연산의 필요성이 증가한다.

  요구 사항에 따라서 일부분을 역정규화 함으로써 데이터 중복 및 갱신 이상을 대가로 성능을 만족시킬 수 있다.

- 많은 DB 응용에서 검색 질의의 비율이 갱신 질의의 비율보다 훨씬 높다.

  역정규화는 자주 수행되는 검색 질의의 수행 속도를 높이기 위해서 이미 분해된 두 개 이상의 릴레이션들을 합쳐서 하나의 릴레이션으로 만드는 작업이다.

- 즉, 보다 낮은 정규형으로 돌아가는 것

> 자바는 바이트 코드이므로 리버스 엔지니어링이 쉽다
> 역정규화는 DB에 대해서 적용하는 리버스 엔지니어링 같은 것

<br>

## 뷰와 시스템 카탈로그

### 뷰(View)

- 다른 릴레이션으로부터 유도된 릴레이션 (derived relation)

- ANSI/SPARC 3단계 아키텍처의 외부 뷰와 다름

  외부 뷰는 특정 사용자가 보는 데이터베이스의 구조

- RDB에서의 뷰는 하나의 가상 릴레이션(virtual relation)을 의미한다.

  기존의 기본 릴레이션(base relation, 실제 릴레이션)에 대한 `SELECT`문의 형태로 정의된다.

- RDB 시스템에서 DB의 보안 메커니즘으로서 복잡한 질의를 간단하게 표현하는 수단이다.

- 데이터 독립성을 높이기 위해서 사용된다.

  다른 부서가 뭐하는지 모르게 함. 각각의 사용자마다 볼 수 있는 정보만 가지도록 함. 정보의 유무 자체도 보안일 수 있음.

- 사용자는 여러 개의 릴레이션과 뷰를 사용할 수 있다.

- 뷰는 릴레이션으로부터 데이터를 검색하거나 갱신할 수 있는 동적인 창(dynamic window)의 역할을 한다.

  뷰의 정의는 고대로 있지만 뷰에 의해서 검색되는 튜플들의 내용은 계속 변하기 때문에 dynamic하다고 한다.

  뷰를 이용해서 연산 요청을 할 때 그 때 실행됨

![image](https://user-images.githubusercontent.com/41130448/121292287-accc2e00-c924-11eb-966b-2d93568a4edc.png)

- 릴레이션 하나로도 뷰를 만들 수 있고, 여러 개를 조인해서 만들 수도 있다. 

- 뷰를 정의하기

  ```sql
  CREATE VIEW {VIEW NAME} [(ATTRIBUTES)]
  AS {SELECT 문}
  [WITH CHECK OPTION]; # 연산의 제약 조건
  ```

  뷰의 이름 다음에 애트리뷰트를 생략하면 `SELECT`절에 열거된 애트리뷰트들의 이름과 동일하게 뷰에 포함된다.

  이런 경우에는 뷰를 정의할 때 모든 애트리뷰트들의 이름을 지정해야 한다.

  1. 뷰를 정의하는 `SELECT`절에 산술식이나 집단 함수에 사용된 애트리뷰트가 있는 경우
  2. 뷰의 정의에 조인이 포함되어 있고, 두 개 이상의 다른 릴레이션에서 가져온 애트리뷰트 이름이 겹치는 경우

  (예시)

  ```sql
  CREATE VIEW EMP_DNO3 (ENO, ENAME, TITLE)
  AS 	SELECT	EMPNO, EMPNAME, TITLE
  	FROM	EMPLOYEE
  	WHERE 	DNO = 3;
  ```

  이렇게 정의하고 나면 하나의 릴레이션이라고 생각해도 좋다. (가상의 릴레이션)

  ```sql
  CREATE VIEW EMP_PLANNING
  AS	SELECT	E.EMPNAME, E.TITLE, E.SALARY
  	FROM	EMPLOYEE E, DEPARTMENT D
  	WHERE 	E.DNO=D.DEPTNO
  			AND D.DEPTNAME = '기획';
  ```

- 복잡한 명령인데 자주 쓴다 하는 경우

  뷰로 정의하고 불러 쓰면 편하다. 마치 매크로 함수처럼

- 뷰를 사용하여 데이터를 접근할 때 관계 DBMS에서 거치는 과정

  1. 시스템 카탈로그로부터 뷰의 정의, 즉 `SELECT`문을 검색
  2. 기본 릴레이션에 대한 뷰의 접근 권한을 검사한다.
  3. 뷰에 대한 질의를 기본 릴레이션에 대한 동등한 질의로 변환한다.

  ```sql
  # 입력
  SELECT *
  FROM EMP_DNO3
  WHERE TITLE='사원';
  # 뷰를 이용해서 처리 (뷰에 대한 implementation으로 쿼리를 transformation해서 처리)
  SELECT EMPNO, EMPNAME, TITLE
  FROM EMPLOYEE
  WHERE TITLE='사원' AND DNO=3;
  ```

- 뷰의 장점

  - 복잡한 질의를 간단하게 표현하도록 도와준다.

    ```sql
    # 뷰를 사용하지 않는 경우
    SELECT E.EMPNAME, E.SALARY
    FROM EMPLOYEE E, DEPARTMENT D
    WHERE D.DEPTNAME = '기획'
    	AND D.DEPTNO = E.DNO
    	AND E.TITLE = '부장';
    # 뷰를 사용하는 경우
    SELECT EMPNAME, SALARY
    FROM EMP_PLANNING
    WHERE TITLE = '부장';
    ```

  - 데이터의 무결성을 보장하는데 활용 가능

    기본적으로 뷰를 통해 튜플을 추가하거나 수정 시(뷰에 INSERT, UPDATE 하는 경우), 튜플이 뷰를 정의하는 `SELECT`문의 `WHERE`절 기준에 맞지 않으면 뷰의 내용에서 사라진다.

    예시)

    ```sql
    UPDATE EMP_DNO3
    SET DNO = 2
    WHERE ENO = 3427;
    # 바꾸는 순간 이 뷰에서 이 EMPLOYEE는 사라진다. -> 이상함, 뷰의 DEFINITION을 위반 
    # DNO = 2인 애를 INSERT해도 이상하다.
    ```

    그 뷰의 DEFINITION 조건을 위반하는 UPDATE 연산은 거절하고 허용하지 않도록 걸 수 있다.

    ```sql
    CREATE VIEW EMP_DNO3 (ENO, ENAME, TITLE)
    AS SELECT EMPNO, EMPNAME, TITLE
    	FROM EMPLOYEE
    	WHERE DNO = 3
    	WITH CHECK OPTION;
    ```

  - 데이터 독립성을 제공함

    데이터베이스의 구조가 바뀌어도 응용 프로그램에서 쓰는 기존의 질의를 다시 작성할 필요성을 줄일 수 있다.

  - 데이터 보안 기능을 제공함

    뷰의 원본이 되는 기본 릴레이션에 직접 접근하는 권한을 부여하지 않고도, 데이터에 접근할 수 있도록 해줌. 보안 메커니즘으로 사용 가능

    일반적으로 일부 애트리뷰트나 일부 튜플을 검색하는 `SELECT`문으로 정의되기 때문에 뷰를 통해서는 기본 릴레이션의 일부만 검색이 가능하다.

    > 접근 제어의 방법
    >
    > 1. static
    >
    >    특정 value의 접근 권한을 딱 지정(?)
    >
    >    예를 들면 학생의 핸드폰 번호를 볼 수 없음 
    >
    > 2. dynamic
    >
    >    조건을 만족하는 지 알기 위해서 쿼리를 실행해봐야 함
    >
    >    특정 데이터에 대한 접근 권한이 시점에 따라 달라짐
    >
    >    content-based control. 내용에 따라서 접근 제어 권한이 변화함

  - 동일한 데이터에 대한 여러 가지 뷰를 제공한다.

    사용자의 그룹마다 각자 가지고 있는 특정한 기준에 따라서 다른 데이터를 접근하도록 제공.

    데이터는 하나지만 사용자마다 필요로 하는 데이터를 다르게 제공. 해당 사용자는 전체 데이터가 존재하는지 알 수조차 없음.

- 뷰의 갱신

  - 뷰에 대한 갱신도 기본 릴레이션에 대한 갱신으로 변환된다.

  - 가급적이면 뷰와 릴레이션을 구분하지 않도록 하는 것이 좋음

    사용자는 뷰에 대한 권한만 가지고 있는데, 그 뷰의 결과로 나오는 릴레이션이 실제 있는 것처럼 취급하게 되어야 함.

  - 뷰(가상 릴레이션)은 실제 존재하지 않는데, 여기에 삽입을 하면 DBMS는 어떻게 받아들이능가?

  ```sql
  # 뷰에 삽입
  INSERT INTO EMP_DNO3
  VALUES (4294, '김정수', '사원');
  # 실제 EMP_DNO3라는 RELATION은 존재하지 않기 때문에 아래로 변환되어야 할 것이다.
  # 근데 이렇게 되면 다른 애트리뷰트 값에는 NULL을 채워 넣어야 하는데, 
  # 이걸 DBMS가 허용할 것인가?
  INSERT INTO EMPLOYEE
  VALUES (4293, '김정수', '사원', ... );
  ```

  일단 BASE RELATION은 PK가 있어야 한다. 얘는 PK는 있기 때문에 들어간다.

  ```SQL
  # JOIN을 통해 나온 VIEW에 삽입하기
  INSERT INTO EMP_PLANNING
  VALUES ('김대리', '대리', 2500000);
  # 어떻게 변환되나용
  INSERT INTO EMPLOYEE
  VALUES (, '김대리', '대리', ..., 2500000);
  ```

  어느 릴레이션으로 보내야 하는지 교통정리 쉽지 않음.

  기본 키도 없음. 따라서 값을 INSERT 하는 것이 불가능. DBMS가 리젝함

  - 집단 함수 등을 포함한 뷰에 갱신을 한다면

  ```sql
  CREATE VIEW EMP_AVGSAL (DNO, AVGSAL)
  AS SELECT DNO, AVG(SALARY)
  	FROM EMPLOYEE
  	GROUP BY DNO;
  # 갱신 시도 -> 허용할까? ㄴㄴ 현재는 허용하지 않는다.
  UPDATE EMP_AVGSAL
  SET AVGSAL = 3000000
  WHERE DNO = 2;
  # 이것도 허용하지 않음
  INSERT INTO EMP_AVGSAL
  VALUES (3, 2000000);
  ```

  집단 함수/통계 연산자를 사용한 뷰는 수정이 안된다. 

- 갱신이 불가능한 뷰

  1. 하나의 릴레이션 위에서 정의되었지만, pk가 포함되지 않은 뷰
  2. 기본 릴레이션의 애트리뷰트 중에서 뷰에 포함되지 않은 애트리뷰트에 대해 `NOT NULL`이 지정되어 있을 때
  3. 집단 함수가 포함된 뷰
  4. 조인으로 정의된 뷰

  ![image](https://user-images.githubusercontent.com/41130448/121316870-b6658e00-c944-11eb-9974-cbedf1bea641.png)

<BR>

### 스냅샷(snapshot)

- 뷰와 비교해서 볼 수 있는 개념

- 어느 시점에 `SELECT`문의 결과를 기본 릴레이션의 형태로 저장해 놓은 것

- 스냅샷을 정의하는 시점의 내용이 스냅샷에 반영됨

- 스냅샷 정의 예시

  어떤 시점의 조직체의 현황, 몇년 몇월 시점에 근무하던 사원들의 정보, 재고 정보 등

<BR>

### 시스템 카탈로그

- 시스템 내의 객체(기본 릴레이션, 뷰, 인덱스, 사용자, 접근 권한 등)에 관한 정보를 포함한다.

  메타 데이터라고도 한다.

  > 도서관 같은 경우에 책의 메타 데이터는 공유를 한다.
  >
  > video같은 멀티미디어 정보에서 중요한 이슈는 관리를 어떻게 할 것인가,, 검색을 어떻게 할 지 ?? 동영상에 대한 content-based search위한 메타 데이터가 잘 되어 있는 상황이다(mp4,mpeg .. ) 스크립트를 인식해서 텍스트로 저장하는 방법도 있음.
  >
  > 암튼 메타 데이터 분야는 꽤 크다.

- 사용자 및 질의 최적화 모듈 등 DBMS 자신의 구성요소에 의해서 사용된다.

  > query optimization은 했을 때 / 안했을 때 성능 차이가 굉장히 크므로 중요하다.

  관계 DBMS마다 표준화 되어 있지 않아서  관계 DBMS마다 서로 다른 형태로 기능을 제공한다. 

  > 사실상 표준화는 SQL 자체만 되어 있는 상태

- 시스템 카탈로그는 데이터 사전(DATA DICTIONARY) 또는 시스템 테이블이라고도 부른다.

- 이걸 적절히 활용하면 원하는 릴레이션을 DB에서 찾고, 그 릴레이션에 어떤 애트리뷰트들어 있으며, 각 애트리뷰트의 데이터 타입이 무엇인지 쉽게 파악할 수 있다. 

- 메타 데이터가 질의 처리에 어떻게 활용되는지 보자. 

  ```SQL
  # 예시
  SELECT EMPNAME, SALARY, SALARY * 1.1
  FROM EMPLOYEE
  WHERE TITLE = '과장' AND DNO = 2;
  ```

  1. 들어온 명령문을 파싱하여 `SELECT`문이 문법적으로 정확한지 검사함

  2. `SELECT`문에서 참조하는 `EMPLOYEE` 릴레이션이 DB에 존재하는지 검사

  3. `EMPLOYEE` 릴레이션 안에 `SELECT`에서 열거한 애트리뷰트 및 `WHERE`절에서 조건에 사용된 애트리뷰트가 존재하는 지 확인

  4. `SALARY` 애트리뷰트가 수식에 사용되었기 때문에 얘의 데이터 타입이 숫자형(정수/실수)인지 검사. `TITLE`이 문자열과 비교되었으므로 얘의 데이터 타입이 문자형(`CHAR(N)`, `VARCHAR(N)`)인지 검사

  5. 이 질의를 입력한 사용자한테 `EMPLOYEE`의 각 애트리뷰트 `EMPNAME`, `SALARY`를 검색할 권한이 있는지 확인

  6. `TITLE` 애트리뷰트와 `DNO` 애트리뷰트에 인덱스가 정의되어 있는지 확인

  7. 두 애트리뷰트에 각각 인덱스가 존재한다고 가장하자.

     DBMS가 두 익덱스 중에서 조건을 만족하는 튜플 수가 더 적은 것을 선택하기 위해서 (SELECTIVITY를 파악하기 위해서) 관계 DB 시스템에 추가적인 정보를 유지해야 함.

     > 추가 정보 : 그 이전에 쿼리를 수행하면서 알게 된 정보를 모아놓음. 그런 기록을 기반으로 추정 및 학습

  8. 한 릴레이션의 전체 튜플 수와 그 릴레이션에 정의된 각 인덱스에 존재하는 상이한 값들의 개수를 유지한다면 어느 인덱스를 사용하는 것이 유리한지 예상 가능 (도메인 CARDINALITY 등을 이용)

- 사용자 릴레이션과 같은 형태로 저장된다. (메타 데이터도 릴레이션이다)

  1. `SELECT`문을 사용해서 내용을 검색할 수 있다. 

  2. 사용자 릴레이션에 적용되는 회복 기법과 동시성 제어 기법을 사용할 수 있다.

- 릴레이션, 애트리뷰트, 인덱스, 사용자, 권한 등 각 유형마다 별도의 릴레이션이 유지된다.

  `SYS_RELATION`, `SYS_ATTRIBUTE`와 같이 생성됨

- 어떤 사용자도 시스템 카탈로그를 직접 갱신 불가

  `INSERT`, `UPDATE`, `DELETE` 명령 써서 변경 불가

  ```sql
  # 이렇게 하면 거절당함
  DELETE FROM SYS_ATTRIBUTE
  WHERE AttRelId = 'EMPLOYEE' AND AttName = 'MANAGER';
  # 이렇게 해야 함
  ALTER TABLE EMPLOYEE DROP COLUMN MANAGER;
  ```

- 시스템 카탈로그에 유지되는 통계 정보

  1. 릴레이션마다

     튜플의 크기, 튜플 수, 각 블록의 채우기 비율(fill factor), 블록킹 인수, 릴레이션의 크기(블록 수)

  2. 뷰마다

     뷰의 이름과 정의

  3. 애트리뷰트마다

     애트리뷰트의 데이터 타입과 크기, 애트리뷰트 내의 상이한 값들의 수(카디널리티), 애트리뷰트 값의 범위, 선택율(조건을 만족하는 튜플 수 / 전체 튜플 수, 이 값은 작동하면서 계속 값이 수정된다.)

  4. 사용자마다

     접근할 수 있는 릴레이션과 권환

  5. 인덱스마다

     인덱스된 애트리뷰트(키 애트리뷰트, 키가 아닌 애트리뷰트), 클러스터링 인덱스/비클러스터링 인덱스의 여부, 밀집/희소 인덱스 여부, 인덱스의 높이, 1단계 인덱스의 블록 수

- MSSQL Server의 경우

  - 주기적으로 통계 정보를 갱신함 (처리량이 많으므로 batch 방식 사용) 

    당장 반영하지 X

    `UPDATE STATISTICS`문을 사용해서 수동으로 갱신 가능

  - 갱신 필요성을 확인하기 위해서 샘플링 방법을 사용

  - 갱신되는 빈도는 애트리뷰트, 인덱스의 크기와 변경되는 데이터 양에 따름

  - 모든 릴레이션에 대한 구성을 정의하는 데이터를 시스템 테이블이라고 부르는 특수한 테이블 집합에 저장함

  - 정보 스키마 뷰, Transact-SQL문 및 함수, 시스템 저장 프로시저 등을 사용하여 시스템 테이블에 저장된 정보를 검색한다.

  - 프로시져를 인터페이스화 해서 검색 가능

  ```SQL
  # KIM이 소유한 릴레이션이나 뷰에 관한 정보 검색
  SELECT *
  FROM INFORMATION_SCHEMA.TABLES
  WHERE TABLE_SCHEMA = 'KIM';
  ```

  ```sql
  # 뷰가 어떤 SELECT문으로 정의되어 있는지
  sp_helptext EMP_PLANNING;
  # 릴레이션이 사용하는 디스크 공간 정보 알아보기
  sp_spaceused EMPLOYEE;
  # 릴레이션에 정의된 인덱스를 확인하기
  sp_helpindex EMPLOYEE;
  ```

  

<BR>

### 질의 최적화

- DBMS가 질의를 수행하는 여러 방법 중에서 가장 비용이 적게 드는 방법을 찾는 과정

- DBA가 알아야 함. 사실 어플리케이션 개발자는 몰라도 된다고 하긴함

  하지만 릴레이션에 관한 다양한 통계 정보가 정확히 유지돼야 한다는 것을 알아야 한다고함,,

- 질의 최적화 모듈이 정확한 결정을 내릴 수 있도록 DBMS는 다양한 메타 데이터를 유지

<br>