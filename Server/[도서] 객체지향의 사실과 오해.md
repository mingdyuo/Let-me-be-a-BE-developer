영문으로 된 글을 읽으면, 같은 말이지만 다른 예시와 단어를 사용하여 반복적으로 설명하는 경향이 있는데, 이 책도 비슷한 서술 방식을 가지고 있다. 어떻게 보면 동어 반복을 하고 있다고 볼 수 있고, 어떻게 보면 그만큼 강조하고자 하는 내용이 단순하고 명확하다고 볼 수 있다. 그래서 정신을 놓고 읽으면 어디까지 읽었는지 무슨 말을 하고자 하는지 헷갈릴 수 있다. 

나는 처음에는 책 읽듯이 쭉 읽다가 중간부터는 필기를 하며 읽었다. 무슨 말이냐면, 예시와 설명 부분은 묶어서 표시를 하고 결국 이 문장을 통해 말하고자 하는 개념이 무엇인지 반복적으로 체크를 하며 읽었다. 그런식으로 여러번 나오는 설명을 마주하고, 개념화 하다 보면 필자가 말하고자 하는 객체의 행위와 책임이 자연스럽게 중요하다고 인식하게 되고 굳이 노력하지 않아도 머릿속에 그려진다. 같은 말을 어떻게 다르게 하는지 확인하며 더욱 이해하는 것이다. 

(킹치만 paraphrasing이 좀 심해서 중간에 정신이 약간 혼미해질 수 있다.)

## 1장, 협력하는 객체들의 공동체





## 5장, 책임과 메시지

- 책임이 너무 구체적이라면 수행 방법을 제한시키고 객체가 자율적이지 못하게 된다.

- 책임이 너무 추상적이라면 협력의 의도를 명확하게 표현할 수 없다. 

- 책임은 '어떻게'를 정해주는 것이 아니라 '무엇을' 할지 정해주는 것이다.

  어떻게 할지는 객체의 자유이고, private한 영역이다.

- 객체끼리의 유일한 의사소통 방법은 메시지를 주고 받는 것이다. 메시지에는 수신자와 행동, 인자가 들어 있다.

- 다형성

  - 같은 메시지를 받았지만 그 메시지를 처리하는 방식이 다를 수 있다.
  - 그러나 보낸 사람 입장에서는 처리하는 방식이 다른 각 개체를 구별할 필요가 없다. 즉, 동일한 책임을 갖는 객체들이다.
  - 다형성은 이와 같이 동일한 책임/역할을 갖는 객체들이 서로 대체될 수 있음을 암시한다. 수신자의 종류를 캡슐화하는 것이다.
  - 송신자와 수신자 간의 관계가 서로 결합되지 않고, 메시지를 매개로 사용하며 결합도를 낮춘다.

- 송신자가 수신자에 대해 알아야 하는 정보는 단지 **수신자가 해당 메시지를 이해하고 처리할 수 있는지의 여부**뿐이다.

- 오해 부시기

  - 객체지향 애플리케이션은 클래스의 집합이 아니다 !
  - 클래스 간의 상속 관계가 객체 지향 설계의 핵심 메커니즘이 아니다 !
  - 중요한 것은 **객체들이 주고받는 메시지**이다.
  - 클래스는 단지 **동적인 객체들의 특성과 행위**를 **정적인 텍스트로 표현**하기 위해 사용하는 추상화 도구이다.
  
- 객체 내부의 데이터를 중심으로 클래스 설계 X

  협력이라는 문맥 내에서 데이터 조작에 필요한 오퍼레이션을 먼저 고려 O

- What/Who Cycle

  어떤 행위를 수행할지 결정 → 누가 그 행위를 수행할지 결정

  객체의 행위를 결정하는 것은 객체 자체의 속성이 아니다.

- TDD (책임주도설계)

  어떤 객체가 어떤 특성을 가지고 있다고 해서 반드시 그와 관련된 행위를 수행할 것이라고 가정하지 않음

  행위를 먼저 식별한 후에, 행위를 수행할 적절한 개체를 찾음

- 묻지 말고 시켜라 (데메테르 법칙)

  - 객체는 일을 시킬 때 다른 객체의 상태를 묻지 말아야 한다.
  - 단지 메시지를 전송하고, 받는 객체가 스스로의 상태에 따라 처리하도록 해라.
  - 그러려면 결국 메시지는 '어떻게 해라'가 아닌 '무엇을 해라'를 담고 있어야 한다.

### 인터페이스

- 특징 3가지

  1. 인터페이스의 사용법을 알면 내부 구조를 몰라도 된다.
  2. 인터페이스 자체를 건들지 않는 한 내부 구성이나 작동 방식을 변경해도 사용자에게 영향을 미치지 않는다.
  3. 대상이 변경되어도 동일한 인터페이스를 제공한다면 상호작용에 문제가 생기지 않는다.

- 공용 인터페이스와 사적 인터페이스로 나눌 수 있다.

- 관련된 원칙 3가지

  1. 좀 더 추상적인 인터페이스

     수신자의 자율성을 보장해준다. 

  2. 최소 인터페이스

     외부에서 사용할 필요가 없다면 최대한 노출하지 않는다.

  3. 인터페이스와 구현 간에 차이가 있다는 점을 인식

- 객체의 외부와 내부를 분리한다는 것  == 객체의 공용 인터페이스와 구현을 분리하는 것

- 훌륭한 객체는 구현을 모른 채여도 상관없이 인터페이스만 알면 쉽게 상호작용할 수 있는 것이다.

  인터페이스와 구현을 분리하는 게 왜 중요하냐면 **소프트웨어는 항상 변경되기 때문**이다.

  (그리고 나는 내가 만든 녀석을 언제든 변경할 수 있다는 생각을 디폴트로 가지고 있어야겠다.)

- 공용 인터페이스는 외부에서 전송 가능한 메시지의 집합이다.

<br>

### 캡슐화

- 캡슐화는 두 가지 관점에서 사용된다.
  1. 상태와 행위의 캡슐화
  2. 사적인 비밀의 캡슐화

### 결론

객체의 책임이 자율적이도록 해라. 

<br>

## 6장, 객체 지도

### 문제를 해결하는 2가지 방법 - 길을 찾을 때

1. 직접 길을 물어보기 : 기능적이고 해결책 지향적
2. 지도를 보기 : 구조적이고 문제 지향적

- 지도를 보는 방법은 범용적이다. 기능 지향적인 해결책보다, 구조 지향적인 해결책이 더 안정적임.

  요구사항이 수정되어도 사용할 수 있음. 이는 지도가 잘 변하지 않는 지형 정보를 기반으로 하고 있기 때문

- 기능이 아닌 구조를 기반으로 모델을 구축하는 것이 범용적으로 사용하기 좋으며, 변경에 안정적이다.

- 이번 장의 내용은, 기능이 아닌 구조를 바탕으로 시스템을 분할한다.

  책임 주도 설계의 본질과도 이어진다.

  **자주 변경되는 기능이 아닌 안정적인 구조를 따라 역할, 책임, 협력을 구성해라**

### 기능 설계  vs 구조 설계

- SW 제품 설계의 두 가지 측면

  1. 기능 → 훌륭한 소프트웨어의 충분 조건

  2. 구조 → 훌륭한 소프트웨어의 필요 조건

     깔끔하고 단순하며, 유지 보수하기 쉬운 설계

  이 두 가지 측면을 잘 녹여서 조화를 이루도록 만드는 것이 중요하며 어렵다.

- 구조 설계가 중요한 이유는 현실세계에서 SW의 요구사항이 항상 변경되기 때문이다.

- 변경은 예측할 수 없다. 모든 변경을 예측하는 것이 아니라, 변경을 수용할 수 있는 선택의 여지를 마련하는 정도로 설계에 반영한다.

- 과거 전통적인 설계는 기능 분해의 방식을 사용했다.

  시스템의 기능을 더 작은 기능으로 분해한다.

  각 기능은 서로 밀접한 하나의 덩어리를 이루므로, 변경이 발생하면 전체 소프트웨어가 바뀐다.

- 객체 지향 방식은, 시스템의 기능을 객체 간의 책임으로 분배한다.

  객체의 구조에 집중하고, 기능은 객체의 구조를 따른다.

  **이러한 객체를 이용하여 지도를 만들어라. 기능은 이 지도를 따라 자연스럽게 흘러갈 것이다.**

### 두 가지 재료: 기능과 구조

- 기능과 구조를 표현해보자

  1. **기능** : 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위

     → **유스케이스 모델링**을 통해 표현 가능 

  2. **구조** : 사용자나 이해 관계자들이 도메인에 관해 생각하는 개념 및 개념들 간의 관계

     → **도메인 모델링**을 통해 표현 가능

### 도메인 모델

- 사용자가 프로그램을 사용하는 대상 분야이다.

- 모델은 대상을 단순하게 표현한 것이다. 복잡하거나 세부적인 사항은 무시한다.

- SW가 목적하는 영역 내의 개념, 개념간의 관계, 다양한 규칙, 제약 등을 추상화 한 것이다,

- 이해 관계자들이 도메인에 대해 생각하는 관점이며, 멘탈 모델이다. 단순한 다이어그램이 아니다.

  비즈니스 규칙, 개념과 정책을 반영하며, 쉽게 바뀌지 않는 안정적인 구조이다.

- 사용자 모델, 디자인 모델, 시스템 이미지를 포괄하도록 추상화한 모델이 도메인 모델이다.

### 유스케이스

- **사용자의 목표**를 달성하기 위해 사용자와 시스템 간에 이루어지는 상호작용의 흐름을 *텍스트*로 정리한 것이다. *시나리오의 집합*이라고 볼 수 있다. (단일 시나리오는 유스케이스 인스턴스라고 한다.)

- 유스케이스 != 단순한 기능 목록 (feature)

  feature의 단점은 연관되어 있는 기능이 서로 독립적인 것으로 보이도록 만드는 것이다.

  유스케이스는 단순히 기능을 나열한 것이 아닌, 이야기를 통해 연관된 기능을 묶을 수 있다.

- 유스 케이스는 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다.

  사용자 관점에서 시스템이 외부에 제공하는 행위에 초점을 맞춘다.

- 유스케이스 != 설계 기법, 유스케이스 != 객체지향 기법

  유스케이스는 내부 설계, 구조 혹은 실행 메커니즘과 관련된 정보를 포함하지 않는다.

  기능적 요구사항을 사용자의 목표라는 문맥을 중심으로 묶기 위한 방법일 뿐이다.

### 기능과 구조의 통합

- 유스케이스 - 도메인 모델간의 관계

  RDD는 기능과 구조의 두 가지 재료인 유스케이스와 도메인 모델을 통합한다.

- 책임 할당의 기본 원칙은 책임을 수행하는 데 **필요한 정보를 가진 객체**가 그 책임을 갖는 것이다.

  → 상태와 행동을 함께 캡슐화 한다.

  → 자율적인 객체를 만든다.

- 일련의 흐름은 객체들의 협력으로 이어진다. 그 출발점은 유스케이스

- 객체지향은 모든 것을 객체로 바라본다. 큰 객체는 작은 객체로 나뉘어 질 수 있다. 크기와 관계 없이 이런 각 객체는 메시지를 전송하거나 수신할 수 있으며, 그 메시지에 응답하기 위해서 자율적으로 메소드를 선택할 수 있다.

  building block의 재귀적인 합성(composition) !

  객체 안에 객체를 포함하는 형태이므로 재귀적이라고 하는 것이다. 컴퓨터 자체에 대한 개념적인 재귀임. 객체 하나를 각각의 컴퓨터로 간주하고 그 안에도 알아서 일을 하는 컴퓨터와 같은 객체가 존재한다.

- 안정적인 도메인 모델을 기반으로 구현하면, 시스템의 기능이 변경되더라도 핵심 비즈니스 로직이 변경되지 않는 이상 전체적인 구조가 흔들리지 않는다.



<br>

## 7장, 함께 모으기

- 중요한 참고 사항

  1. 머릿속으로만 구상한 설계는 코드로 구현하는 단게에서 대부분 변경된다. 설계 작업은 구현을 위한 스케치를 작성하는 단계지 구현 그 자체가 아님

     중요한 것은 설계가 아니라 코드이며, 협력을 구상하는 단계에 너어어무 오랜 시간을 쏟지 말고 빨리 구현하면서 설계에 이상이 없는지, 설계가 구현 가능한지 판단해야 한다. 

     코드를 통해 피드백하며 깔끔한 설계를 얻을 수 있다.

  2. 객체에게 책임을 할당하고 인터페이스를 결정할 때에는 가급적 객체 내부의 구현에 대한 어떤 가정도 하지 말아야 한다. 객체의 속성과 그 속성이 어떤 자료 구조로 구현되었는지를 고려하지 않는 것이다.

     이렇게 해야 인터페이스와 구현을 깔끔하게 분리할 수 있다.

- 코드는 세 가지 관점을 모두 제공해야 한다.

  1. 개념 관점

  2. 명세 관점

     인터페이스는 구현에 대한 세부 사항을 노출해서는 안된다.

  3. 구현 관점

     클래스 내부의 속성과 구현은 변경이 되던 말던 절대 외부 객체에게 영향을 미쳐서는 안된다.

- **인터페이스와 구현을 분리해라 ! ! !** 

  명세 관점과 구현 관점이 뒤섞여지면 혼란스러워진다. 

<br>

### 부록 A 추상화 기법

- 추상화의 종류

  1. 분류와 인스턴스화
  2. 일반화와 특수화
  3. 집합과 분해

- 단일분류와 다중 분류

  단일 분류는 한 객체가 한 시점에 하나의 타입에만 속하는 것이다 (데스크톱 컴퓨터 / 노트북 컴퓨터)

  다중 분류는 한 객체가 한 시점에 여러 타입에 속할 수 있는 것이다. (데스크톱 컴퓨터이면서 사무용 컴퓨터)

- 대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다. 동시에 두 클래스의 인스턴스일 수 없다.

  (다중상속과 혼동하지 말자)

- 객체가 한 집합에서 다른 집합으로 속하는 타입을 변경할 수 있는 경우 동적분류라고 하며, 변경할 수 없는 경우 정적분류라고 한다. 대부분의 언어에서는 동적 분류를 구현할 수 없다. 한 객체 인스턴스의 타입은 변경될 수 없다.