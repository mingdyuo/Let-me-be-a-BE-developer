### Strategy 패턴

- 알고리즘군을 정의하고 캡슐화

- 필요한 알고리즘군을 교환하며 사용할 수 있다. 

- 사용하는 클라이언트와 독립적으로 알고리즘 변경 가능

- 예제

  오리의 속성을 상속받은 → 모형 오리, 진짜 오리

  모형 오리는 꽥꽥거리기 대신 삑삑거리기를 해야 하고, 진짜 오리와 달리 날 수 없다.

  → 오리의 행동을 분리하여 행동 인터페이스로 만들고 그 행동을 또다시 분류하여 구현

  → 오리 기반 클래스는 행동 인터페이스를 가지고 있고, 자식클래스는 그 인터페이스를 상속받는다. 행동 인터페이스를 상속받아서 만든 구현 클래스 객체를 가지고 있어서 실제 알맞는 행위 가능

- 행위(메소드)도 클래스로 구분할 수 있다.

  행위도 상태를 가질 수 있다. 예를 들면 `fly()`라는 행위의 경우에는 속도, 가속도, 방향과 같은 상태를 가지고 있을 수 있고, 이 상태는 행위에 또다시 영향을 미칠 수 있다.

<br>

### 옵저버 패턴

- 신문사와 정기구독자의 관계와 비슷하다

- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 간다.

  자동으로 그 내용이 갱신된다.

  일대다 관계를 나타낸다.

- 신문사는 subject, 정기구독자는 observer이다.

- 상태를 저장하고 있는 지배적인 객체는 subject 객체이다. (subject 객체가 데이터의 주인이다.)

  observer 객체는 상태를 꼭 가지고 있을 필요가 없다. (subject 객체를 의존한다.)

- 여러 객체에서 동일한 데이터를 제어하도록 할 때 좋은 디자인 패턴이다

### 느슨한 결합

- 두 객체가 느슨하게 결합되어 있다는 것은, 두 객체간에 상호작용이 있지만 서로에 대해 잘 모른다는 것이다.

- 옵저버 패턴에서는 subject와 observer가 느슨하게 결합되어 있다. 다음과 같은 이점들이 있기 때문이다.

  1. subject는 옵저버에 대해서 구현된 정보를 알 필요가 없다. 단지 "옵저버 인터페이스를 구현한다"는 것만 알면 된다.

  2. 옵저버는 언제든 새로 추가, 삭제할 수 있다. 실행중이라도 무관하다

  3. 새로운 형식의 옵저버를 추가해도, subject를 변경할 필요가 없다.

  4. subject와 옵저버는 독립적으로 재사용할 수 있다.

  5. subject와 옵저버가 바뀌더라도 서로에게 영향을 미치지 않는다.

     ↪ 결국 객체 사이의 상호 의존성을 최소화시킨다 !

