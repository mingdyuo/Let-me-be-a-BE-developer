# 데이터베이스

[KOCW 데이터베이스 강의](http://www.kocw.net/home/search/kemView.do?kemId=1064626)

- [x] 1차시 관계 대수와 SQL (21/06/01)
- [x] 2차시 관계 대수와 SQL (21/06/01)
- [x] 3차시 관계 대수와 SQL (21/06/01)
- [x] 3차시 관계 대수와 SQL 데이터베이스 설계와 ER 모델 (21/06/04)
- [x] 4차시 데이터베이스 설계와 ER 모델 (21/06/04)
- [x] 5차시 데이터베이스 설계와 ER 모델 (21/06/05)
- [x] 6차시 물리적 데이터베이스 설계 (21/06/05)
- [x] 7차시 물리적 데이터베이스 설계 (21/06/05)
- [x] 7차시 물리적 데이터베이스 설계, 릴레이션 정규화 (21/06/08)
- [x] 8차시 릴레이션 정규화 (21/06/08)
- [ ] 9차시 릴레이션 정규화, 뷰와 시스템 카탈로그 (21/06/08)
- [ ] 10차시 뷰와 시스템 카탈로그
- [ ] 11차시 트랜잭션
- [ ] 12차시 트랜잭션
- [ ] 13차시 데이터베이스의 저장과 접근 : 해싱 빅테이터 관리 서론
- [ ] 14차시 빅테이터 관리 서론
- [ ] 15차시 NoSQL Database Patterns
- [ ] 15차시 NoSQL Database Patterns

<br>

### 공부 가능한 사이트 / 소스

[SqlZoo](https://sqlzoo.net/)
[sql-ex](https://sql-ex.ru/)
[공공데이터포털](https://www.data.go.kr/)

<br>

## 목차

### [관계 대수와 SQL](#관계 대수와 SQL)

[관계 대수](# 관계 대수)
[SQL](# SQL)
[리눅스와 MySQL 접속 방법](#리눅스와 MySQL 접속 방법)
[데이터베이스 설계](#데이터베이스 설계)

### [ER 모델](#ER 모델)

[엔티티](#엔티티)
[약한 엔티티 타입](#약한 엔티티 타입)
[애트리뷰트](#애트리뷰트)
[관계와 관계 타입](#관계와 관계 타입)
[논리적 설계](#논리적 설계)

### [물리적 데이터베이스 설계](#물리적 데이터베이스 설계)

[보조 기억 장치](#보조 기억 장치)
[보조 기억 장치 - 자기 디스크](#보조 기억 장치 - 자기 디스크)
[버퍼 관리와 운영 체제](#버퍼 관리와 운영 체제)
[디스크 상에서 file의 레코드 배치](#디스크 상에서 file의 레코드 배치)
[file structure](#file structure)

<br>

## 관계 대수와 SQL

### 관계 대수

관계 데이터 모델에서 지원하는 두 가지 언어

1. 관계 해석 (relational caculus)
2. 관계 대수 (relational algebra)
   - 기존의 릴레이션으로부터 새로운 릴레이션을 생성
   - 피연산자와 연산이후의 결과 모두 릴레이션

- primitive operator : CPU가 바로 연산 가능

![image](https://user-images.githubusercontent.com/41130448/120252854-b02a3e80-c2c0-11eb-8300-e7b246a6e8a9.png)

- 세미 조인 - 반만 조인하는것?

- 카티션 곱 -> 양쪽의 튜플을 엮어서 가능한 모든 경우를 만드는 것

  튜플 수가 많은 경우 연산할때 시간이 겁나 많이 걸린다.

- Selection 연산자

  - 단항 연산자
  - 실렉션 조건을 predicate라고 한다. (true, false를 판단하는 기준)

- relation의 기본 원칙 : 모든 튜플들은 unique하다

- 임의의 relation으로 합집합을 만들 수는 없다. (의미가 없음)

  합집합 호환(union compatible)을 만족해야 한다.

  attribute의 수가 같고, 도메인이 같아야 함
  
- 프로젝션 할 때 중복 제거는 굉장히 오래걸리는 연산

  특별히 명령을 하지 않는 이상 중복이 허용되도록 연산이 이루어짐

- 카티션 곱

  임의의 두 릴레이션의 모든 가능한 조합을 만드는 릴레이션

  사용자가 실제로 원하는 것은 결과 릴레이션의 일부일 경우가 많다. 그래서 그 자체는 유용하지 않을 수 있다. 

  join을 하기 위한 연산이라서 중요한 것

- 관계 대수의 완전성

  관계 대수의 필수적인 연산자 : selection, projection, 합집합, 차집합, 카티션 곱 → 어떤 데이터 베이스 언어라도 이 연산자들은 꼭 표현할 수 있어야 한다.

  다른 관계 연산자 : 필수적인 관계 연산자를 두 개 이상 조합하여 표현 가능

  임의의 질의어가 적어도 필수적인 관계 대수 연산자들만큼의 표현력을 갖고 있으면 관계적으로 완전하다고 한다. (relationally complete)

- 조인 연산자

  두 개의 릴레이션으로 부터 **연관된 튜플**들을 결합함 (공통 attribute)

  릴레이션의 관계를 다루는 데에 매우 중요함

  종류

  → 세타 조인, 동등 조인(equi join), 자연 조인(natural join , 가장 많이 사용함), 외부 조인(outer join), 세미 조인

- 디비전 연산자

  나누어 지는 릴레이션이 나누는 릴레이션을 **모두** 포함하고 있어야 결과값에 포함됨

- 조인 연산은 disk에서 이루어지므로 시간이 많이 걸린다.

- 관계 대수의 한계

  - 산술 연산을 할 수 없음
  - 집단 함수 (aggregate function)을 지원하지 않음 (개별적인 검색만 가능, 통계 작업 불가)
  - 정렬을 나타낼 수 없음
  - 데이터베이스를 수정할 수 없음
  - 프로젝션의 연산 결과에 중복된 튜블을 나타내는 것이 필요할 때가 있는데 이를 명시하지 못함. 

- Data analysis

  그루핑하고, 통계 내는 것

  연도별, 부서별, 지역별 등등 다양한 기준을 가지고 한번에 그루핑하면 어렵다.

  multi dimension에서 dimension은 곧 attribute, 다차원의 경우 데이터가 많으므로 연산이 오래 걸림. 다 소팅해야 되기 때문에.

  그래서 수시로 하지 않고 주기적으로 정해놓고 가끔함

  이 분석을 batch로 (real-time으로) 처리하면 더 자주 작업을 진행할 수 있다.  

- 외부 조인

  left, right, full조인

  관련된 튜플은 모두 포함되고, 조인 조건을 만족하는 것을 넣는지 아닌지에 따라 나눔. 

<br>

### SQL

- SEQUEL부터 시작됨

- 비절차적 언어(선언적 언어)

  자신이 원하는 바만 명시, 처리하는 방법은 명시할 수 없음

- DBMS는 사용자가 SQL을 입력하면 그걸 번역해서 요구한 데이터를 찾아온다.

- 두 가지 인터페이스

  대화식(interactive), 내포된(embedded)

- 구성 요소

  데이터 정의어, 조작어, 제어어

- UPDATE DELETE INSERT

  릴레이션 하나에 대해서 수행됨. 단항 연산처럼

- SELECT

  여러 개의 릴레이션에 대해 수행 가능

- 데이터 정의어

  ![image](https://user-images.githubusercontent.com/41130448/120300552-015d2100-c307-11eb-9295-1839b1591830.png)

- 릴레이션, 도메인, 제약조건, 뷰, 권한 등을 그룹화하기 위해서 스키마 개념을 지원

  ```sql
  CREATE SCHEMA MY_DB AUTHORIZATION kim;
  
  DROP SCHEMA MY_DB RESTRICT; # 내부에 다른 릴레이션이 많이 존재하면 안삭제
  DROP SCHEMA MY_DB CASCADE; # 내부에 연결된 릴레이션 삭제
  ```

- 무결성 제약조건

  ```
  NOT NULL
  UNIQUE
  DEFAULT
  CHECK
  FOREIGN KEY REFERENCES
  ON
  (CASCADE UPDATE 등)
  ```

  DBMS 시스템 자체가 보장해주도록 설정할 수 있다.

  제약조건에 이름 붙혀서 추가 가능

  ```sql
  ALTER TABLE STUDENT ADD CONTRAINT STUDENT_PK
  	PRIMARY KEY(STNO);
  ```

- SELECT문

  정보를 검색하는 질의문

  관계 대수의 실렉션과 의미가 완전히 다르다.

  관계 대수의 실렉션, 프로젝션, 조인, 카티션 곱을 조합한 것

  ```sql
  SELECT [DISTINCT] ATTRIBUTES
  FROM RELATIONS
  [WHERE CONDITIONS]
  [GROUP BY ATTRIBUTES]
  [HAVING CONDITIONS]
  [ORDER BY ATTRIBUTES [ASC|DESC]];
  ```

- SIMILAR MATCH

  `%`를 사용

  ```SQL
  WHERE EMPNAME LIKE '이%' # 이씨 성을 갖는 사람 찾기
  ```

- 부정 검색 조건

  `<>`를 사용

  ```SQL
  WHERE DNO <> 1
  ```

- 리스트를 사용한 검색

  ```SQL
  WHERE DNO IN (1, 3)
  ```

- `NULL`과 비교를 하기 위해서는 `=`가 아닌 `IS`를 사용하자

  ```sql
  WHERE DNO IS NULL
  ```

- 집단 함수 - aggregate  function

  COUNT, SUM, AVG, MAX, MIN

- 그룹화

  `GROUP BY`절에 사용된 attribute에 동일한 값을 갖는 튜플들이 각각 하나의 그룹으로 묶임

  이 attribute를 그룹화 애트리뷰트 (grouping attribute)라고 한다.

  각 그룹에 대해서 하나의 튜플이 생성된다.

- HAVING

  그룹핑된 애트리뷰트에 조건 걸기

- 집합 연산

  UNION, EXCEPT, INTERSECT, UNION ALL, EXCEPT ALL, INTERSECT ALL

- 서브쿼리, 중첩 질의(NESTED QUERY)

  쿼리 속에 쿼리를 표현할 수 있다.

- SELF JOIN

  한 릴레이션에 속하는 튜플을 동일한 릴레이션에 속하는 튜플들과 조인하는 것

  실제로는 한 릴레이션이 접근되지만 FROM  절에 두 릴레이션이 참조되는 것처럼 나타내기 위해서 그 릴레이션에 대한 별칭을 두 개 지정해야 함.

  ```sql
  SELECT E.EMPNAME, M.EMPNAME
  FROM EMPLOYEE E, EMPLOYEE M
  WHERE E.MANAGER = M.EMPNO;
  ```

- SELECT의 WHERE절에 사용할 수 있는 연산자

  ```SQL
  IN, NOT IN, ANY(SOME), ALL, EXISTS
  ```

  EXIST → 조건을 만족하는 컬럼이 있는 경우

- 조인도 사실은 루프를 두개 도는 것이다.

- INSERT 명령을 할 때에는 무결성 제약 조건을 위배하는지 확인한다. 

  쿼리의 결과값을 INSERT문으로 삽입할 수 있다.

- 트리거

  명시적인 이벤트가 발생할 때마다 DBMS가 자동으로 사용자 정의 프로시저를 수행하도록 하는 것

  데이터베이스의 무결성을 유지하기 위한 일반적이고 강력한 도구임

  테이블 정의 시 표현할 수 없는 기업의 비즈니스 규칙들을 시행할 수 있다. (어플리케이션 대신)

  이벤트-조건-동작(ECA, Event, Condition, Action)이라고도 한다.

  조회, 검색에 대한 보고도 시킬 수 있다.

  ```sql
  CREATE TRIGGER <NAME>
  AFTER <EVENTS> ON <RELATION>
  [WHEN <CONDITION>]
  BEGIN
  	<SQLS>
  END
  ```

  연쇄적으로 트리거가 일어날 수 있음. 마치 핵분열이 일어나듯이...

- ASSERTION

  ```sql
  CREATE ASSERTION <NAME>
  CHECK <CONDITION>;
  ```

  일종의 룰이면서, 데이터베이스가 반드시 지켜야 하는 조건이다.

  predicate를 검사해서 참인 경우에만 DB 수정이 허용된다.

  무결성 제약 조건으로 볼 수 있다.

  ```sql
  CREATE ASSERTION EnrollStudentIntegrity
  CHECK (NOT EXISTS # 이런 건 있어서는 안된다
  	(SELECT	*
  	 FROM ENROLL
  	 WHERE STNO NOT IN
  	 	(SELECT STNO FROM STUDENT)));
  ```

- Embedded SQL

  모든 질의를 sql로 표현할 수는 없음 프로그래밍 언어의 개념을 사용해서 만든것

  호스트 언어(프로그래밍 언어)에 포함된 SQL문을 의미한다.

  요즘에는 SQL에 다 포함되어 있음.

  프로그래밍 언어는 릴레이션 단위로 처리하는 것이 아니라 레코드(튜플) 단위로 처리함. 따라서 데이터 구조가 불일치하는 문제(impedance mismatch)가 발생할 수 있음

  공용으로 사용하는 변수 host variable이 있다.
  
- 불일치 문제

  SQL과 호스트 언어의 처리 단위가 달라서 발생함

  이를 해결하기 위해서 커서(cursor)를 사용, 한번에 한 튜플씩 가져오는 수단

  `OPEN cursor`가 질의를 수행하고 그 결과의 첫번째 튜플 이전을 가르킴

  `FETCH`문으로 다음 튜플로 이동하고 attribute값을 명시된 호스트 변수에 복사함

  ```sql
  EXEC SQL BEGIN DECLARE SECTION;
  char name[] = "엄준식";
  char title[10];
  EXEC SQL END DECLARE SECTION;
  
  EXEC SQL
  	DECLARE title_cursor CURSOR FOR
  	SELECT title FROM employee WHERE empname = :name;
  
  EXEC SQL OPEN title_cursor;
  EXEC SQL FETCH title_cursor INTO :title;
  ```

- SQL 통신 영역(SQL Communications Area)

  C 프로그램에 내포된 sql문에 발생하는 에러를 알려줌

  SQLCA 데이터 구조의 에러 필드와 상태 표시자를 검사, 잘 수행되었는지 확인

  에러 핸들링 목적

  데이터를 성공적으로 가져오면 `SQLCODE` 값이 `0`이다.

  > 미국 도요타 급발진 원인 분석 시
  >
  > 이 프로그램이 잘못됬다는걸 증명함
  >
  > 에러 핸들링 부분이 잘못됬었다는데 그게 내포 SQL인지는 잘 머르겠네요?

<br>

### 리눅스와 MySQL 접속 방법

```shell
$ mysql -u {ID} -p
```

<br>

### 데이터베이스 설계

- 두 가지로 구분

  1. 개념적 DB 설계

     정보 사용의 모델을 개발

     실세계의 엔티티, 관계, 프로세스, 무결성 제약 조건 등을 나타내는 추상화 모델을 구축

     > 엔티티 : 서로 구분이 되면서 조직체에서 DB에 나타내려는 객체
     >
     > 관계 : 두 개 이상의 엔티티 간의 연관성
     >
     > 프로세스 : 관련된 활동
     >
     > 무결성 제약 조건 : 데이터의 정확성과 비즈니스 규칙

  2. 물리적 DB 설계

     실제로 DB를 어떻게 구현할 것인가

     물리적인 저장 장치와 접근 방식을 다룸

     DBMS 선정

- 개념적 수준의 모델

  - 이 범주에서 많이 쓰는게 바로 ER(Entity-Relationship) 모델임

    세계적으로 자연스럽게 통일된 느낌 (de facto standard)

  - 개념적 데이터 모델인 ER모델을 구현할 수 있는 구현 데이터 모델(implementation data model)이 존재함

    1. 관계 데이터 모델
    2. 계층 데이터 모델
    3. 네트워크 데이터 모델

- 설계에 필요한것

  탑다운 과정으로 내려감

  이 회사에서 사용하는 응용 프로그램이 뭔가?

  그 응용 프로그램이 사용하는 데이터가 뭔가?

  이 데이터들은 서로 어떤 관계가 있는가?

- 설계시 중요한 것

  시간의 흐름에 따른 데이터의 측면을 나타낼 수 있어야 함

  중복 최소화

  효율적인 접근 제공

  무결성 제공

  이해하기 쉬워야 함

- 설계 과정

  개념적 설계(ER 모델링) - 논리적 설계(스키마) - 스키마 정제(정규화 등) - 물리적 설계(인덱싱 등) - 보안 설계 - 구현 단계

- 요구사항 수집과 분석

  제일 어려운 것이다. 설계 변경을 최소화 하기 위해서 이 단계를 잘 해야 함

  고객들은 자기가 뭘 필요로 하는 지 잘 모름. 고객들을 잘 가이드 해야 함. 이 부분을 컨설턴트들이 하는데, 부가 가치가 높은 부분임. 분석된 결과를 가지고 설계를 의뢰 할 수 있음

  요구사항에 대한 지식을 기반으로 관련된 엔티티, 관계, 애트리뷰트 등을 파악해야 함

  데이터 처리 시 전형적인 연산, 연산들의 의미, 접근하는 데이터의 양을 분석

- 물리적 설계 시 성능상 고려할 점

  1. 응답 시간 : 질의와 갱신이 평균 / 피크 시간 때 얼마나 오래 걸릴 것인가

  2. 트랜잭션 처리율 : 1초당 얼마나 많은 트랜잭션들이 평균 / 피크시간 때 처리될 수 있는가?

     벤치마킹해서 성능 평가

  3. 전체 DB에 대핸 보고서를 생성하는 데 얼마나 오래 걸릴 것인가?

  → 평균 / 피크 시간을 모두 고려해야 함

  → 튜닝을 위한 SW를 사용할 수도 있음

- 트랜잭션 설계

  - 요구사항 수집과 분석 후, DB 설계에 대해 별도로 진행
  - 완성될 데이터베이스에서 동작할 응용 프로그램에 대한 것
  - DB 스키마는 트랜잭션에서 요구하는 모든 정보를 포함해야 한다.
  - 검색, 갱신, 혼합 으로 구분하고 입력, 출력, 동작 등을 식별
  - 트랜잭션의 종류별 빈도 수도 고려해야 한다. 주요 트랜잭션을 잘 처리할 수 있도록 데이터를 튜닝할 필요성이 있음

<br>

## ER 모델

- DB 설계를 용이하게 하기 위해 제안된 것

  현재는 EER(Enhanced Entity Relationship)모델 사용

- 기본 구문 : 엔티티, 관계, 애트리뷰트

  기타 구문 : 카디날리티 비율, 참여 제약 조건 등

- CASE 도구들에서는 ER 설계를 자동적으로 DB 스키마로 변환 가능

- 또다른 표기법 : 새발 표기법

  좀더 컴팩트하게 표기하기 위해서 사용

  ![image](https://user-images.githubusercontent.com/41130448/120877970-585b4280-c5f4-11eb-8621-7f080b5ed8e5.png)

  ![image](https://user-images.githubusercontent.com/41130448/120877978-690bb880-c5f4-11eb-96c1-165c3aeeacb1.png)

  ![image](https://user-images.githubusercontent.com/41130448/120877987-75901100-c5f4-11eb-8681-43783a5dd563.png)

  

<br>

### 엔티티

- 엔티티

  - 설계자가 결정하는 것

  - 독립적으로 존재해서, 고유하게 식별 가능한 객체

  - 사원처럼 실체가 있을 수도 있고, 생각이나 개념처럼 추상적일 수도 있음

  - 같은 타입을 묶어서 엔티티 타입/집합 이라고 함, 엄격하게 구분할 필요는 X

    1. 엔티티 타입(스키마)

       동일한 애트리뷰트를 가진 엔티티의 틀 → 같은 애트리뷰트는 같은 종류의 실체라는 것

       관계 모델의 릴레이션의 내포에 해당

       ER 다이어그램에서 직사각형으로 나타냄

    2. 엔티티 집합(인스턴스)

       동일한 애트리뷰트를 가진 엔티티들의 모임

       관계 모델의 릴레이션의 외연에 해당

  - 하나의 엔티티는 한 개 이상의 엔티티 집합에 속할 수 있음

- 엔티티의 두 가지 타입

  1. 강한 엔티티 타입
     - 독자적으로 존재
     - 자신의 키 애트리뷰트 사용하며 고유하게 식별 가능
  2. 약한 엔티티 타입
     - 키를 형성하기에 충분한 애트리뷰트 X
     - 소유 엔티티 타입이 있어야 존재 가능 (dependent)
     - 소유 엔티티 타입의 키 애트리뷰트를 결합해서 식별, 따라댕겨야 함

<br>

### 약한 엔티티 타입

- 키를 형성하기에 충분한 애트리뷰트 X

- 소유 엔티티/식별 엔티티 타입으로부터 키 애트리뷰트를 제공받음

  > 회사 입장에서 [사원 - 부양 가족] 관계에서 부양 가족은 사원에 딸려 있는 것
  >
  > 사원이 없어지면 의미 없는 정보

- ER 다이어그램에서 이중선 직사각형으로 표현

- 부분 키 (partial key)

  부양 가족의 이름처럼 한 사원에 속한 부양 가족 내에서는 서로 다르지만, 회사 전체 사원들의 부양가족 전체에서는 같은 경우가 생길 수 있는 애트리뷰트

  점선 밑줄을 그어서 표기

<br>

### 애트리뷰트

- 하나의 엔티티를 설명하는 집합들
-  애트리뷰트의 도메인 : 그 애트리뷰트가 가질 수 있는 가능한 값들의 집합
- ER 다이어그램에서 타원형으로 나타내며, 기본 키 애트리뷰트는 밑줄 그어 표시
- 요구사항 명세에서 명사나 형용사로 표현
- 엔티티와 달리 독립적인 의미를 갖지 않음, 그 자체로 어떤 의미가 있지는 않음
- 엔티티 타입과 실선으로 연결
  1. 단순 애트리뷰트
     - 더 이상 다른 애트리뷰트로 나눌 수 없음
     - 실선과 타원으로 표시함
     - ER 애트리뷰트에서 대부분임
  2. 복합 애트리뷰트
     - 두 개 이상의 애트리뷰트로 이루어짐
     - 동일한 엔티티 타입이나 관계 타입에 속하는 애트리뷰트 중에서 밀접하게 연관된 것을 모아놓은 것 
     - 계층 구조
  3. 단일 값 애트리뷰트(single-valued attribute)
     - 각 엔티티마다 정확히 하나의 값을 갖는다, 여러 개의 값을 갖지 않음
     - 단순 애트리뷰트와 동일하게 표현
     - ER 다이어그램에서 대부분임
  4. 다치 애트리뷰트(multi-valued attribute)
     - 각 엔티티마다 여러 개의 값을 가질 수 있음
     - ER 다이어그램에서 이중선 타원으로 표시함
     - 관계형 DB에서 여러 개의 애트리뷰트 값을 가질 수 없음, 어케 표현할까용?
  5. 저장된 애트리뷰트(stored attribute)
     - 다른 애트리뷰트와 독립적으로 존재
     - 표현은 단순 애트리뷰트와 동일
     - ER 다이어그램의 대부분
     - 사원의 이름, 급여 등
  6. 유도된 애트리뷰트 (derived attribute)
     - 다른 애트리뷰트의 값으로부터 얻어짐
     - 관계형 DB에서 릴레이션의 애트리뷰트로 포함시키지 않는 게 좋다.
     - ER 다이어그램에서 점선 타원으로 표현함
     - 나이 같은 것

<br>

### 관계와 관계 타입

- 엔티티들 사이에 존재하는 연관, 연결

- 관계 집합은 동질의 관계들의 집합

  관계 타입은 동질의 관계들의 틀

  > 엄격히 구분할 필요는 없다.

- 요구사항 명세에서 주로 동사를 표현한다.

- ER 다이어그램에서 다이아몬드로 표현

- 엔티티를 관계 타입에 실선으로 연결

- 관계도 특징을 기술하는 애트리뷰트가 존재 가능

  키 애트리뷰트를 갖지 않음 (WHY?????)

  관계는 키를 갖는다는 게 의미가 없다. 키의 역할은 엔티티의 기본 키들이 한다. (참조키들)

  > 관계를 supply chain 자동화 할 때 사용 가능. 많은 부품을 관리할 때 납기, 장소, 수량 등을 잘 관리해야 함

- 차수 (degree)

  - 어떤 관계로 연결된 엔티티 타입들의 개수
  - 실세계에서는 두 개의 엔티티 타입을 연결하는 2진 관계가 제일 많다.

- 카디날리티

  - 카디날리티 비율 : 한 엔티티가 다른 엔티티와 맺을 수 있는 관계의 수

  - 관계 타입에 참여하는 엔티티들의 가능한 조합을 제한. 반드시 참여하도록 할 수도 있음

  - 1:1, 1:N, M:N으로 구분

    > 1 to many는 보통 계층 구조가 많음

  - 간선 위에 카디날리티 정보를 표시

  - 카디날리티 비율의 최소값과 최대값

    `(min, max)`로 표시함. mandatory/optional을 표현할 수 있음

- 역할(role)

  - 관계를 명확히 하는 역할
  - 간선 위에 표시

- 전체 참여와 부분 참여 (total/partial participiation)

  - 모든 엔티티가 관계에 참여하는지의 여부에 따라 나눔

  - 약한 엔티티 타입은 항상 관계에 전체 참여함

    ER 다이어그램에서 이중 실선으로 표시

  - 관계에 대한 중요한 제약 조건임

- 기타 관계

  1. 다중 관계 (multiple relationship)

     두 엔티티 타입 사이에 두 개 이상의 관게타입이 존재할 수 있다.

  2. 순환적 관계 (recursive)

     하나의 엔티티 타입이 동일한 관계 타입에 두 번 이상 참여

- ER 스키마 작성 지침

  - 엔티티는 키 이외에 설명 정보가 추가로 필요함
  - 다치 애트리뷰트는 엔티티로 분류해야 한다.
  - 가능한 복합 식별자는 피하자.
  - 관계는 독자적으로 존재할 수 없지만, 엔티티 타입과 관계 타입을 엄밀하게 구분하는 것은 어렵다.

<br>

### 논리적 설계

- ER 스키마를 관계형 DBMS의 릴레이션으로 사상시키기

- ER 스키마에서는 엔티티 타입과 관계 타입이 존재하지만, 관계형 DB에는 엔티티 타입과 관계 타입을 구분하지 않고 릴레이션들만 있음

- 릴레이션으로 사상할 대상이 ER 스키마에서 엔티티 타입인지, 관계 타입인지

  엔티티 타입이라면 정규 엔티티 타입인지, 약한 엔티티 타입인지

  관계 타입이라면 2진 관계 타입인지 3진 이상의 관계 타입인지

  애트리뷰트가 단일 값 애트리뷰트인지, 다치 애트리뷰트인지

  등에 따라서 사상하는 방법이 달라진다.

- ER 모델을 릴레이션으로 사상하는 7 단계의 알고리즘이 있다.

1. 정규 엔티티 타입과 단일 값 애트리뷰트

   - ER 스키마의 각 정규 엔티티 타입 E에 대해서 하나의 릴레이션 R을 생성한다.
   - E에 있던 단순 애트리뷰트들을 릴레이션 R에 모두 포함시킨다.
   - E에서 복합 애트리뷰트는 그 복합 애트리뷰트를 구성하는 단순(leaf) 애트리뷰트들만 릴레이션 R에 포함시킨다.
   - E의 기본 키가 릴레이션 R의 기본 키가 된다.

2. 약한 엔티티 타입과 단일 값 애트리뷰트

   - ER 스키마에서 소유 엔티티 타입 E를 갖는 각 약한 엔티티 타입 W에 대하여 릴레이션 R을 생성한다.
   - W에 있던 모든 단순 애트리뷰트들을 릴레이션 R에 포함시킨다.
   - 소유 엔티티 타입에 해당하는 릴레이션의 기본 키를 약한 엔티티 타입에 해당하는 릴레이션에 외래 키로 포함시킨다.
   - 약한 엔티티 타입에 해당하는 **릴레이션 R의 기본 키**는 **약한 엔티티 타입의 부분 키**와 **소유 엔티티 타입에 해당하는 릴레이션을 참조하는 외래 키**의 조합으로 이루어진다.

3. 2진 1:1 관계 타입

   - ER 스키마의 각 2진 1:1 관계 타입 R에 대하여, R에 참여하는 엔티티 타입에 대응되는 릴레이션 S와 T를 찾음

   - 릴레이션으로 바꾸는 방법들

     1. S와 T 중에서 한 릴레이션을 선택하여, 만일 S를 선택했다면 T의 기본 키를 S의 외래키로 포함시킨다. (외래키 자체가 관계를 표현)

        S와 T 중에서 관계 타입에 완전하게 참여하는 릴레이션을 S의 역할을 하는 릴레이션으로 선택한다.

        관계 타입 R이 가지고 있는 모든 단순 애트리뷰트(복합 애트리뷰트를 갖고 있는 경우에는 복합 애트리뷰트를 구성하는 단순 애트리뷰트)들을 S에 대응되는 릴레이션에 포함시킨다.

        > 하지만 이 외래키가 관계를 포함하는 것인지 의도를 쉽게 알 수 없다는 문제가 있음
        >
        > 참조 관계이기 때문에 외래키를 어디에 넣느냐에 따라서 조인 방식이 달라질 수 있다. 한쪽은 인덱스가 안되어 있는 경우도 있고 이런 요인에 따라서 방향성이 달라짐.

     2. 관계를이한 릴레이션 R을 생성함. 양쪽 S, T의 기본 키를 각각 외래 키로 갖는다. 관계에 해당하는 애트리뷰트도 R에 포함한다. (복합 애트리뷰트인 경우 복합 애트리뷰트를 구성하는 단순 애트리뷰트)

        > 이 방법이 제일 중립적이고 일반적인 방법이다. 하지만 항상 릴레이션의 join을 두번 해야 하므로 오버헤드가 커질 수 있다.
        >
        > 조인 오버헤드를 줄이기 위해서 1번 방법을 사용할 수 있다.

     3. 두 엔티티 타입이 관계 타입 R에 완전하게 (모두) 참여할 때는 두 엔티티 타입과 관게타입을 하나의 릴레이션으로 합칠 수도 있다. (예외적인 케이스이긴 하다.)

        > 두 엔티티는 의미적으로 독립적인 엔티티이기 때문에, 합쳤을 때 의미상으로 애매해진다. 실질적인 퍼포먼스 측면에서는 제일 좋을 수 있다.

4. 정규 2진 1:N 관계 타입

   - 관계 타입 R에 대해서 N측(참여 엔티티 타입)에 대응되는 릴레이션 S를 찾는다.
   - 관계 타입 R에 참여하는 1측(엔티티 타입)에 대응되는 릴레이션 T의 기본 키를 릴레이션 S에 외래 키로 포함시킨다.
   - S의 기본 키를 T의 외래 키로 포함시키면 애트리뷰트에 값의 집합이 들어가거나 정보의 중복이 많이 발생할 수 있다.
   - 관계 타입 R이 가지고 있는 모든 단순 애트리뷰트를 S 릴레이션에 포함시킨다.

5. 2진 M:N 관계 타입

   - 관계 타이에 해당하는 릴레이션 R을 생성한다.
   - 참여 엔티티 타입에 해당하는 릴레이션들의 기본 키를 R의 외래 키로 포함시킨다. 이들의 조합이 R의 기본 키가 된다.
   - 관계 타입 R의 단순 애트리뷰트는 릴레이션 R에 포함시킨다. 

6. 3진 이상의 관계 타입

   - 각 관계 타입 R에 대하여 릴레이션 R을 생성한다.
   - 관계 타입 R에 참여하는 모든 엔티티 타입에 대응되는 릴레이션들의 기본 키를 R에 외래 키로 포함시킨다.
   - 관계 타입 R의 단순 애트리뷰트는 릴레이션 R에 포함시킨다.
   - 일반적으로 외래 키들의 조합이 릴레이션 R의 기본 키가 된다.
   - 관계 타입 R에 참여하는 엔티티 타입들의 카디날리티가 1:N:N인 경우, 카디날리티가 1인 릴레이션의 기본 키를 참조하는 외래 키를 제외한 나머지 외래 키들의 조합이 릴레이션 R의 기본 키가 된다. 

7. 다치 애트리뷰트

   - 각 다치 애트리뷰트에 대하여 릴레이션 R을 생성한다.
   - 다치 애트리뷰트에 해당하는 애트리뷰트를 릴레이션 R에 포함시키고, 다치 애트리뷰트를 애트리뷰트로 갖는 엔티티 타입이나 관계 타입에 해당하는 릴레이션의 기본 키를 릴레이션 R에 외래 키로 포함시킨다.
   - 릴레이션 R의 기본 키는 다치 애트리뷰트와 외래 키의 조합이다.

<br>

## 물리적 데이터베이스 설계

- 데이터에 대한 효율적인 접근을 제공하기 위해서 저장 구조와 접근 방법을 다룬다. 

  storage structure에 따라서 접근 방식이 달라진다. 

- 파일 구조 (storage structure) / OS와 관련이 있다.

  논리적 설계의 데이터 구조를 보조 기억 장치 상의 file로 사상한다.

- 예상 빈도, 데이터베이스 질의와 트랜잭션을 분석한다. 

  질의를 효율적으로 지원하기 위해서 인덱스 구조를 적절히 사용할 수 있다.

  요즘은 솔루션을 통해서 질의 자체를 통계낼 수도 있다.

- 특정 DBMS의 특성을 고려해서 설계를 진행할 수 있다.

- 원래는 하드 디스크에 저장했지만 요즘은 flash memory에 저장

  flash memory에 어떻게 파일을 저장하는지가 중요함

  기본 원리는 비슷하기 때문에 하드 기준으로 살펴보자.

- optimal solution을 찾는 것은 아주 어렵다. 그래서 optimal에 가까운 것을 찾는다.

### 보조 기억 장치

- 데이터들이 저장되는 공간. 장기간 보관하기 위해서 주로 디스크를 사용함.

  옛~날에는 테이프를 사용함. 용량이 크고 싸다.

- 검색을 할 때에는 디스크 상에서 원하는 데이터를 포함하고 있는 블록을 읽는다. 주기억장치에 가지고 와서 찾는다.

- 데이터가 변경된 경우에는 해당 블록을 디스크에 다시 기록한다.

- 블록 단위는 다양함. 512byte ~ 수 kb

  현재는 통상 4kb 정도, 더 클 수도 있음

- 각 file은 고정된 크기의 블록으로 나뉘어서 저장된다.

- 무선 통신 속도는 빠르지만 저장 장치에 기록하는 속도가 느려서 다운로드가 느릴 수 있음

### 보조 기억 장치 - 자기 디스크

- 자기 물질로 만들어진 여러 개의 판으로 이루어짐

  각 판은 트랙과 섹터로 구분

  정보는 디스크 표면 상의 동심원(트랙)을 따라서 저장됨

- 각 면마다 디스크 헤드가 존재

- 실린더 : 여러 개의 디스크 면 중에서 같은 지름을 갖는 트랙들

- 블록은 한 개 이상의 섹터로 이루어진다.

- 디스크에서 임의의 블록을 읽어오거나 기록하는 데 걸리는 시간

  seek time + rotational delay(회전 지연 시간) + transfer time

  > seek time : 헤드가 트랙을 따라서 움직이는 시간
  >
  > 하드 디스크 도는 속도 : 1분에 만번 정도 (빨리 돌수록 비쌈)

- 플래시 메모리는 ㄹㅇ 랜덤 액세스가 된다.

  데이터가 어디에 있던간에 읽어 오는 시간이 똑같은걸 보장함

  디스크에서는 헤드를 실린더마다 만들 수가 없어서 그게 안됨.

  > 한 파일(relation)을 한 실린더에다가 저장하면 움직이지 않고 빠르게 읽을 수 있음

### 버퍼 관리와 운영 체제

- 디스크 입출력은 컴퓨터 시스템에서 가장 속도가 느린 작업임

  따라서 입출력 횟수를 줄이는 것이 DBMS의 성능을 향상시키는 데에 중요하다.

  > 매직 넘버 : 이론적으로는 알 수 없지만 실제 실험적으로 했을 때 가장 좋은 숫자 (엔지니어링 넘버)
  >
  > 몇 번 읽어오면 가장 좋은지 알아내기

- 가능하면 많은 블록을 혹은, 자주 참조되는 블록을 메모리 상에 유지해 놓으면 블록 전송 횟수를 줄일 수 있다.

- 버퍼는 디스크 블록을 저장하는 데 사용되는 주기억 장치 공간

- 버퍼 관리자는 운영체제의 구성요소이다. 주기억 장치 내에서 버퍼 공간을 할당하과 관리하는 일을 맡는다.

- 운영체제에서 버퍼 관리를 위해서 LRU 알고리즘을 사용하는데, 이는 데이터 베이스에 대해서는 항상 우수한 성능을 갖지는 않는다. 

  DBMS가 관리하는 메타 데이타는 스키마 정보가 된다. 스키마 정보는 자주 액세스하니까 이런건 버퍼에 올려 놓는 것이 좋다. 

  OS는 이런 어플리케이션의 특징점을 잘 모른다. 

### 디스크 상에서 file의 레코드 배치

- 릴레이션의 애트리뷰트는 고정 길이 또는 가변 길이의 필드로 표현 된다.

  > 고정 길이의 경우에는 overwrite도 좀 편한 편이다. 
  >
  > 가변길이의 경우에는 내용물이 변경되었을 때 핸들링하는 알고리즘이 복잡해질 수 있다. 

- 연관된 필드들이 모여서 고정 길이 또는 가변 길이의 레코드가 된다.

- 한 **릴레이션**을 구성하는 **레코드들의 모임**이, **file**이라고 부르는 **블록들의 모임**에 저장된다. 

- 파일, 블록, 레코드의 구조도

  보통 가장 첫번째 블록에 제어 정보(control block)을 저장한다. 헤더라고도 부름.

  ![image](https://user-images.githubusercontent.com/41130448/120881679-d37d2280-c60d-11eb-88c0-dc19a91b183c.png)

- 위와 같은 블록이 실제 물리적으로 연속되어 있지는 않다. 

  튜플은 다이나믹한 구조이므로 계속 변화하기 때문에 연속성을 유지시켜 줄 수 가 없음

- 인접한 블록들을 읽는 경우에는 seek time과 rotation delay가 걸리지 않으므로 입출력 속도가 빠름. 따라서 블록들이 인접하도록 한 file의 블록들을 재조직할 수 있다. 

  이게 디스크 조각모음인듯??

- BLOB(Binary Large Object)

  - 이미지(GIF, JPG), 동영상(MPEG, AVI) 등의 대규모 크기의 데이터를 저장하는 데 사용
  - BLOB의 최대 크기는 MS SQL에서 2GB 가능

- 채우기 인수 (fill factor)

  - 각 블록에 레코드를 채우는 공간의 비율,  한 블럭을 레코드로 몇 %를 채울 것인가.

  - 나중에 레코드가 삽입될 때 기존의 레코드를 이동하는 가능성을 줄이기 위해서 사용한다.

    무조건 꽉꽉 채워서 저장한다고 좋은 것은 아님

  - 이 비율은 application 성격에 따라서 달라짐. 엔지니어링 value임. 현장 지식이 반영되어야 한다.

- 고정 길이 레코드

  i번째 레코드를 접근하기 쉽다.

  레코드 삭제 시 채워넣는 방법들

  1. 여러 개의 레코드를 쭉 올린다.
  2. 한 개의 레코드를 빼서 채워 넣는다. (가변 길이 레코드는 이런 작업이 불가능함)

- 파일 내의 클러스터링 (intra-file clustering)

  한 file 내에서 함께 검색될 가능성이 높은 레코드들을 디스크 상에서 물리적으로 가까운 곳에 모아 두는 것 (연속적으로 저장)

  데이터 마이닝에서 많이 사용함

- 파일 간의 클러스터링 (inter-file clustering)

  논리적으로 연관되어 함께 검색될 가능성이 높은 두 개 이상의 file에 속한 레코드들을 디스크 상에서 물리적으로 가까운 곳에 저장하는 것

  서로 다른 레코드들을 클러스터링 할 수 있음

### file structure

1. heap file

   - 레코드가 삽입되는 순서대로 저장함. 가장 단순한 형태

   - 새로 들어오면 맨 끝에 넣고(append), 검색하기 위해서는 모든 레코드를 순차적으로 접근해야 함. 삭제하는 경우 검색 후 삭제 처리하고, 해당 공간을 재사용하지 않음(다 이동시키지 않기 위해서)

   - 고속으로 데이터를 입력받는 경우 좋다. 

   - 성능을 좋게 유지하려면 주기적으로 파일을 재조직 해야 한다. 삭제 작업이 많이 이루어진 경우 빈 공간이 많아지기 때문이다.

   - 성능에 대해서

     1. 모든 레코드를 참조하고, 레코드 접근 순서는 중요하지 않는 질의의 경우 쓰기 좋다.

     2. 특정 레코드를 검색하는 경우에는 비효율적이다.

        삽입만 빠르고 나머지는 다 속도가 구림

        그래서 특수한 경우가 아니면 잘 쓰지 않는다.

2. sequential file

   - 하나 이상의 필드의 값(search key)을 기준으로 정렬해놓음
   - 삽입 연산은 레코드의 순서를 고려해야 하므로 시간이 많이 걸림
   - 삭제 시에도 heap file처럼 빈 공간으로 남김
   - 키를 기반으로 하므로 탐색시에만 빠르고 나머지 연산은 다 구리다.
   - DB 응용 시 거의 쓰지 않음

3. indexed sequential file - 단일 단계 인덱스

   - 인덱스를 통해서 임의의 레코드를 접근할 수 있음

   - 각 엔트리는 <search key, record pointer>로 구성도미

   - 엔트리들은 탐색 키 값의 오름차순으로 정렬된다.

     ![image](https://user-images.githubusercontent.com/41130448/120883246-07a91100-c617-11eb-8eac-4874a3bb2ae0.png)

   - 인덱스는 데이터 file 과는 별도의 file로 저장됨

   - 인덱스의 크기는 데이터 파일보다 훨씬 작음

   - 하나의 파일에 여러 개의 인덱스를 정의할 수 있음

     ![image](https://user-images.githubusercontent.com/41130448/120883284-4dfe7000-c617-11eb-989b-9c9b0de4e0e9.png)

   - 인덱스가 정의된 필드를 탐색 키라고 부른다.

     탐색 키의 값들은 후보 키처럼 각 튜플마다 고유하지는 않음

   - 탐색 키는 어떤 애트리뷰트도 다 쓸 수 있음

     하지만 카디널리티를 고려해서 효율적인 것을 선택해야 함. 안그러면 인덱싱하는 의미가 없다.

   - 탐색 키 값을 기준으로 오름차순 정렬되어 있으므로 이진 탐색 가능

   - 기본 인덱스 (primary index)

     - 탐색 키가 데이터 파일의 PK인 경우 기본 인덱스라고 한다.

     - 기본 인덱스는 PK 값에 따라서 정렬된 데이터 파일에 대해서 정의된다.

     - 기본 인덱스는 보통 희소(sparse) 인덱스로 유지가능하다. 

       희소 인덱스는 특정 범위로 분절해서 대표값만 추려서 만드는 것

       희소 인덱스로 만드려면 무조건 데이터 파일이 정렬이 되어 있어야 한다. 

     - 각 릴레이션마다 최대 한개의 기본 인덱스를 가질 수 있다.

   ![image](https://user-images.githubusercontent.com/41130448/120883463-4a1f1d80-c618-11eb-80d2-557e4ae43d29.png)

   - 클러스터링 인덱스 (clusteting index) 7-48:51
     - 탐색 키 값에 따라 정렬된 데이터 파일에 대해 정의된다.
     
     - 각각의 상이한 키 값마다 하나의 인덱스 엔트리가 인덱스에 포함된다.
     
     - 범위에 대한 질의(Range query)에 유용하다.
     
       범위의 시작 값에 해당하는 인덱스 엔트리를 먼저 찾고, 범위에 속하는 인덱스 엔트리들을 따라가면서 레코드를 검색할 때 디스크에서 읽어오는 블록 수가 최소화된다.
     
     - 어떤 인덱스 엔트리에서 참조되는 데이터 블록을 읽어 오면 그 데이터 블록에 들어 있는 대부분의 레코드들은 범위를 만족한다.
     
   - 보조 인덱스 (secondary index)

     - 한 file은 한 가지 필드의 조합에만 대해서 정렬할 수 있음

     - 보조 인덱스는 탐색 키 값에 따라 정렬되지 않은 데이터 파일에 대해 정의된다.

     - 보조 인덱스는 보통 밀집 인덱스이다. 따라서 같은 수의 레코드들을 접근할 때 보조 인덱스를 통하면, 기본 인덱스보다 디스크 접근 횟수가 증가할 수 있다. 

       entry가 더 많아짐.

   - 희소 인덱스와 밀집 인덱스 비교

     - 희소 인덱스는 각 데이터 블록마다 한 개의 엔트리를 갖는다.

       밀집 인덱스는 각 레코드마다 한 개의 엔트리를 갖는다.

     - 레코드의 길이가 블록 크기보다 훨씬 작은 일반적인 경우에는, 희소 인덱스의 엔트리 수가 밀집 인덱스의 엔트리 수보다 훨씬 적다. 

     - 희소 인덱스는 일반적으로 밀집 인덱스에 비해 인덱스 단계 수가 1 정도 적다. 따라서 인덱스 탐색 시 디스크 접근 수가 1만큼 적을 수 있다. 

     - 희소 인덱스는 밀집 인덱스에 비해 모든 갱신과 대부분의 질의에 대해 더 효율적이고 성능이 좋다.

       하지만 질의에서 인덱스가 정의된 애트리뷰트만 검색하는 경우에는 (COUNT 질의 등), 데이터 파일을 접근할 필요 없이 인덱스만 접근해서 질의를 수행할 수 있기 때문에 밀집 인덱스가 더 유리하다.

     - 한 파일은 한 개의 희소 인덱스와 여러 개의 밀집 인덱스를 가질 수 있다. 

   - 클러스터링 인덱스와 보조 인덱스의 비교

     - 클러스터링 인덱스는 희소 인덱스일 경우가 많고, 범위를 질의할 때 좋다.
     - 보조 인덱스는 밀집 인덱스이므로, 일부 질의에 대해서는 파일을 접근할 필요 없이 처리할 수 있다.

   - 다단계 인덱스

     - 인덱스 자체가 클 경우에는 인덱스를 탐색하는 시간도 오래 걸릴 수 있다.

     - 인덱스 엔트리를 탐색하는 시간을 줄이기 위해서 단일 단계 인덱스를 디스크 상의 하나의 순서 파일로 간주하고, 단일 단계 인덱스에 대해서 다시 인덱스를 정의할 수 있다.

     - 다단계 인덱스는 가장 상위 단계의 모든 인덱스 엔트리들이 한 블록에 들어갈 수 있을 때까지 이런 과정을 반복한다.

     - 가장 상위 단계 인덱스를 마스터 인덱스라고 부른다. 단계의 개수는 제한이 딱히 없음

       마스터 인덱스는 한 블록으로 이루어지므로 주기억장치에 상주할 수 있다. 버퍼를 금방 비우지 말고 올려놓음

     - 대부분의 다단계 인덱스는 B+ tree를 사용한다. 
     
       > de facto 느낌. 세계적으로 걍 이거 쓰자 함
       >
       > B+ - tree는 꼭 알아야 함니더
     
     - B+ tree
     
       → Balanced (root에서 leaf까지 깊이가 균형 잡힌 것을 보장)
     
       → 모든 node들이 갖는 child의 개수를 일정하게 유지해준다.
     
     ![image](https://user-images.githubusercontent.com/41130448/121208628-2b898280-c8b5-11eb-8386-0f856aebf64a.png)
     
     - 이거슨 B+ tree 아니고 그냥 다단계 인덱스. 목차의 목차의 목차 느낌
     
       값에 대해 sorting이 반드시 되어 있어야 한다잉
     
       특정 키 값의 검색이 빠르게 가능
     
     - 레코드 삽입/삭제 시 인덱스를 전체 다 재점검해야 할 수도 있음
     
       **index maintenance overhead**라고 한다. 모든 것은 다 trade off임
     
       이걸 항상 감안해야 함. 모든 attribute에 대해서 다 인덱스를 만들 수 없음
     
       인덱스를 만드는 것이 좋은지 아닌지 항상 고민해야 한다
     
     - 1. tree는 root에서 leaf 노드까지의 길이가 다를 수 있음.
     
          skewed tree의 경우 편향된 형태의 트리가 생성될 수 있다.
     
       2. child의 개수도 다를 수 있다.
     
          그러면 전체적인 효율성이 떨어짐
     
   - SQL의 인덱스 정의문

     - `CREATE TABLE`문에서 `PRIMARY KEY`절로 명시하면 해당 애트리뷰트에 대해서 DBMS가 자동으로 기본 인덱스 생성

     - `UNIQUE`로 명시한 애트리뷰트에 대해서는 DBMS가 자동으로 보조 인덱스 생성

     - SQL2는 인덱스 정의 및 제거에 관한 표준 SQL문을 제공하지 않는다.

     - 다른 애트리뷰트에 추가적으로 인덱스를 정의하기 위해서는 DBMS마다 각자 구문에 맞춰서 `CREATE INDEX`문을 사용한다. 

       ```sql
       CREATE INDEX EmpIndex ON EMPLOYEE (DNO, SALARY);
       # 두개 이상의 애트리뷰트를 묶어서 인덱스를 만들 수 있다.
       ```

       인덱스의 활용 예

       ```SQL
       # 아래와 같은 쿼리에 할용 가능 (실제 수행해보면 쥰내 빨라진다.)
       SELECT *
       FROM EMPLOYEE
       WHERE DNO = 3 AND SALARY = 4000000;
       # RANGE QUERY에도 활용하기 좋음
       SELECT *
       FROM EMPLOYEE
       WHERE DNO >= 2 AND DNO <= 3 
       	AND SALARY >= 3000000 AND SALARY <= 4000000;
       # 여기에도 사용 가능
       SELECT *
       FROM EMPLOYEE
       WHERE DNO = 2; # 혹은 DNO에 대한 범위 질의
       ```

       이런 질의에는 위의 인덱스를 활용할 수 없다.

       ```sql
       SELECT *
       FROM EMPLOYEE
       WHERE SALARY >= 3000000 AND SALARY <= 4000000; # 혹은 SALARY에 대한 동등 조건
       ```

       `DNO`에 대한 조건이 없음. 이 경우에는 사용 불가

     - 인덱스의 사용 여부는 DBMS가 결정한다. 써서 빠르겠다 싶으면 쓰는 것. 

       쿼리 처리 후 인덱스 사용 여부는 확인할 수 있음

   - 인덱스의 장점과 단점

     - 검색 속도를 향상

       저장하기 위한 공간이 추가로 필요함, 삽입/삭제/수정의 연산 속도 저하

     - 소수의 레코드 수정/삭제하는 연산의 속도는 향상

     - 릴레이션이 매우 크고, 질의에서 튜플들 중에 일부(예를 들어 2~4%)를 검색하는 경우, `WHERE`절이 잘 표현되는 경우 특히 성능에 도움이 된다. 

   - 인덱스 선정 지침과 데이터베이스 튜닝

     - 다음과 같은 것들에 대해서 바람직한 성능을 고려해서 인덱스를 선정한다.

       1. 가장 중요한 질의와 이들의 수행 빈도
       2. 가장 중요한 갱신과 이들의 수행 빈도

     - Workload 내의 각 질의에 대해서, 해당 질의가

       1. 어떤 릴레이션을 접근하는지
       2. 어떤 애트리뷰트들을 검색하는지
       3. `WHERE`절의 선택/조인 조건에 어떤 애트리뷰트가 포함되는지
       4. 이 조건들의 선별력은 얼마인지

       등을 고려한다.

     - Workload 내의 각 갱신에 대해서, 해당 갱신이

       1. 어떤 릴레이션들을 접근하는지
       2. `WHERE`절의 선택/조인 조건에 대해 어떤 애트리뷰트가 포함되는지
       3. 이 조건들의 선별력은 얼마인지
       4. 갱신의 유형(`INSERT/DELETE/UPDATE`)
       5. 갱신의 영향을 받는 애트리뷰트

       등을 고려한다.

     - Workload란 어떠한 작업을 얼마나 하느냐를 통틀어서 본 것

     - 선별력이란 Selectivity 이 조건을 만족하는 튜플들이 몇%인지를 의미한다.

       그 애트리뷰트의 cardinality와 관련이 있다. 

     > 예) 우리나라 이름에서 성의 selectivity는 굉장히 낮다. 

     - 그 외에 고려할 것
       1. 어떤 릴레이션에 인덱스를 생성할지
       2. 어떤 애트리뷰트를 탐색 키로 선정할지
       3. 몇 개의 인덱스를 생성할지
       4. 각 인덱스에 대해 클러스터링/밀집/희소 인덱스 중 어느 유형을 선택할지
     - 물리적 데이터베이스 설계는 끊임없이 이루어지는 작업이다.

   - 인덱스 선정에 참고할 지침

     1. 기본 키는 클러스터링 인덱스를 정의할 훌륭한 후보이다.

     2. 외래 키도 인덱스를 정의할 훌륭한 후보이다.

     3. 한 애트리뷰트에 들어 있는 값들이 거의 서로 다르고, 그 애트리뷰트가 동등 조건에 사용된다면 비 클러스터링 인덱스를 생성하는 것이 좋다.

     4. 튜플이 많이 들어 있는 릴레이션 내에서 행해지는 검색 질의의 대부분이 2%~4% 미만의 튜플이라면 인덱스를 생성

     5. 자주 갱신되는 *애트리뷰트*에는 인덱스를 정의하지 않는 것이 좋다.

     6. 갱신이 빈번하게 이루어지는 *릴레이션*에는 인덱스를 많이 만드는 것을 피한다.

        (static, dynamic relation에 따라 구분)

     7. 후보 키는 기본 키가 갖는 모든 특성을 함께 갖기 때문에 인덱스를 생성할 훕이다.

     8. 인덱스는 파일의 레코드들을 충분히 분할할 수 있어야 한다.

     9. 정수형 애트리뷰트에 인덱스를 생성하는 것이 좋다. (실수형에는 부적절)

     10. `VARCHAR` 애트리뷰트에는 인덱스를 만들지 말자 (값이 크면 공간을 너무 많이 차지함)

     11. 작은 파일에는 인덱스를 만들 필요가 없다.

     12. 대량의 데이터(bulk data)를 삽입할 때는 모든 인덱스를 제거하고, 데이터 삽입이 끝난 후에 인덱스를 다시 생성하는 것이 좋다. (좋은 가이드라인인듯)

     13. `ORDER BY`절, `GROUP BY`절에 자주 사용되는 애트리뷰트는 인덱스를 정의할 후보이다. (이 두 연산은 오버헤드가 제일 큰 연산 중에 하나임)

   - 인덱스가 사용되지 않는 경우 

     - 시스템 카탈로그가 오래 전의 데이터베이스 상태를 나타낼 때

       > 카탈로그 : db 시스템의 상황을 기록하는 메타 데이터 
       >
       > 대부분의 시스템은 메타 데이터 업데이트를 real-time으로 하지 않는다. 
       >
       > delay를 두고 주기적으로 실행함 
       >
       > 따라서 인덱스를 만들었는데도 그 메타 데이터에 바로 반영이 안되었을 수 있음
       >
       > 그럼 사용 못하는거임. DBMS가 인덱스 만들어졌는지 모르기 때문에 못쓴다.

     - DBMS의 질의 최적화 모듈이, 릴레이션의 크기가 작아서 인덱스가 필요 없다고 판단하는 경우

     - 인덱스가 정의된 애트리뷰트에 산술 연산자가 사용되는 경우 (오!!!헐)

       ```sql
       SELECT *
       FROM EMPLOYEE
       WHERE SALARY * 12 > 4000000;
       ```

     - DBMS가 제공하는 내장 함수가 집단 함수 대신 사용되는 경우

       ```sql
       SELECT *
       FROM EMPLOYEE
       WHERE SUBSTRING(EMPNAME, 1, 1) = '김';
       ```

     - 널 값에 대해서는 인덱스 사용하지 않음

       ```sql
       SELECT *
       FROM EMPLOYEE
       WHERE MANAGER IS NULL;
       ```

   - 질의 튜닝을 위한 추가 지침

     1. `DISTINCT`절의 사용을 최소화하라

        > 시간이 많이 걸리므로 꼭 필요한 거 아니면 쓰지 마셈

     2. `GROUP BY`절과 `HAVING`절의 사용을 최소화하라

     3. 임시 릴레이션의 사용을 피하라

        > 복잡한 쿼리 하나 대신 임시 테이블을 만들어서 쓸 수 있지만, 가능하면 하지 말어라

     4. `SELECT *` 대신 `SELECT` 절에 애트리뷰트 이름을 구체적으로 명시하라 

4. hash file

<br>

### B+ TREE

- 최대 child의 개수는 key 값의 크기에 따라서 달라진다. 노드 자체가 디스크의 block 하나를 뜻함

  ![image](https://user-images.githubusercontent.com/41130448/121215528-10217600-c8bb-11eb-875c-9caf8aea7acf.png)

  얘는 최대 child 수가 4개인 B+ tree

- 통상 50% 이상의 fill factor를 가지고 있음 

  노드 하나 안에서 50% 이상은 채워야 함

  수정/삭제 시 매번 이 채우는 정도를 유지시킴

- `INSERTION` 수행하는 경우

  1. 사이에 쏙 넣음

     ![image](https://user-images.githubusercontent.com/41130448/121215755-3fd07e00-c8bb-11eb-9f4c-a0994a9ffa74.png)

  2. leaf가 꽉 찬 경우 → split (propagation)

     ![image](https://user-images.githubusercontent.com/41130448/121215882-5bd41f80-c8bb-11eb-9907-6343d78fb17f.png)

     leaf를 둘로 쪼갠 후 새로 넣는다.

     여기서는 50에 있는 애를 쪼개서 70을 오른쪽에 넣는다.

     ![image](https://user-images.githubusercontent.com/41130448/121216081-8920cd80-c8bb-11eb-819f-3d4bee62f781.png)

     여기서 95를 또 넣는 경우에 또 꽉차있음

     ![image](https://user-images.githubusercontent.com/41130448/121216233-ac4b7d00-c8bb-11eb-8431-6ed8b9b5d25b.png)

     75짜리를 또 반띵해서 95를 오른쪽에 넣는다. 근데 인덱스 노드가 꽉참

     인덱스를 반띵한다.

     ![image](https://user-images.githubusercontent.com/41130448/121216536-ef0d5500-c8bb-11eb-9657-94add416ca9d.png)

     ![image](https://user-images.githubusercontent.com/41130448/121216570-faf91700-c8bb-11eb-8959-cc64e077a70d.png)

     암튼 leaf 노드의 깊이는 다 똑같아진다 이말이야 *밸런-쓰*

<br>

## 릴레이션 정규화

- 정규화는 정규형(Normal form)을 만드는 것

- 함수 종속성을 알고 분해해주어야 relation 설계가 끝나는 것임

- 때로는 융통성있게 역정규화도 할 줄 알아야 한다.

  어떤 때 필요한지 살펴보자.

### 정규화 개요

- 데이터베이스 설계를 부주의하게 설게하면 데이터 중복이 커져서 여러 가지 갱신 이상을 발생시킨다. (update anomaly)

- 좋은 데이터베이스 설계를 위해서 생각할 것

  어떤 릴레이션들을 생성할 것인가?

  각 릴레이션에 어떤 애트리뷰트를 둘 것 인가?

- 좋은 RDB 스키마를 설계하는 목적

  - 정보의 중복과 갱신 이상 생기지 않도록 함
  - 정보의 손실을 막는다
  - 실세게를 훌륭하게 나타낸다.
  - 애트리뷰트들 간의 관계를 잘 표현
  - 무결성 제약 조건의 시행을 간단하게 한다.
  - 효율성도 높이도록

- 우선순위

  갱신 이상 → 효율성

- 정규화는 릴레이션 스키마를 함수적 종속성과 기본 키를 기반으로 분석한다. 이를 원래의 릴레이션으로 분해한다.

  → 중복, 갱신이상 3가지(수정, 삽입, 삭제)를 최소화

  > 정보의 중복은 저장 공간을 낭비한다. 
  >
  > 변경 시 일부 중복된 튜플에 적용하는 것을 빼먹으면 불일치 문제가 발생한다. 중복을 방지하기 위해 딱 한 곳에서만 변경하면 되도록 하는 게 좋음

- 갱신 이상

  1. 수정 이상(modification anomaly)

     반복된 데이터 중에 일부만 수정하면, 데이터의 불일치가 발생(inconsistency)

  2. 삽입 이상(insertion anomaly)

     불필요한 정보를 함께 저장하지 않고는 어떤 정보를 저장하는 것이 불가능

     어떤 정보를 넣기 위해서는 부수적으로 다른 정보도 함께 넣어야만 삽입이 가능한 것

  3. 삭제 이상(deletion anomaly)

     유용한 정보를 함께 삭제하지 않고는 어떤 정보를 삭제하는 것이 불가능

     특정 정보를 삭제할 때 다른 정보까지 의도하지 않았지만 딸려서 삭제되는 것

- 릴레이션의 분해 (Decompose)

  - 하나의 릴레이션을 두 개 이상의 릴레이션으로 나누는 것이다.
  - 갱신 이상을 해결하는 방법이다
  - 릴레이션을 분해할 때에는, 분해된 릴레이션으로부터 원래의 릴레이션을 다시 구할 수 있음을 보장해야 한다.
  - 분해를 잘못하면 분해된 두 릴레이션으로부터 얻을 수 있는 정보가 원래의 릴레이션이 나타내던 정보보다 적거나 많다.
  - 릴레이션에 존재하는 함수적 종속성에 관한 지식을 기반으로 분해한다. 

- 정규형의 종류

  일반적으로 산업게에서 설계할 때에는 BCNF까지 고려함, 굳이 이 이상으로는 알 필요는 읎다.

  1. 제1정규형
  2. 제2정규형
  3. 제3정규형
  4. BCNF(Boyce-Codd normal form)
  5. 제4정규형
  6. 제5정규형

- RDB 설계 시 비공식적인 지침

  1. 이해하기 쉽고 명확한 스키마를 만들자.

     여러 엔티티 타입이나 관계 타입에 속한 애트리뷰트를 하나의 릴레이션에 포함 ㄴㄴ

  2. 널값을 피하자

  3. 가짜 튜플이 생기지 않도록 하자

     가짜 튜플은 실제 발생할 수 없는 튜플을 의미함

  4. 스키마를 정제하자

     다듬고 최적화하자.

<br>

### 함수적 종속성

- 함수적 종속성은 정규화 이론의 핵심이다.

- 릴레이션의 애트리뷰트들의 의미에서 결정된다.

- 릴레이션 스키마 자체에 대한 것이며, 특정 인스턴스에 대한 것이 아님

  릴레이션의 가능한 모든 인스턴스들이 만족해야 한다.

- 실세계에 대한 지식과 응용의 의미를 기반으로 어떤 함수적 종속성들이 존재하는지 파악해야 한다.

- 함수적 종속성은 제2정규형부터 BCNF까지 적용된다. 

- 결정자 (Determinant)

  - 어떤 애트리뷰트의 값은 다른 애트리뷰트의 값을 고유하게 결정, 그렇게 고유하게 결정시키는 하나 이상의 애트리뷰트가 결정자이다.

    > 사원 번호 → 사원 이름 (고유히 결정 O)
    >
    > 주소 → 사원 이름 (고유히 결정 X)
    >
    > 부서 번호 → 부서 이름 (고유히 결정 O)

  - "A가 B를 결정한다", "A는 B의 결정자이다", "B가 A에 함수적으로 종속한다"를 다음과 같이 표현한다.

    A → B

    > A쪽에 집합이 올 수도 있음

    주어진 릴레이션 R내에서 각 A 값에 대해 반드시 한 개의 B가 대응되어야 한다.

    > 걍 함수같네 함수도 정의역 내의 특정 값에 대해서 반드시 하나의 값만 나와야지 함수라고 하는디 

- 완전 함수적 종속성 (FFD: Full Functional Dependency)

  - 릴레이션 R, 복합(set) 애트리뷰트 A, 그냥 애트리뷰트 B

    주어진 R에서 B가 A에 함수적으로 종속하면서, A의 어떠한 진부분 집합(부분 집합 아무거나)에도 함수적으로 종속하지 않으면

    → B가 A에 완전하게 함수적으로 종속한다

    ![image](https://user-images.githubusercontent.com/41130448/121147393-cbc2b580-c87b-11eb-966b-004fc50fdb1a.png)

    fd3는 완전 함수적 종속성을 가짐

    fd1, fd2는 부분 함수적 종속성을 가짐 

    > 직책은 사원번호 + 부서번호로 인해 결정됨
    >
    > 이 회사는 한 사원이 여러 부서에 속할 수 있는 부서라서 그럼 

    부분 함수적 종속성을 없애기 위해서 분해해야 깔끔

- 이행적 함수적 종속성 (transitive FD)

  - 릴레이션 R, 애트리뷰트 A, B, C에서

    "C가 이행적으로 A에 종속한다"는

    A→B ∧ B→C 가 성립하는 것이다. 

  - A가 릴레이션의 PK라면 키의 정의에 따라서 A→B, A→C가 성립한다.

    만약에 C가 A 외에 B에도 함수적으로 종속한다면 C는 A에 직접 합수적으로 종속하면서 B를 거쳐서 A에 이행적으로 종속

  ![image](https://user-images.githubusercontent.com/41130448/121148245-91a5e380-c87c-11eb-9782-53f817db666f.png)

<br>

### 릴레이션 분해

- 하나의 릴레이션을 두 개 이상의 릴레이션으로 나누는 것

- 장점 : 중복이 감소되고, 갱신 이상이 줄어든다.

  단점 : 잠재적인 문제를 야기할 수 있음

  > 조인이 필요 없는 질의였다가, 분해한 후에는 조인이 필요하도록 변화. 성능이 감소할 수도 있다.
  >
  > 분해된 릴레이션으로 기존의 릴레이션을 재구성하지 못할 수도 있다.

  > 공학은 현재 시점에서 어떤 것이 최선인지 trade off를 고려해서 적절히 선택하는 것.
  >
  > 비용과 서비스 품질을 잘 고려하자

- 무손실 분해 (lossless decomposition)

  - 여기서 말하는 손실이란 정보의 손실이다.

    분해된 릴레이션 조인 시 원래의 릴레이션에 있던 정보보다 적거나 많은 것을 모두 포함한다. 

  - 분해된 두 릴레이션을 조인하면 원래의 릴레이션에 있던 정보를 완전히 얻을 수 있게 분해하는 것.

  ![image](https://user-images.githubusercontent.com/41130448/121149245-75567680-c87d-11eb-840e-29c5a75de626.png)

  잘한 것

  ![image](https://user-images.githubusercontent.com/41130448/121149300-81423880-c87d-11eb-941f-76de58e5c470.png)

  무손실 분해지만 쓸데 없는 분해

  binary relation(attribute가 2개인 것)으로 모든 정보를 표현하면 중복을 제일 최소화 할 수 있다. 하지만 그만큼 조인 해야 하므로 항상 권장되는 것은 XXX

  ![image](https://user-images.githubusercontent.com/41130448/121149489-aa62c900-c87d-11eb-9142-3f6f6ad58643.png)

  과목과 학점이 합쳐져야지 의미 있는 정보임. 이걸 부시면 안됨. 합쳤을 때 말이 안되는 정보 (가짜  튜플)이 생성된다.

<br>

### 제 1 정규형

- 릴레이션 R의 모든 애트리뷰트가 원자값만을 갖는다는 것이다.
- 모든 애트리뷰트에 반복 그룹(repeating group)이 나타나지 않으면 제 1정규형을 만족함

![image](https://user-images.githubusercontent.com/41130448/121149790-eb5add80-c87d-11eb-836c-750a5e616cbf.png)

표현하기에는 좋지만 반복 그룹(집합값)이 존재함 (객체 관계 모델에서는 이걸 할 수 있다는듯?)

집합값이 들어갈 수 있으면 자연스럽게 설계할 수 있음. 하지만 디비에는 그렇게 표현 안됨.

nested relation으로 표현한다링

![image](https://user-images.githubusercontent.com/41130448/121149844-f9106300-c87d-11eb-875a-6661f002187a.png)

제1 정규형을 만족하지만 중복 정보가 많음  

- 제 1정규형만 만족 시 발생할 수 있는 문제

  예시) 릴레이션 내에 학생, 학과, 학과의 전화번호가 존재

  ![image](https://user-images.githubusercontent.com/41130448/121170794-a55b4500-c890-11eb-8869-74f8d15eb161.png)

  1. 수정 이상

     특정 카테고리에 속한 원소(특정 학과의 연결 전화번호)가 변경되었을 때 이 원소를 갖고 있는 모든 튜플(해당 학과에 속한 학생 튜플)을 모두 변경시켜야 한다.

  2. 삽입 이상

     특정 정보가 없으면 새로운 튜플을 넣을 수 없다.

     (새로운 학과를 신설할 수 없다, 소속되어 있는 학생이 없으므로)

  3. 삭제 이상

     특정 정보를 삭제 시 의도하지 않은 다른 정보까지 함께 삭제

     (어떤 학과에 소속된 마지막 학생 튜플을 삭제하면 이 학생이 소속된 학과 정보도 함께 삭제)

<br>

### 제 2 정규형

- 릴레이션 R이 제1정규형을 만족하면서, 어떤 후보 키에도 속하지 않는 모든 애트리뷰트들이 R의 **기본 키에 완전하게 함수적으로 종속**하는 것

- 기본 키가 두 개 이상의 애트리뷰트로 구성되었을 경우에만 제1정규형이 제2정규형을 만족하는가를 고려할 필요가 있다. 

  ![image](https://user-images.githubusercontent.com/41130448/121175547-236e1a80-c896-11eb-972e-b77bf20270f9.png)

- 제2 정규형에 존재하는 이상

  1. 수정 이상

     여러 학생이 소속된 학과의 전화번호가 변경되었을 때 그 학과에 속한 모든 학생들의 튜플에서 전화번호 수정해야 함

  2. 삽입 이상

     학과 신설 시 소속 학생이 없으면 정보 입력 불가. 학번이 PK이기 때문에 무결성 제약 조건에 따라서 널값을 입력할 수 없음

  3. 삭제 이상

     어떤 학과에서 마지막 학생의 튜플 삭제 시 그 학과의 전화번호도 함께 삭제

- 갱신 이상이 생기는 이유

  이행적 종속성이 존재하기 때문 

  학과 전화번호는 학과 이름에도 종속됨

<br>

### 제 3정규형

- 릴레이션 R이 제2정규형을 만족시키면서, 키가 아닌 모든 애트리뷰트가 R의 기본 키에 이행적으로 종속하지 않는 것

- 제 3정규형에 존재하는 갱신 이상

  ![image](https://user-images.githubusercontent.com/41130448/121203633-393d0900-c8b1-11eb-973e-83d8555d8da2.png)

  강사가 결정되면 과목이 결정됨

  1. 수정 이상

     여러 학생이 수강 중인 어떤 과목의 강사가 변경되었을 때 그 과목을 수강하는 모든 학생들의 튜플에서 강사를 다 수정해야 함. (data consistency)

  2. 삽입 이상

     어떤 과목을 신설할 때 아직 수강생이 없으면, (학번이 PK이므로) 어떤 강사가 그 과목을 가르친다는 정보 입력 불가능

  3. 삭제 이상

     어떤 과목의 수강생이 1명일 때, 이 학생의 튜플 삭제 시 그 과목의 강사에 대한 정보도 삭제됨

- 갱신 이상이 생기는 이유

  - 키가 아닌 애트리뷰트가 다른 애트리뷰트를 결정함

  > 모든 애트리뷰트에서 결정자는 꼭 기본키, 혹은 후보 키가 되어야 한다. 

<br>

### BCNF

- 릴레이션 R이 제 3정규형을 만족하고, 모든 결정자가 후보 키어야 한다.

- 제 3정규형을 만족하는 릴레이션은 대부분 BCNF를 만족한다.

- 하나의 후보 키만을 가진 릴레이션이 제3정규형을 만족하면 동시에 BCNF도 만족한다.

- 제 3정규형을 만족하는 릴레이션을 BCNF로 정규화하기 위해서는, 키가 아니면서 결정자 역할을 하는 애트리뷰트(갱신 이상을 발생시키는 녀석)와 그 결정자에 함수적으로 종속하는 애트리뷰트를 하나의 테이블에 넣는다.

  이 릴레이션(테이블)에서 결정자 역할을 하던 녀석은 곧 기본 키가 된다.

  기존 릴레이션에는 결정자를 남겨서 기본 키의 구성 요소가 되도록 한다. 동시에 이 결정자는 새로운 릴레이션에 대한 외래키 역할도 한다. 

  ![image](https://user-images.githubusercontent.com/41130448/121205130-5e7e4700-c8b2-11eb-91a1-2ed157405191.png)

- 하지만 릴레이션이 너무 많아지면 그것도 문제다.

![image](https://user-images.githubusercontent.com/41130448/121205259-78b82500-c8b2-11eb-9ac8-fbc5ccf51e5f.png)

<br>

### 역정규화

- 정규화 단계가 진행될수록 

  1. 중복과 갱신 이상도 감소된다.
  2. 무결성 제약 조건을 시행하기 위해 필요한 코드의 양도 감소된다.
  3. 하나의 릴레이션이 최소한 두 개의 릴레이션으로 분해된다.

- 정규화가 DB 설계의 중요한 요소이지만, 성능상의 관점에서만 보았을 때 높은 정규형을 만족한다고 항상 그 스키마가 최적인 것은 아니다.

- 릴레이션을 분해하면서 같은 정보를 얻기 위해 조인 연산의 필요성이 증가한다.

  요구 사항에 따라서 일부분을 역정규화 함으로써 데이터 중복 및 갱신 이상을 대가로 성능을 만족시킬 수 있다.

- 많은 DB 응용에서 검색 질의의 비율이 갱신 질의의 비율보다 훨씬 높다.

  역정규화는 자주 수행되는 검색 질의의 수행 속도를 높이기 위해서 이미 분해된 두 개 이상의 릴레이션들을 합쳐서 하나의 릴레이션으로 만드는 작업이다.

- 즉, 보다 낮은 정규형으로 돌아가는 것

> 자바는 바이트 코드이므로 리버스 엔지니어링이 쉽다
> 역정규화는 DB에 대해서 적용하는 리버스 엔지니어링 같은 것

<br>

## 뷰와 시스템 카탈로그

36:32부터
