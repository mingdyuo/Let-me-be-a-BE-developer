## Chapter 1 C++에 왔으면 C++의 법에 따릅시다.

### 항목 0 용어 설명

- 암시적 타입 변환에 생성자가 사용될 여지를 남겨둬야 할 필요성이 있지 않으면 가능한 `explicit` 으로 선언하자.

### 항목 1 C++를 언어의 연합체로 바라보는 안목은 필수

C++을 다음 4가지 항목의 연합체로 보자.

1. C

   아무튼 C++의 기본은 C에 있다.

2. 객체 지향 개념의 C++

3. 템플릿 C++

   TMP가 나온 배경이 되는 기능. 근데 주류로 쓰지는 않나보다.

4. STL

   컨테이너, 반복자, 알고리즘, 함수 객체가 얽혀 있다.

C++을 사용해서 잘 프로그래밍 하려면 어떤 규칙을 적용해야 할까? 그건 위의 4가지 항목 중 어떤 부분을 사용하느냐에 따라 달라진다!

예를 들어서 값/객체를 넘길때 C style에서는 값 전달이, 객체 지향 C++에서는 상수 객체 참조자 전달이, 템플릿에서는 어떤 객체인지도 알 수 없으므로 특히 상수 객체 참조자 전달이, STL에서는 포인터를 본떠 만든 반복자와 값 전달이 좋다.

### 항목 2 `#define`을 쓰려거든 `const`, `enum`, `inline`을 떠올리자.

- 핵심은 **선행 처리자**보다 **컴파일러**를 더 가까이 하자는 것이다.

- `#define`은 컴파일러에게 넘어가기 전에 밀려버리고 다른 값으로 대체된다. 컴파일러의 기호 테이블에도 들어가지 않는다.

- `const` 상수는 여러 번 쓰이더라도 사본은 한개만 생긴다.

- `#define`을 `const` 상수로 바꿀 때 이 점은 주의하자.

  1. 상수 포인터를 정의하는 경우

     포인터는 꼭 `const`로 선언해 주어야 한다.

     보통 포인터가 가리키는 대상까지 `const`로 선언해준다.

     예를 들면

     ```c++
     const char* const authorName = "Justin Bieber";
     ```

     문자열 상수를 쓸 때에는 `string` 객체를 사용하는 것이 더 좋다.

     ```c++
     const std::string authorName("Justin Bieber");
     ```

  2. 클래스 멤버로 상수를 정의하는 경우

     해당 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 `static`으로 선언하자.

     헤더 파일에 선언하고 구현 파일에 정의한다.

     구식 컴파일러의 경우, 클래스 컴파일 시 클래스 상수가 필요한 경우에는 열거형을 쓸 수 있다. (`enum hack`이라고 부른다. 그만큼 꼼수라는거지~ )

     ```c++
     class ExampleClass {
     private:
     	enum { TestNum = 5 };
     }
     ```

- 매크로 함수 노노 인라인 함수 예스예스

- `enum`은 메모리 할당 안함. `#define`은 하는가본데??? 모지 

### 항목 3 낌새만 보이면 `const`를 들이대 보자!

- `const`를 쓸 수 있는 범위는 다양하다.

  1. 클래스 밖에서 전역/네임스페이스 유효범위의 상수를 선언/정의 할 수 있음

  2. 파일, 함수, 블록 유효 범위에서 `static`으로 선언한 객체에도 `const`를 붙일 수 있다.

  3. 클래수 내부의 정적, 비정적 데이터 멤버를 모두 상수로 선언할 수 있다.

  4. 포인터 자체 / 포인터가 가르키는 데이터를 상수로 선언할 수 있다.

     ```c++
     void f1(const Widget *pw);
     void f1(Widget const *pw);
     ```

     이 둘은 같은 매개변수 타입을 갖는다. `*`포인터의 왼쪽에 있으면 상수 포인터

- 반복자에 `const` 쓰기

  `const iterator`는 `iterator`가 가르키는 대상의 값은 변경 가능하나 가르키는 대상은 변경할 수 없다.

  ```c++
  const std::vector<int>::iterator iter = vec.begin(); // T* const 처럼 동작
  *iter = 10; 	// 가능
  ++iter; 		// 불가능
  ```

  `container::const_iterator`는 가르키는 대상의 값을 변경할 수 없으나, 가르키는 대상은 변경할 수 있다.

  ```c++
  std::vector<int>::const_iterator iter = vec.begin(); // const T* 처럼 동작
  *iter = 10;		// 불가능
  ++iter;			// 가능
  ```

- 함수 반환 값에 `const` 쓰기

  안전성이나 효율을 포기하지 않고 사용자측의 에러 및 돌발상황을 예방할 수 있다.

  ```c++
  // 곱하기 함수
  const Rational operator*(const Rational& lhs, const Rational& rhs);
  ```

  반환값이 상수 객체일 이유가 있을까? 

  만약 반환값이 상수 객체가 아니라면 아래의 실수들을 저질렀을 때 쉽게 잡을 수 없다.

  ```c++
  // 1
  Rational a, b, c;
  (a * b) = c; 		// 띠용
  // 2
  if (a * b = c)		// 띠용2 (원래 비교 구문이 의도)
  ```

  가능한 항상 `const`를 사용하자.

- 상수 **멤버 함수**

  - 왜 중요한가?

    1. 클래스의 인터페이스를 이해하기 좋게 해줌

       객체를 변경할 수 있는 함수 / 변경할 수 없는 함수 파악

    2. 이 키워드를 통해 상수 객체를 사용할 수 있도록 해줌

  - `const`키워드가 있고/없고의 차이가 있는 함수들도 오버로딩이 가능하다 !

    (`const` 함수는 `const` 객체를 사용할 때 호출, 비상수는 비상수 객체 사용 시 호출)

### 항목 4 객체를 사용하기 전에 반드시 그 객체를 초기화하자



## Chatper 2 생성자, 소멸자 및 대입 연산자

### 항목 7 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자.



## Chatper 3 자원 관리

- 자원이란 사용을 마치고 난 후에 시스템에 돌려줘야 하는 모든 것

  → 메모리, `file descriptor`, `mutex lock`, `font`, `brush` (GUI)

- 생성자, 소멸자, 객체 복사 함수를 사용해서 객체 기반의 자원 관리를 해보자.

### 항목 13 자원 관리에는 객체가 그만!

- RAII에 대해, 그리고 `auto_ptr`과 `shared_ptr`에 대해 설명하는 장이다.
- `auto_ptr`은 현재 deprecated 되었고, `shared_ptr`은 여기서 자세하게 다루지 않으니 그렇구나 하고 넘어가자.
- 동적 할당한 배열에 대해서는 `auto_ptr`과 `shared_ptr`을 사용할 수 없다고 하는데, 이것도 알아보자.

<br>

## Chatper 4 설계 및 선언

### 항목 20 '값에 의한 전달'보다는 '상수 객체 참조자에 의한 전달 방식이 대개 낫다.

- 복사 손실(slicing problem) 

  - 파생 클래스 객체가 전달될 때 기본 클래스 객체로 전달되는 경우. 가끔 일어난다.

  - 이게 일어나면 파생 클래스 객체로 동작하는 특징들이 잘려 나간다. 그래서 slicing problem

  - `const reference`로 매개변수를 넘기면 이 문제를 걱정하지 않아도 된다.

  - 예)

    A 클래스를 상속받은 클래스 B가 있다. A에는 가상함수 `a()`가 있으며, B에도 구현되어 있다. 

    이 때 A를 값의 의한 전달로 받는 함수에 B로 만든 객체를 넣으면 생성자 A만 호출되고 B의 특성을 갖는 영역은 사라진다. `B::a()`는 사용하지 못한다.

    이 때 A를 const reference로 받는 함수에 B로 만든 객체를 넣으면 `B::a()`가 잘리지 않는다.

- 레퍼런스는 내부에서 포인터를 써서 구현된다.

  레퍼런스를 전달한다는 것은 결국 포인터를 전달하는 것과 일맥상통하다.

- 전달하는 객체의 타입이 `int`와 같이 built-in인 경우에는 값으로 넘기는 편이 대체로 더 효율적이다.

  1. **단순히 타입 크기가 작은 경우를 의미하는 것이 아니다.** 작더라도 user-defined 객체라면 복사하는 비용이 클 수 있다. 

     컴파일러 중에는 built-in과 user-defined 타입을 아예 다르게 취급하는 것도 있다. 

  2. 또한 user-defined 타입은 언제든 크기가 변할 수 있으므로 call by value로 사용하는 것은 권장되지 않을 것이다.

- STL의 `iterator`와 `functor`는 call by value로 설계되어 있다.

- 다음 3가지 타입은 call by value를 사용해도 저비용이라고 여겨질 수 있는 것들이다. 이외는 가능하면 상수 레퍼런스를 사용하자.

  1. built-in type
  2. STL iterator
  3. 함수 객체

<br>

## Chatper 5 구현

### 항목 27 캐스팅은 절약, 또 절약! 잊지 말자

- C++ 스타일 캐스트

  1. `const_cast`

     객체의 상수성을 없애는 용도로 사용. 이 캐스트만 `const` 떼버릴 수 있다.

  2. `dynamic_cast`

     안전한 다운캐스팅을 할 때 사용.

     주어진 객체가 어떤 클래스 상속 계통에 속한 특정 타입인지 아닌지 결정

     런타임 비용이 꽤나 높으므로 남발 ㄴㄴ

  3. `reinterpret_cast`

     포인터를 `int`로 바꾸는 등의 하부 수준 캐스팅

     적용 결과는 구현 환경에 의존적이고 하부 수준 코드 아니면 잘 쓰지 마세요

  4. `static_cast`

     암시적 변환을 강제로 진행할 때 사용 (비상수 → 상수, `int` → `double`)

     상수 → 비상수는 안됨

- C++에서는 객체 하나가 가질 수 있는 주소가 여러 개가 될 수 있음.

  예를 들면 `Base` 클래스를 상속받은 `Derived`를 `Derived*`로 가르킬 때와 `Base*`로 가르킬 때 달라진다.

- 객체의 메모리 배치 구조를 결정하는 방법과 객체의 주소를 계산하는 방법은 컴파일러마다 다르다.

- 파생 클래스 객체임이 분명하지만, 조작할 수 있는 포인터가 기본 클래스 인 경우가 있다. 

  1. 이 때에는 `dynamic_cast`를 사용할 수도 있지만, 

  2. 파생 클래스 객체에 대한 포인터를 컨테이너에 담아서 기본 클래스 인터페이스를 통해 조작하지 않아도 되도록 하거나, 

  3. 가상함수 집합으로 정리하여 기본 클래스에 넣어두자.

  cascading `dynamic_cast` 방식의 설계는 반드시 피하자.

- 다른 방법이 가능하다면, 캐스팅은 피하자. 특히 `dynamic_cast`는 성능이 민감한 코드에서 꼭 피하자.

- 캐스팅이 어쩔 수 없이 필요하면, 함수 안에 숨길 수 있도록 해보자.

- C style 보다는 C++ style 캐스팅을 쓰자.

### 항목 30 인라인 함수는 미주알고주알 따져서 이해해 두자

- 인라인 함수 ↔ 아웃라인 함수 (일반적인 함수)

- 본문 길이가 짧은 인라인 함수의 경우, 함수 호출문보다 크기가 작아질 수 있다.

- `inline` 키워드는 컴파일러에 대해 **요청**을 하는 것이지 **명령**을 하는 것이 아니다.

  `inline`을 붙이지 않아도 암시적으로 인라인화 될 수 있고, `inline`을 붙혀도 인라인화 되지 않을 수 있다.

  - 클래스 정의 안에 함수를 바로 정의해서 넣으면 인라인 함수 후보가 된다.
  - 간단한 함수라도, 가상 함수의 호출은 절대 인라인화 되지 않는다. 
  - 해당 함수의 함수 포인터를 취하여 호출하는 경우가 있다면, `inline`을 붙혀도 인라인화 되지 않는다. 함수의 주소를 취하기 위해서 아웃라인 함수 본문을 만들어야만 한다.

- 생성자, 소멸자는 인라인화 하지 말자.

- 인라인 함수는 디버깅 할 수 없다. 있지도 않은 함수 내부에 중단점을 걸 수 없다.

- 인라인 함수는 대체로 헤더 파일 내부에 있어야 하는 게 맞다. 빌드 환경에서 컴파일 중에 인라인화를 수행하기 때문

- 크기가 작고, 자주 호출되는 함수에 대해서만 인라인화 하자.