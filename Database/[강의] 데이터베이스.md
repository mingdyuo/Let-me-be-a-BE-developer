# 데이터베이스

[KOCW 데이터베이스 강의](http://www.kocw.net/home/search/kemView.do?kemId=1064626)

- [x] 1차시 관계 대수와 SQL (21/06/01)
- [ ] 2차시 관계 대수와 SQL (21/06/01)
- [ ] 3차시 관계 대수와 SQL
- [ ] 3차시 관계 대수와 SQL 데이터베이스 설계와 ER 모델
- [ ] 4차시 데이터베이스 설계와 ER 모델
- [ ] 5차시 데이터베이스 설계와 ER 모델
- [ ] 6차시 물리적 데이터베이스 설계
- [ ] 7차시 물리적 데이터베이스 설계
- [ ] 7차시 물리적 데이터베이스 설계, 릴레이션 정규화
- [ ] 8차시 릴레이션 정규화
- [ ] 9차시 릴레이션 정규화, 뷰와 시스템 카탈로그
- [ ] 10차시 뷰와 시스템 카탈로그
- [ ] 11차시 트랜잭션
- [ ] 12차시 트랜잭션
- [ ] 13차시 데이터베이스의 저장과 접근 : 해싱 빅테이터 관리 서론
- [ ] 14차시 빅테이터 관리 서론
- [ ] 15차시 NoSQL Database Patterns
- [ ] 15차시 NoSQL Database Patterns

<br>

## 관계 대수

관계 데이터 모델에서 지원하는 두 가지 언어

1. 관계 해석 (relational caculus)
2. 관계 대수 (relational algebra)
   - 기존의 릴레이션으로부터 새로운 릴레이션을 생성
   - 피연산자와 연산이후의 결과 모두 릴레이션

- primitive operator : CPU가 바로 연산 가능

![image](https://user-images.githubusercontent.com/41130448/120252854-b02a3e80-c2c0-11eb-8300-e7b246a6e8a9.png)

- 세미 조인 - 반만 조인하는것?

- 카티션 곱 -> 양쪽의 튜플을 엮어서 가능한 모든 경우를 만드는 것

  튜플 수가 많은 경우 연산할때 시간이 겁나 많이 걸린다.

- Selection 연산자

  - 단항 연산자
  - 실렉션 조건을 predicate라고 한다. (true, false를 판단하는 기준)

- relation의 기본 원칙 : 모든 튜플들은 unique하다

- 임의의 relation으로 합집합을 만들 수는 없다. (의미가 없음)

  합집합 호환(union compatible)을 만족해야 한다.

  attribute의 수가 같고, 도메인이 같아야 함
  
- 프로젝션 할 때 중복 제거는 굉장히 오래걸리는 연산

  특별히 명령을 하지 않는 이상 중복이 허용되도록 연산이 이루어짐

- 카티션 곱

  임의의 두 릴레이션의 모든 가능한 조합을 만드는 릴레이션

  사용자가 실제로 원하는 것은 결과 릴레이션의 일부일 경우가 많다. 그래서 그 자체는 유용하지 않을 수 있다. 

  join을 하기 위한 연산이라서 중요한 것

- 관계 대수의 완전성

  관계 대수의 필수적인 연산자 : selection, projection, 합집합, 차집합, 카티션 곱 → 어떤 데이터 베이스 언어라도 이 연산자들은 꼭 표현할 수 있어야 한다.

  다른 관계 연산자 : 필수적인 관계 연산자를 두 개 이상 조합하여 표현 가능

  임의의 질의어가 적어도 필수적인 관계 대수 연산자들만큼의 표현력을 갖고 있으면 관계적으로 완전하다고 한다. (relationally complete)

- 조인 연산자

  두 개의 릴레이션으로 부터 **연관된 튜플**들을 결합함 (공통 attribute)

  릴레이션의 관계를 다루는 데에 매우 중요함

  종류

  → 세타 조인, 동등 조인(equi join), 자연 조인(natural join , 가장 많이 사용함), 외부 조인(outer join), 세미 조인

- 디비전 연산자

  나누어 지는 릴레이션이 나누는 릴레이션을 **모두** 포함하고 있어야 결과값에 포함됨

- 조인 연산은 disk에서 이루어지므로 시간이 많이 걸린다.

- 관계 대수의 한계

  - 산술 연산을 할 수 없음
  - 집단 함수 (aggregate function)을 지원하지 않음 (개별적인 검색만 가능, 통계 작업 불가)
  - 정렬을 나타낼 수 없음
  - 데이터베이스를 수정할 수 없음
  - 프로젝션의 연산 결과에 중복된 튜블을 나타내는 것이 필요할 때가 있는데 이를 명시하지 못함. 

- Data analysis

  그루핑하고, 통계 내는 것

  연도별, 부서별, 지역별 등등 다양한 기준을 가지고 한번에 그루핑하면 어렵다.

  multi dimension에서 dimension은 곧 attribute, 다차원의 경우 데이터가 많으므로 연산이 오래 걸림. 다 소팅해야 되기 때문에.

  그래서 수시로 하지 않고 주기적으로 정해놓고 가끔함

  이 분석을 batch로 (real-time으로) 처리하면 더 자주 작업을 진행할 수 있다.  

- 외부 조인

  left, right, full조인

  관련된 튜플은 모두 포함되고, 조인 조건을 만족하는 것을 넣는지 아닌지에 따라 나눔. 

<br>

### SQL

- SEQUEL부터 시작됨

- 비절차적 언어(선언적 언어)

  자신이 원하는 바만 명시, 처리하는 방법은 명시할 수 없음

- DBMS는 사용자가 SQL을 입력하면 그걸 번역해서 요구한 데이터를 찾아온다.

- 두 가지 인터페이스

  대화식(interactive), 내포된(embedded)

- 구성 요소

  데이터 정의어, 조작어, 제어어

- UPDATE DELETE INSERT

  릴레이션 하나에 대해서 수행됨. 단항 연산처럼

- SELECT

  여러 개의 릴레이션에 대해 수행 가능

- 데이터 정의어

  ![image](https://user-images.githubusercontent.com/41130448/120300552-015d2100-c307-11eb-9295-1839b1591830.png)

- 릴레이션, 도메인, 제약조건, 뷰, 권한 등을 그룹화하기 위해서 스키마 개념을 지원

  ```sql
  CREATE SCHEMA MY_DB AUTHORIZATION kim;
  
  DROP SCHEMA MY_DB RESTRICT; # 내부에 다른 릴레이션이 많이 존재하면 안삭제
  DROP SCHEMA MY_DB CASCADE; # 내부에 연결된 릴레이션 삭제
  ```

- 무결성 제약조건

  ```
  NOT NULL
  UNIQUE
  DEFAULT
  CHECK
  FOREIGN KEY REFERENCES
  ON
  (CASCADE UPDATE 등)
  ```

  DBMS 시스템 자체가 보장해주도록 설정할 수 있다.

  제약조건에 이름 붙혀서 추가 가능

  ```sql
  ALTER TABLE STUDENT ADD CONTRAINT STUDENT_PK
  	PRIMARY KEY(STNO);
  ```

- SELECT문

  정보를 검색하는 질의문

  관계 대수의 실렉션과 의미가 완전히 다르다.

  관계 대수의 실렉션, 프로젝션, 조인, 카티션 곱을 조합한 것

  ```sql
  SELECT [DISTINCT] ATTRIBUTES
  FROM RELATIONS
  [WHERE CONDITIONS]
  [GROUP BY ATTRIBUTES]
  [HAVING CONDITIONS]
  [ORDER BY ATTRIBUTES [ASC|DESC]];
  ```

- SIMILAR MATCH

  `%`를 사용

  ```SQL
  WHERE EMPNAME LIKE '이%' # 이씨 성을 갖는 사람 찾기
  ```

- 부정 검색 조건

  `<>`를 사용

  ```SQL
  WHERE DNO <> 1
  ```

- 리스트를 사용한 검색

  ```SQL
  WHERE DNO IN (1, 3)
  ```

  

