# 데이터베이스

[KOCW 데이터베이스 강의](http://www.kocw.net/home/search/kemView.do?kemId=1064626)

- [x] 11차시 트랜잭션 (21/06/09)
- [x] 12차시 트랜잭션 (21/07/04)
- [ ] 13차시 데이터베이스의 저장과 접근 : 해싱 빅테이터 관리 서론
- [ ] 14차시 빅테이터 관리 서론
- [ ] 15차시 NoSQL Database Patterns
- [ ] 15차시 NoSQL Database Patterns

<br>

### 공부 가능한 사이트 / 소스

[SqlZoo](https://sqlzoo.net/)
[sql-ex](https://sql-ex.ru/)
[공공데이터포털](https://www.data.go.kr/)

<br>

## 목차

### [관계 대수와 SQL](#관계 대수와 SQL)

[관계 대수](# 관계 대수)
[SQL](# SQL)
[리눅스와 MySQL 접속 방법](#리눅스와 MySQL 접속 방법)
[데이터베이스 설계](#데이터베이스 설계)

### [ER 모델](#ER 모델)

[엔티티](#엔티티)
[약한 엔티티 타입](#약한 엔티티 타입)
[애트리뷰트](#애트리뷰트)
[관계와 관계 타입](#관계와 관계 타입)
[논리적 설계](#논리적 설계)

### [물리적 데이터베이스 설계](#물리적 데이터베이스 설계)

[보조 기억 장치](#보조 기억 장치)
[보조 기억 장치 - 자기 디스크](#보조 기억 장치 - 자기 디스크)
[버퍼 관리와 운영 체제](#버퍼 관리와 운영 체제)
[디스크 상에서 file의 레코드 배치](#디스크 상에서 file의 레코드 배치)
[file structure](#file structure)

<br>



## 트랜잭션

- 아주 중요한 기능. 이 기능이 있기 때문에 비싼 돈을 주고 DBMS를 쓰는 것임
- 동시성 제어와 회복을 다룰 것이다.

### 트랜잭션이 뭐냐 (Transaction)

- 간단하게 말해서는 데이터 어플리케이션

- 대규모 데이터 베이스를 많은 여러 사용자들이 동시에 접근, 서로 같거다 다른 부분에 접근하면서 데이터 베이스를 사용한다.

  1. 동시성 제어 (concurrency control)

     - 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향은 이들을 순차적으로 수행하였을 때 데이터베이스에 미치는 영향과 같도록 보장
     - 다수의 사용자가 DB를 동시에 접근하도록 허용하면서 DB의 일관성을 유지함

     > 통상 정보 시스템의 성능 평가는 1초에 몇 개의 트랜잭션을 처리하는지(TPS)로 한다.
     >
     > 이거에 비해서는 운영체제에서 쓰는 동시성 제어는 간단하다.
     >
     > CPU, 하드의 성능이 좋다고 해서 정보 시스템의 성능이 좋은 것이 아니다. 소프트웨어와 하드웨어가 조화를 이루어야 함
     >
     > 컴퓨터 + 애플리케이션 + 정보 시스템 → 다 묶여서 성능이 측정됨
     >
     > 성능을 평가할 때 데이터가 다 미리 준비되어 있음 이걸로 벤치마킹을 함.

  2. 회복 (recovery)

     - DB 갱신 과정에서 시스템이 고장나도 일관성을 유지함

       > worst case가 발생했을 때 어떻게 자동화 해서 복구해야 하는지
       >
       > 어떤 상황에서도 데이터를 잃어버리면 안됨

- 응용의 예시

  모든 사원의 급여를 6% 인상하는 연산을 수행해야 한다.

  ```sql
  UPDATE EMPLOYEE
  SET SALARY = SALARY * 1.06;
  ```

  - 이 때 사원 전원의 급여가 수정되거나 모두 수정되지 않도록 보장해야 함. (원자성)

  - 310명 수정째에 컴퓨터 시스템이 다운되고 재가동된다면?

  - DBMS가 추가로 정보를 유지하지 않으면 DBMS는 재가동 후에 어디까지 수정했는지 알 수 없음. 심지어 돌리던 질의가 수백 수천개라면? 

    → 이를 위해서 로그를 유지할 필요가 있다.

- 응용의 예시 2 : 송금과 이체

  (송금자의 계좌에서 돈을 빼는 연산 + 수신자의 계좌에 돈을 넣는 연산)으로 이루어짐

  하나만 수행하고 시스템이 다운되는 경우 복구하거나 수행을 다시 제대로 해야 한다.

  두 연산을 하나의 단위(트랜잭션)으로 보아서 원자성을 띠도록 DBMS가 보장해야 함

- 응용의 예시 3 : 비행기 좌석 예약

  트랜잭션 과정에서 좌석 확인 후 꽉 차면 ABORT, 그렇지 않으면 예약 정보를 넣고 COMMIT

  한번 COMMIT이 되어 업데이트 되면 어떤 상황에서도 이 데이터를 보장해야 한다.

- 트랜잭션 덩어리는 하나의 SQL문이라고 가정하고 수행되어야 함

  이거 때문에 가격이 비싸고 개발하기가 어렵다.

- 트랜잭션의 특징 (ACID)

  1. 원자성 (Atomicity)

     - all or nothing. 완전히 실행되거나 아예 안되거나

     - DBMS의 회복 모듈은 시스템이 다운되는 경우에 부분적으로 DB를 갱신한 트랜잭션의 영향을 취소하여 원자성을 보장
     - 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행(REDO)함으로써 트랜잭션의 원자성을 보장 (COMMIT 된 트랜잭션이 제대로 반영 되었는지 확인)

  2. 일관성 (Consistency)

     - 어떤 트랜잭션이 수행되기 전에 DB가 일관된 상태를 가졌다면, 트랜잭션이 수행된 후에 DB는 또 다른 일관된 상태를 가진다.

     - 트랜잭션이 수행되는 도중에서는 일시적으로 일관되지 않은 상태를 가질 수 있다.

       ![image](https://user-images.githubusercontent.com/41130448/121327017-09900e80-c94e-11eb-97f2-9c5869a53830.png)

       중간결과 (temporary, 일시적, 불일치 상태일 수 있음) : 한 계좌에서 송금을 위해 돈을 뺏지만 아직 상대방 계좌에 넣지 않은 상태

  3. 고립성 (Isolation)

     - 한 트랜잭션이 데이터를 갱신하는 동안, 완료 전에는 갱신중인 데이터를 다른 트랜잭션이 접근하면 안됨.

       (데이터를 중심으로 분리해야 하므로 관리하기가 까다롭다.)

     - 다수의 트랜잭션이 동시에 수행되더라도, 그 결과는 어떤 순서에 따라 하나씩 수행한 결과와 같아야 한다.

       > 실제로는 병행해서 수행하지만, 순서대로 수행하는 것과 같은 효과를 갖는다.

     - DBMS의 동시성 제어 모듈이 트랜잭션의 고립성을 보장한다.

     - DBMS는 응용 프로그램의 요구사항에 따라서 다양한 고립 수준을 제공한다. (isolation level)

  4. 지속성 (Durability)

     - 일단 한 트랜잭션이 완료되면 이 갱신 내용은 후에 시스템에 고장이 나더라도 손실되지 않고 DB에 반영되어 있어야 함.
     - DBMS의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장한다. 

  ![image](https://user-images.githubusercontent.com/41130448/121327727-a94d9c80-c94e-11eb-96e0-ed31b3dee6be.png)

- 트랜잭션의 완료와 철회

  1. 완료 (commit)

     - 변경하려는 내용이 DB에 완전히 반영됨
     - SQL 구문 상으로 `COMMIT WORK`
     - DB는 새로운 일관된 상태를 갖는다.

  2. 철회 (abort)

     - 트랜잭션에서 변경하려는 내용이 데이터베이스에 일부만 반영된 경우에는 원자성을 보장하기 위해서 트랜잭션이 갱신한 사항을 트랜잭션이 수행되기 전의 상태로 되돌린다.

       원상복구 ! UNDO ! 옛날 값과 상태를 알아야 한다. 로그에 기록해야 함.

     - SQL 구문 상으로 `ROLLBACK WORK`

     - DB는 불일치 상태를 가질 수 있다.

- 트랜잭션이 성공하지 못하는 원인 (failure의 원인)

  1. 시스템(사이트) 고장

     CPU, 주기억장치, 전원 공급 장치 등이 고장 (서버에서는 얘의 원인 비율이 적다.)

  2. 트랜잭션 고장

     트랜잭션 고장은 트랜잭션이 수행되는 도중에 철회됨

  3. 매체 고장

     디스크 헤드, 콘트롤러 등이 고장나서 보조 기억 장치의 전부나 일부 내용이 지워지는 것

     > 하드디스크 이중화 등으로 대응

  4. 통신 고장

  5. 자연적 재해

  6. 부주의 또는 고의적 고장

<br>

### 동시성 제어

- 대부분의 DBMS는 다수의 사용자가 쓴다.

  동시에 동일한 테이블 접근하기도 한다.

- DBMS 성능을 높이기 위해서 여러 사용자의 질의나 프로그램을 동시에 수행하는 것이 필수적이다.

- 동시성 제어 기법은 여러 사용자들이 동시 수행하는 환경에서 부정확한 결과를 생성할 수 있는 간섭, 충돌이 생기지 않도록 함

  > 특히 같이 읽는건 괜찮은데 동시에 쓰기를 할 때 충돌 발생

- data의 뭘 공유하느냐?

  릴레이션, 튜플 값, 애트리뷰트 ? 이런 공유 레벨이 다양함

- 동시성 제어

  1. 직렬 스케쥴(serial schedule)

     여러 트랜잭션들의 집합을 한번에 한 트랜잭션씩 차례대로 수행함

     어떤 순서든 상관없이 하나씩 처리

  2. 비직렬 스케쥴(non-serial schedule)

     어떤 트랜잭션들을 동시에 수행. 어떤 순서로 하는지 모름

  3. 직렬 가능(serializable)

     비직렬 스케쥴의 결과가 어떤 직렬 스케쥴의 수행 결과과 동등함

  > 이거 잘못하면 스케쥴하다가 시간 다간다
  >
  > 어떤 때에 어떤 트랜잭션이 들어올지 모르고 스케쥴링 하는 시간 자체의 오버헤드 이런 것도 존재한다.
  >
  > → 모든 트랜잭션이 어떤 규칙을 따라서 실행되기만 하면 됨

- 데이터베이스 연산

  디스크 → 주기억장치 (버퍼) → 응용프로그램 내의 변수

  이걸 각각 둘로 쪼갠다.

  1. `Input(X)`

     데이터베이스 항목 X를 포함하고 있는 블록을 주기억 장치의 버퍼로 읽어들임 

  2. `Output(X)`

     데이터베이스 항목 X를 포함하고 있는 블록을 디스크에 기록함

  3. `read_item(X)`

     주기억 장치 버퍼에서 DB 항목 X의 값을 프로그램 변수 X로 복사함

  4. `write_item(X)`

     프로그램 변수 X의 값을 주기억 장치 내의 DB 항목 X에 기록함

- 동시성 제어를 하지 않고 병렬 처리 시 발생할 수 있는 문제

  1. 갱신 손실(lost update)

     수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어 씀으로써 갱신이 무효가 되는 것

     트랜잭션이 잘 업데이트 해 놨는데 교통정리 안되서 다른 트랜잭션이 업데이트해서 이전의 결과가 반영이 안된 것처럼 되버리는 것

     > 열심히 업데이트 했는데 없어짐. Consistent하지 않은 현상

  2. dirty read

     (완료되지 않은 트랜잭션이 갱신한) 데이터를 읽는 것

     완료된 트랜잭션의 데이터를 clean하다고 함. 중간 결과를 갖다 썼는데, 갱신하던 트랜잭션이 롤백하는 경우 또 같이 롤백이 일어나야 함 (cascade, 연쇄 복귀 일어나야 함)

     항상 worst case 생각해야 함. 그 경우 오버헤드가 굉장히 커진다. 커밋한 경우에는 또 롤백이 안된다. 더티 데이터 읽은 경우에는 커밋하지 말고 계속 대기타야 한다. 왜냐면 그 데이터를 제공한 트랜잭션이 롤백하는 경우 같이 롤백해야 하므로. 그러면 병렬성의 의미가 없자나?

  3. unrepeatable read
  
     한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽는 것
  
- 로킹 (locking) 

  - 동시에 수행되는 트랜잭션들의 동시성을 제어하기 위해서 가장 널리 사용되는 기법이다.

    배타적인 리소스에 대한 충돌 방지 가능

  - lock은 DB 내의 각 데이터 항목과 연관된 하나의 변수이다.

    각 트랜잭션이 수행을 시작하여 데이터 항목을 접근할 때마다, 요청한 락에 대한 정보는 락 테이블(lock table) 등에 유지된다.

    트랜잭션이 데이터 항목에 대한 접근을 끝낸 후에 락을 해제한다

  - 독점 락 (X-lock, eXclusive lock)

    트랜잭션에서 갱신을 목적으로 데이터 항목을 접근할 때 요청하는 것

    이 락을 언제 언락하느냐? -> 

  - 공유 락 (S-lock, Shared lock)

    트랜잭션에서 읽을 목적으로 데이터 항목을 접근할 떄 요청하는 것

  - 락을 아무렇게나 쓰면 안된다. 정교한 메커니즘을 갖고 써야한다.

  ![image](https://user-images.githubusercontent.com/41130448/124358926-8a94aa00-dc5d-11eb-8da9-9db9453ff75f.png)

  이 방법만 가지고 있을 때에는 동시성 제어 문제 발생 가능

- 2단계 락 프로토콜 (2-phase locking protocol)

  - 락을 요청/해제하는 것이 2단계로 이루어진다.
  - 락 확장 단계가 지난 후에 락 수축 단계에 들어간다.
  - 일단 락을 한 개라도 해제하면 락 수축 단계에 들어간다. 
  - 한번 걸었으면 내가 사용할 모든 락에 대해 해제 못해. 죄다 락을 걸어. 있는 락을 다 걸었으면 락을 해제할 수 있음. 하나를 해제하면 죄다 해제해야 함

  1. 락 확장 단계 (1단계)

     확장 단계에서는 트랜잭션이 데이터 항목에 대해서 새로운 락을 요청할 수 있지만, 보유하고 있는 락을 하나도 해제할 수 없음.

  2. 락 수축 단계 (2단계)

     수축 단계에서는 보유하고 있던 락을 해제할 수 있지만, 새로운 락을 요청할 수 없음

     락을 조금씩 해제할 수도 있고, 트랜잭션이 완료 시점에 이르렀을 떄 (커밋할 때) 한꺼번에 모든 락을 해제할 수도 있음. 일반적으로는 한꺼번에 해제하는 방식을 사용

  - 락 포인트

    한 트랜잭션에서 필요로 하는 모든 락을 걸어놓은 시점

  ![image](https://user-images.githubusercontent.com/41130448/124359093-5cfc3080-dc5e-11eb-8318-5e61cd15e0ec.png)

  이 중 한꺼번에 하는 방법을 많이 사용한다.

  > 분산 환경에서는 2-phase commit protocol이라는 것도 있다.

- 데드락

  - 2단계 락 프로토콜에서 발생 가능
  - 두 개 이상의 트랜잭션들이 서로 상대방이 보유하고 있는 락을 요청하면서 기다리고 있는 상태
  - 데드록을 방지하는 기법이나, 데드락을 탐지하고 victim을 선정해서 푸는 기법 등을 사용하여 해결한다. 
  
- 다중 락 단위 (multiple granularity)

  - 대부분의 트랜잭션들이 소수의 튜플들을 접근하는 경우, 튜플 단위로 락을 해도 락 테이블을 다루는 시간이 오래 걸리지 않는다.

  - 트랜잭션들이 많은 튜플을 접근하는 경우, 튜플 단위로만 락을 한다면 락 테이블에서 락 충돌을 검사하고 정보를 기록하는 시간이 오래 걸린다.

  - 트랜잭션이 접근하는 튜플의 수에 따라서 락을 하는 데이터 항목의 단위를 구분하는 것이 필요하다.

  - 한 트랜잭션에서 락을 할 수 있는 데이터 항목이 두 가지 이상 있으면, 다중 락 단위라고 한다.

  - 데이터베이스에서 락을 할 수 있는 단위로는 DB, 릴레이션, 디스크 블록, 튜플 등이 있다.

    > 튜플이 최소 단위 (아주 정교한 수준)

  - 일반적으로 DBMS는 각 트랜잭션에서 접근하는 튜플 수에 따라 자동적으로 락 단위를 조정한다.

  - 락의 단위가 작을수록 락에 따른 오버헤드가 증가한다.

    락의 단위가 작을수록 동시성의 정도는 증가한다.

    > 현재 릴레이션에 저장되지 않은 정보에 대해 락을 걸 수는 없다.
    >
    > 팬텀 문제 발생 가능

<br>

## 회복

### 회복이 왜 필요할까

1. 어떤 트랜잭션 T를 수행하는 도중 시스템이 다운되는 경우, T의 수행 효과가 디스크의 데이터베이스에 일부 반영되어 있을 수 있다.

   -> 어떻게 T의 수행을 취소하여 원자성을 보장할 것인가 ?

2. 또한 트랜잭션 T가 완료된 직후에 시스템이 다운되면 T의 모든 갱신 효과가 주기억 장치로부터 디스크에 기록되지 않았을 수 있다.

   -> 어떻게 T의 수행 결과가 데이터베이스에 완전하게 반영되도록 하여 지속성을 보장할 것인가?

3. 디스크의 헤드 등이 고장나서 디스크의 데이터베이스를 접근할 수 없다면 어떻게 할 것인가?

그래서 별도의 로그에 관리를 한다.

### 개요

- 여러 응용이 주기억 장치 버퍼 내의 동일한 DB 항목을 갱신한 후에 디스크에 기록함으로써 성능을 향상시키는 것이 중요하다.

- 버퍼의 내용을 디스크에 기록하는 것을, 가능하면 최대한 줄이는 것이 일반적이다.

  > 버퍼가 꽉 찼을 때 또는 트랜잭션이 완료될 때 버퍼의 내용이 디스크에 기록될 수 있다.

- 트랜잭션이 버퍼에는 갱신 사항을 반영했지만 버퍼의 내용이 디스크에 기록되기 전에 고장이 발생할 수 있다. 

- 고장이 발생하기 전에 트랜잭션 완료 명령을 수행했다면 회복 모듈은 이 트랜잭션의 갱신 사항을 **재수행(REDO)**해서 트랜잭션의 갱신이 지속성을 갖도록 해야 한다.

- 고장이 발생하기 전에 트랜잭션이 완료 명령을 수행하지 못했다면 원자성을 보장하기 위해서 이 트랜잭션이 데이터베이스에 반영헀을 가능성이 있는 갱신사항을 **취소(UNDO)**해야 한다.

### 저장 장치의 유형

- 주기억 장치와 같은 휘발성 저장 장치에 들어 있는 내용은 시스템이 다운된 후에 모두 사라진다.
- 디스크와 같은 비휘발성 저장 장치에 들어 있는 내용은 디스크 헤드 등이 손상을 입지 않는 한 시스템이 다운된 후에도 유지된다.
- 안전 저장 장치(stable storage)는 모든 유형의 고장을 견딜 수 있는 저장 장치를 의미
- 두 개 이상의 비휘발성 저장 장치가 동시에 고장날 가능성이 매우 낮으므로, 비휘발성 저장 장치에 두 개 이상의 사본을 중복해서 저장함으로써 안전 저장 장치를 구현한다.

> 요즘 서버에서 사용하는 하드 구조 - RAID
> 디스크를 array로 묶어서 몇개는 자동 백업용으로 사용. 내부에서 디스크 몇개가 어떻게 돌아가는지는 사용자가 신경쓸 필요 없음. 

### 고장의 분류

1. 재해적 고장

   - 디스크가 손상을 입어서 데이터베이스를 읽을 수 없는 고장
   - 재해적 고장으로부터의 회복은 데이터베이스를 백업해 놓은 자기 테이프를 기반으로 한다.

2. 비재해적 고장

   - 그 이외의 고장

   - 대부분의 회복 알고리즘들은 비재해적 고장에 적용된다.

   - 로그를 기반으로 한 즉시 갱신, 로그를 기반으로 한 지연 갱신, 그림자 페이징(shadow paging)등의 알고리즘

     그림자 페이징 : 항상 새 블락으로 할당, 페이지 자체를 새/옛 페이지로 구분해서 쓴다. 업데이트 과정에서 생기는 문제/overwrite 문제 등을 해결할 수 있다.

     즉시 갱신 - 롤백을 해야 함/ 지연 갱신 - 롤백할 필요 없다.

     모든 트랜잭션은 다 커밋이 될 것이다 라는 낙관적인 가정을 가지고 즉시 갱신 형태로 overwrite한다.

   - 대부분의 상용 DBMS에서 로그를 기반으로 한 즉시 갱신 방식을 사용한다.

### 로그를 사용한 즉시 갱신

- 즉시 갱신에서는 트랜잭션이 데이터베이스를 갱신한 사항이 주기억장치의 버퍼에 유지되다가 트랜잭션이 완료되기 전이라도 디스크의 데이터베이스에 기록될 수 있다.

- DB에는 완료된 트랜잭션의 수행 결과 & 철회된 트랜잭션의 수행 결과도 반영될 수 있다.

- 트랜잭션의 원자성과 지속성을 보장하기 위해서 DBMS는 로그라고 부르는 특별한 파일을 유지한다.

- DB의 항목에 영향을 미치는 모든 트랜잭션의 연산들에 대해서 로그 레코드를 기록한다.

  각 로그 레코드는 로그 순서 번호(LSN : log sequence number)로 식별된다.

  > 데이터와 로그는 다른 디스크에 저장해야 한다. stable하게 저장해야 함

![image](https://user-images.githubusercontent.com/41130448/124386338-e3734980-dd14-11eb-903c-1a37e4ba5fb2.png)

<br>

## 데이터베이스의 저장과 접근 : 해싱 빅데이터 관리 서론

