## Chapter 1 C++에 왔으면 C++의 법에 따릅시다.

### 항목 0 용어 설명

- 암시적 타입 변환에 생성자가 사용될 여지를 남겨둬야 할 필요성이 있지 않으면 가능한 `explicit` 으로 선언하자.

### 항목 1 C++를 언어의 연합체로 바라보는 안목은 필수

C++을 다음 4가지 항목의 연합체로 보자.

1. C

   아무튼 C++의 기본은 C에 있다.

2. 객체 지향 개념의 C++

3. 템플릿 C++

   TMP가 나온 배경이 되는 기능. 근데 주류로 쓰지는 않나보다.

4. STL

   컨테이너, 반복자, 알고리즘, 함수 객체가 얽혀 있다.

C++을 사용해서 잘 프로그래밍 하려면 어떤 규칙을 적용해야 할까? 그건 위의 4가지 항목 중 어떤 부분을 사용하느냐에 따라 달라진다!

예를 들어서 값/객체를 넘길때 C style에서는 값 전달이, 객체 지향 C++에서는 상수 객체 참조자 전달이, 템플릿에서는 어떤 객체인지도 알 수 없으므로 특히 상수 객체 참조자 전달이, STL에서는 포인터를 본떠 만든 반복자와 값 전달이 좋다.

<br>

### 항목 2 `#define`을 쓰려거든 `const`, `enum`, `inline`을 떠올리자.

- 핵심은 **선행 처리자**보다 **컴파일러**를 더 가까이 하자는 것이다.

- `#define`은 컴파일러에게 넘어가기 전에 밀려버리고 다른 값으로 대체된다. 컴파일러의 기호 테이블에도 들어가지 않는다.

- `const` 상수는 여러 번 쓰이더라도 사본은 한개만 생긴다.

- `#define`을 `const` 상수로 바꿀 때 이 점은 주의하자.

  1. 상수 포인터를 정의하는 경우

     포인터는 꼭 `const`로 선언해 주어야 한다.

     보통 포인터가 가리키는 대상까지 `const`로 선언해준다.

     예를 들면

     ```c++
     const char* const authorName = "Justin Bieber";
     ```

     문자열 상수를 쓸 때에는 `string` 객체를 사용하는 것이 더 좋다.

     ```c++
     const std::string authorName("Justin Bieber");
     ```

  2. 클래스 멤버로 상수를 정의하는 경우

     해당 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 `static`으로 선언하자.

     헤더 파일에 선언하고 구현 파일에 정의한다.

     구식 컴파일러의 경우, 클래스 컴파일 시 클래스 상수가 필요한 경우에는 열거형을 쓸 수 있다. (`enum hack`이라고 부른다. 그만큼 꼼수라는거지~ )

     ```c++
     class ExampleClass {
     private:
     	enum { TestNum = 5 };
     }
     ```

- 매크로 함수 노노 인라인 함수 예스예스

- `enum`은 메모리 할당 안함. `#define`은 하는가본데??? 모지 

<br>

### 항목 3 낌새만 보이면 `const`를 들이대 보자!

- `const`를 쓸 수 있는 범위는 다양하다.

  1. 클래스 밖에서 전역/네임스페이스 유효범위의 상수를 선언/정의 할 수 있음

  2. 파일, 함수, 블록 유효 범위에서 `static`으로 선언한 객체에도 `const`를 붙일 수 있다.

  3. 클래수 내부의 정적, 비정적 데이터 멤버를 모두 상수로 선언할 수 있다.

  4. 포인터 자체 / 포인터가 가르키는 데이터를 상수로 선언할 수 있다.

     ```c++
     void f1(const Widget *pw);
     void f1(Widget const *pw);
     ```

     이 둘은 같은 매개변수 타입을 갖는다. `*`포인터의 왼쪽에 있으면 상수 포인터

- 반복자에 `const` 쓰기

  `const iterator`는 `iterator`가 가르키는 대상의 값은 변경 가능하나 가르키는 대상은 변경할 수 없다.

  ```c++
  const std::vector<int>::iterator iter = vec.begin(); // T* const 처럼 동작
  *iter = 10; 	// 가능
  ++iter; 		// 불가능
  ```

  `container::const_iterator`는 가르키는 대상의 값을 변경할 수 없으나, 가르키는 대상은 변경할 수 있다.

  ```c++
  std::vector<int>::const_iterator iter = vec.begin(); // const T* 처럼 동작
  *iter = 10;		// 불가능
  ++iter;			// 가능
  ```

- 함수 반환 값에 `const` 쓰기

  안전성이나 효율을 포기하지 않고 사용자측의 에러 및 돌발상황을 예방할 수 있다.

  ```c++
  // 곱하기 함수
  const Rational operator*(const Rational& lhs, const Rational& rhs);
  ```

  반환값이 상수 객체일 이유가 있을까? 

  만약 반환값이 상수 객체가 아니라면 아래의 실수들을 저질렀을 때 쉽게 잡을 수 없다.

  ```c++
  // 1
  Rational a, b, c;
  (a * b) = c; 		// 띠용
  // 2
  if (a * b = c)		// 띠용2 (원래 비교 구문이 의도)
  ```

  가능한 항상 `const`를 사용하자.

- 상수 **멤버 함수**

  - 왜 중요한가?

    1. 클래스의 인터페이스를 이해하기 좋게 해줌

       객체를 변경할 수 있는 함수 / 변경할 수 없는 함수 파악

    2. 이 키워드를 통해 상수 객체를 사용할 수 있도록 해줌

  - `const`키워드가 있고/없고의 차이가 있는 함수들도 오버로딩이 가능하다 !

    (`const` 함수는 `const` 객체를 사용할 때 호출, 비상수는 비상수 객체 사용 시 호출)

<br>

### 항목 4 객체를 사용하기 전에 반드시 그 객체를 초기화하자



<br>

## Chatper 2 생성자, 소멸자 및 대입 연산자

### 항목 7 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자.

- 기본 클래스 포인터를 통해 파생 클래스 객체가 삭제될 때, 기본 클래스 소멸자가 `virtual`로 선언되어 있지 않다면 `Undefined Behavior`를 일으킨다.

  보통은 파생 클래스 부분이 소멸되지 않는다.

- 가상 소멸자를 가지고 있지 않은 클래스는 기본 클래스로 사용되지 않을 클래스로 간주해도 된다. (다형성이 있겠구나)

  반대로 기본 클래스로 사용되지 않을 클래스는 소멸자를 가상으로 선언하지 말자.

- 가상 함수를 `C++`에서 구현하려면 클래스에 별도의 자료구조가 들어가야 한다. 이 자료 구조는 런타임에 객체의 가상함수를 선택하기 위한 정보를 가지고 있다. 

  보통 포인터의 형태를 취하며 `vptr`(가상 함수 테이블 포인터, virtual table pointer)라는 이름을 가지고 있다.

  `vptr`의 배열은 `vtbl`(가상 함수 테이블, virtual table)이라는 이름을 갖는다.

  즉 어떤 가상 함수가 호출 되려고 하면 그 객체의 `vptr`이 가리키는 `vtbl`에 따라 결정된다.

  → 아무튼 가상 함수를 선언하면 클래스 객체의 크기가 커진다.

- 가상 소멸자가 없는 클래스는 상속받으면 안된다! 

  예) `std::string`, `STL` 컨테이너 타입

- 순수 가상 소멸자

  - 해당 클래스를 추상 클래스로 만든다. (추상 클래스는 그 자체로 인스턴스를 만들 수 없는 클래스임)

  - ```c++
    class EXAMPLE{ 
    public:
    	virtual ~EXAMPLE() = 0;}; // 선언
    EXAMPLE::~EXAMPLE() {} // 정의
    ```

  - 소멸자가 동작하는 순서

    파생 클래스의 소멸자 호출, 기본 클래스쪽으로 올라가면서 각 소멸자가 하나씩 호출됨

<br>

## Chatper 3 자원 관리

- 자원이란 사용을 마치고 난 후에 시스템에 돌려줘야 하는 모든 것

  → 메모리, `file descriptor`, `mutex lock`, `font`, `brush` (GUI)

- 생성자, 소멸자, 객체 복사 함수를 사용해서 객체 기반의 자원 관리를 해보자.

### 항목 13 자원 관리에는 객체가 그만!

- RAII에 대해, 그리고 `auto_ptr`과 `shared_ptr`에 대해 설명하는 장이다.

- `auto_ptr`은 현재 deprecated 되었고, `shared_ptr`은 여기서 자세하게 다루지 않으니 그렇구나 하고 넘어가자.

- 동적 할당한 배열에 대해서는 `auto_ptr`과 `shared_ptr`을 사용할 수 없다고 하는데, 이것도 알아보자.

- RCSP (reference-counting smart pointer) 참조 카운팅 방식

  - 어떤 자원을 참조하는 외부 객체의 수를 기억, 해당 수가 0이 되면 그 자원을 자동으로 삭제한다.

  - 가비지 컬렉션의 동작과 비슷하다.

    다만, 순환 참조의 경우에는 없앨 수 없음

  - `tr1::shared_ptr`이 대표적인 예이다.

  - STL 컨테이너 등의 환경에 맞게 쓸 수 있다.

- 내부적으로 `delete []`가 아닌 `delete`를 사용하기 때문에 동적으로 할당한 배열에 대해 쓰면 애매하다. 컴파일 에러도 발생하지 않아 잡기도 어렵다.

- 앗 근데 이 책은 `C++11`에서의 스마트 포인터를 얘기하는게 아닌가..?

- 아무튼 중요한 점은 객체를 사용해서 자원 관리를 하자는 것이다.

<br>

## Chatper 4 설계 및 선언

### 항목 18 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자

- 인터페이스란 뭣인가

  함수도, 클래스도, 템플릿도 모두 인터페이스다.

- 사용자가 저지를 수 있는 종류의 실수를 알고 있어야 한다.

- 교차 DLL 문제

  - 객체 생성시에 어떤 DLL의 `new`를 썼는데, 삭제 시에는 다른 DLL의 `delete`를 사용한 경우

  - `shared_ptr`을 사용하게 되면 다른 DLL 사이에서 넘겨지더라도 어떤 DLL의 `delete`를 사용해야 하는지 알고 있다.

    따라서 교차 DLL 문제를 미연에 방지할 수 있다.

<br>

### 항목 19 클래스 설계는 타입 설계와 똑같이 취급하자

- 좋은 타입은 문법이 자연스럽고, 의미 구조가 직관적이며, 효율적인 구현이 한 가지 이상 가능해야 한다.

  충분한 고민을 하며 클래스를 정의해야 이런 조건을 만족시킬 수 있다.

- 신경써야 할 것들

  1. 새로 정의한 타입의 객체 생성 및 소멸은 어떻게 ?

     요 부분에 따라서 생성자와 소멸자의 설계가 바뀐다. 

  2. 객체 초기화는 객체 대입과 어떻게 달라야 하는가 ?

     생성자와 대입 연산자 동작의 차이점을 결정짓는 요소임

  3. 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가?

     값에 의한 전달을 구현하는 것은 복사 생성자임!

  4. 새로운 타입이 가질 수 있는 적절한 값에 대한 제약은 어떻게 할 것인가?

     클래스의 불변속성(invariant) : 반드시 유효한 데이터 멤버의 조합 값들

     불변속성에 따라 함수 내부의 에러 점검 루틴이 달라진다.

  5. 기존의 클래스 상속 흐름에 맞출 것인가?

     이미 있는 클래스에 상속 받으면 얘네한테 제약을 받게 됨. 특히 멤버 함수가 가상인지, 비가상인지 여부가 가장 중요한 요인이다.

  6. 어떤 종류의 타입 변환을 허용할 것인가?

     암시적 변환, 명시적 변환 제한하기.

  7. 어떤 연산자와 함수를 두어야 의미가 있을까?

  8. 표준 함수 중 어떤 것을 비허용할 것인가?

     `private`로 선언해야 하는 것들

  9. 새로운 타입의 멤버에 대한 접근 권한을 어느 쪽에 줄 것인가?

     `public`, `protected`, `private` 영역 정하기

     `friend` 클래스, 함수 정하기

     클래스 중첩에 대한 결정 정하기

  10. '선언되지 않은 인터페이스'로 무엇을 둘 것인가?

  11. 새로 만드는 타입이 얼마나 일반적인가?

      만드는 것이 타입 하나가 아닌, 타입의 군집일 수도 있음. 

      그렇다면 클래스가 아닌 클래스 템플릿을 정의해야 하는 경우임

  12. 정말로 꼭 필요한 타입인가?

      기능 몇 개가 아쉬워서 파생 클래스를 새로 뽑는 것이라면, 차라리 간단하게 비멤버 함수나 템플릿을 몇 개 더 정의해라

<br>

### 항목 20 '값에 의한 전달'보다는 '상수 객체 참조자에 의한 전달 방식이 대개 낫다.

- 복사 손실(slicing problem) 

  - 파생 클래스 객체가 전달될 때 기본 클래스 객체로 전달되는 경우. 가끔 일어난다.

  - 이게 일어나면 파생 클래스 객체로 동작하는 특징들이 잘려 나간다. 그래서 slicing problem

  - `const reference`로 매개변수를 넘기면 이 문제를 걱정하지 않아도 된다.

  - 예)

    A 클래스를 상속받은 클래스 B가 있다. A에는 가상함수 `a()`가 있으며, B에도 구현되어 있다. 

    이 때 A를 값의 의한 전달로 받는 함수에 B로 만든 객체를 넣으면 생성자 A만 호출되고 B의 특성을 갖는 영역은 사라진다. `B::a()`는 사용하지 못한다.

    이 때 A를 const reference로 받는 함수에 B로 만든 객체를 넣으면 `B::a()`가 잘리지 않는다.

- 레퍼런스는 내부에서 포인터를 써서 구현된다.

  레퍼런스를 전달한다는 것은 결국 포인터를 전달하는 것과 일맥상통하다.

- 전달하는 객체의 타입이 `int`와 같이 built-in인 경우에는 값으로 넘기는 편이 대체로 더 효율적이다.

  1. **단순히 타입 크기가 작은 경우를 의미하는 것이 아니다.** 작더라도 user-defined 객체라면 복사하는 비용이 클 수 있다. 

     컴파일러 중에는 built-in과 user-defined 타입을 아예 다르게 취급하는 것도 있다. 

  2. 또한 user-defined 타입은 언제든 크기가 변할 수 있으므로 call by value로 사용하는 것은 권장되지 않을 것이다.

- STL의 `iterator`와 `functor`는 call by value로 설계되어 있다.

- 다음 3가지 타입은 call by value를 사용해도 저비용이라고 여겨질 수 있는 것들이다. 이외는 가능하면 상수 레퍼런스를 사용하자.

  1. built-in type
  2. STL iterator
  3. 함수 객체

<br>

## Chatper 5 구현

### 항목 27 캐스팅은 절약, 또 절약! 잊지 말자

- C++ 스타일 캐스트

  1. `const_cast`

     객체의 상수성을 없애는 용도로 사용. 이 캐스트만 `const` 떼버릴 수 있다.

  2. `dynamic_cast`

     안전한 다운캐스팅을 할 때 사용.

     주어진 객체가 어떤 클래스 상속 계통에 속한 특정 타입인지 아닌지 결정

     런타임 비용이 꽤나 높으므로 남발 ㄴㄴ

  3. `reinterpret_cast`

     포인터를 `int`로 바꾸는 등의 하부 수준 캐스팅

     적용 결과는 구현 환경에 의존적이고 하부 수준 코드 아니면 잘 쓰지 마세요

  4. `static_cast`

     암시적 변환을 강제로 진행할 때 사용 (비상수 → 상수, `int` → `double`)

     상수 → 비상수는 안됨

- C++에서는 객체 하나가 가질 수 있는 주소가 여러 개가 될 수 있음.

  예를 들면 `Base` 클래스를 상속받은 `Derived`를 `Derived*`로 가르킬 때와 `Base*`로 가르킬 때 달라진다.

- 객체의 메모리 배치 구조를 결정하는 방법과 객체의 주소를 계산하는 방법은 컴파일러마다 다르다.

- 파생 클래스 객체임이 분명하지만, 조작할 수 있는 포인터가 기본 클래스 인 경우가 있다. 

  1. 이 때에는 `dynamic_cast`를 사용할 수도 있지만, 

  2. 파생 클래스 객체에 대한 포인터를 컨테이너에 담아서 기본 클래스 인터페이스를 통해 조작하지 않아도 되도록 하거나, 

  3. 가상함수 집합으로 정리하여 기본 클래스에 넣어두자.

  cascading `dynamic_cast` 방식의 설계는 반드시 피하자.

- 다른 방법이 가능하다면, 캐스팅은 피하자. 특히 `dynamic_cast`는 성능이 민감한 코드에서 꼭 피하자.

- 캐스팅이 어쩔 수 없이 필요하면, 함수 안에 숨길 수 있도록 해보자.

- C style 보다는 C++ style 캐스팅을 쓰자.

<br>

### 항목 30 인라인 함수는 미주알고주알 따져서 이해해 두자

- 인라인 함수 ↔ 아웃라인 함수 (일반적인 함수)

- 본문 길이가 짧은 인라인 함수의 경우, 함수 호출문보다 크기가 작아질 수 있다.

- `inline` 키워드는 컴파일러에 대해 **요청**을 하는 것이지 **명령**을 하는 것이 아니다.

  `inline`을 붙이지 않아도 암시적으로 인라인화 될 수 있고, `inline`을 붙혀도 인라인화 되지 않을 수 있다.

  - 클래스 정의 안에 함수를 바로 정의해서 넣으면 인라인 함수 후보가 된다.
  - 간단한 함수라도, 가상 함수의 호출은 절대 인라인화 되지 않는다. 
  - 해당 함수의 함수 포인터를 취하여 호출하는 경우가 있다면, `inline`을 붙혀도 인라인화 되지 않는다. 함수의 주소를 취하기 위해서 아웃라인 함수 본문을 만들어야만 한다.

- 생성자, 소멸자는 인라인화 하지 말자.

- 인라인 함수는 디버깅 할 수 없다. 있지도 않은 함수 내부에 중단점을 걸 수 없다.

- 인라인 함수는 대체로 헤더 파일 내부에 있어야 하는 게 맞다. 빌드 환경에서 컴파일 중에 인라인화를 수행하기 때문

- 크기가 작고, 자주 호출되는 함수에 대해서만 인라인화 하자.

<br>