### 객체지향 원칙

- 바뀌는 부분은 캡슐화한다.

- 상속보다는 구성(composition)을 활용한다.

  서브클래스를 만들어서 행동을 상속받으면 컴파일시에 완전히 결정되어야 한다. 구성을 통해서 행동을 확장하면 실행중에 동적으로 행동을 설정할 수 있다.

- 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.

- 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.

- OCP : 클래스는 확장에 대해서는 열려 있고, 코드 변경에 대해서는 닫혀 있어야 한다.

- DI : 추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하도록 만들지 않도록 해야 한다.

<br>

### Strategy 패턴

- 알고리즘군을 정의하고 캡슐화

- 필요한 알고리즘군을 교환하며 사용할 수 있다. 

- 사용하는 클라이언트와 독립적으로 알고리즘 변경 가능

- 예제

  오리의 속성을 상속받은 → 모형 오리, 진짜 오리

  모형 오리는 꽥꽥거리기 대신 삑삑거리기를 해야 하고, 진짜 오리와 달리 날 수 없다.

  → 오리의 행동을 분리하여 행동 인터페이스로 만들고 그 행동을 또다시 분류하여 구현

  → 오리 기반 클래스는 행동 인터페이스를 가지고 있고, 자식클래스는 그 인터페이스를 상속받는다. 행동 인터페이스를 상속받아서 만든 구현 클래스 객체를 가지고 있어서 실제 알맞는 행위 가능

- 행위(메소드)도 클래스로 구분할 수 있다.

  행위도 상태를 가질 수 있다. 예를 들면 `fly()`라는 행위의 경우에는 속도, 가속도, 방향과 같은 상태를 가지고 있을 수 있고, 이 상태는 행위에 또다시 영향을 미칠 수 있다.

<br>

### 옵저버 패턴

- 신문사와 정기구독자의 관계와 비슷하다

- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 간다.

  자동으로 그 내용이 갱신된다.

  일대다 관계를 나타낸다.

- 신문사는 subject, 정기구독자는 observer이다.

- 상태를 저장하고 있는 지배적인 객체는 subject 객체이다. (subject 객체가 데이터의 주인이다.)

  observer 객체는 상태를 꼭 가지고 있을 필요가 없다. (subject 객체를 의존한다.)

- 여러 객체에서 동일한 데이터를 제어하도록 할 때 좋은 디자인 패턴이다

- 옵저버들에게 **연락을 돌리는 순서에 의존**하면 **절대 안된다.**

### 느슨한 결합

- 두 객체가 느슨하게 결합되어 있다는 것은, 두 객체간에 상호작용이 있지만 서로에 대해 잘 모른다는 것이다.

- 옵저버 패턴에서는 subject와 observer가 느슨하게 결합되어 있다. 다음과 같은 이점들이 있기 때문이다.

  1. subject는 옵저버에 대해서 구현된 정보를 알 필요가 없다. 단지 "옵저버 인터페이스를 구현한다"는 것만 알면 된다.

  2. 옵저버는 언제든 새로 추가, 삭제할 수 있다. 실행중이라도 무관하다

  3. 새로운 형식의 옵저버를 추가해도, subject를 변경할 필요가 없다.

  4. subject와 옵저버는 독립적으로 재사용할 수 있다.

  5. subject와 옵저버가 바뀌더라도 서로에게 영향을 미치지 않는다.

     ↪ 결국 객체 사이의 상호 의존성을 최소화시킨다 !

### 자바의 `java.util.Observable`

- 옵저버 디자인 패턴을 구현한 라이브러리다.
- 인터페이스가 아닌 클래스고, 활용도와 재사용성 측면에서 문제점이 있다.
  1. `Observable` 자체가 클래스이므로 서브클래스를 만들어야 하고, 이미 다른 super class를 확장하고 있다면 기능을 추가할 수 없다. 재사용성 X
  2. `Observable` 인터페이스라는 것이 없으므로 자바에 내장된 `Observer API`와 잘 맞는 클래스를 직접 구현하는 것이 불가능하다. `java.util`의 구현을 다른 구현으로 바꿀 수도 없다. (멀티 스레드로 구현하거나 이런 것이 안됨)
  3. `Observable` 클래스의 핵심 메소드를 외부에서 호출할 수 없다. `protected`로 선언되어 있기 때문. 상속받은 클래스만 호출이 가능하다.

<br>

### Decorator 패턴

- 객체에 추가적인 요건을 **동적으로 첨가**한다.

  마치 객체에 휘핑크림을 바르듯이

- 데코레이터의 형식은 그 데코레이터로 감싸는 객체의 형식과 같다.

  따라서 상속을 이용해서 형식을 맞춘다.

  그러나 목적은 **형식을 맞추는 것**이지, **행동을 물려받는 것**이 아니다.

- 상속이 아닌 구성의 방법을 사용했기 때문에 실행중에 데코레이터를 마음대로 조합해서 사용할 수 있다. 

- 새로운 행동을 추가할 때에도 기존 코드를 변경할 필요가 없다.

<br>

### Decorator 패턴의 단점 & 사용시 주의할 점

- 자잘한 클래스들이 많이 추가되어, 다른 사람의 입장에서 이해하기 힘든 디자인이 만들어질 수 있다.
- 특정 형식에 의존하는 클라이언트 코드 내에 데코레이터 패턴을 적용하면 안된다. 
- 구성 요소를 초기화 하는 데에 필요한 코드가 복잡해진다. 구성 요소 인스턴스만 만드는 것이 아니라, 많은 데코레이터로 감싸야 하기도 한다.

<br>

### Factory 패턴

- 객체를 생성하기 위한 인터페이스를 정의한다. 해당 인터페이스(추상 클래스)에서는 어떤 인스턴스가 만들어질지 모르고, 생성되는 인스턴스의 클래스 종류는 구상 클래스에서 결정된다.
- **객체의 생성**을 캡슐화할 수 있다.
- 추상 팩토리 패턴 : 인터페이스를 이용하여 서로 연관되거나 의존하는 객체를 구상 클래스를 지정하지 않고 생성하기
- 팩토리 메소트 패턴은 (클래스)상속을 통해서 객체를 만들고, 추상 팩토리 패턴은 객체 구성을 통해서 만든다.
- 구상 클래스에 대한 의존성을 줄여서 느슨한 결합을 도와준다.

### Factory 패턴 사용시 지키면 좋을 것

- 어떤 변수에도 구상 클래스에 대한 레퍼런스를 저장하지 않는다.
- 구상 클래스에서 유도된 클래스를 만들지 말자
- 베이스 클래스에 이미 구현되어 있던 메소드를 오버라이드 하지 말자: 베이스 클래스를 제대로 추상화 해야 하며, 모든 서브클래스에서 공유할 수 있는 것만 정의하고 구현

헷갈린다 ㅇㅇ.. 이 패턴은 꼭 다시 보자 

<br>

### 싱글턴 패턴

- 해당 클래스의 인스턴스가 하나만 만들어지도록 하는 패턴이다. 어디서든 그 인스턴스에 접근할 수 있다.

- 레지스트리 설정, 디바이스 드라이버, 로그 기록용 객체 등 두 개 이상의 인스턴스가 있으면 이상하게 동작할 객체에 대해서 적용한다. 

- 필요한 경우에만 생성(lazy instantiation)하므로 전역변수를 선언하고 사용하지 않을 시 발생하는 자원 차지와 같은 단점이 없다.

- 멀티 스레드 환경에서 사용 시 여러 개의 객체를 생성하게 될 수 있다. 이에 대처하는 방법들이 존재한다.

  1. 인스턴스를 가져오는 함수 자체를 동기화 (`java`의 `synchronized` 키워드)

     메소드를 동기화하면 성능이 100배정도 줄어든다. 만약 병목으로 작용한다면 다른 방법을 사용해야 한다.

  2. 인스턴스를 처음부터 만들어버린다.

     `static`으로 미리 선언해버린다. 표준 `C++`에서는 정적 객체의 생성 순서가 정해져 있지 않으므로 주의한다.

  3. DCL(Double checking locking)을 사용해서 동기화 되는 부분을 줄인다.

     객체가 존재하는지 확인하는 부분을 제외하고, 객체를 새로 생성하는 부분을 동기화한다. 객체를 새로 생성하기 이전에 객체의 존재 여부를 한번 더 체크하므로 중복 객체를 생성하지 않을 수 있다.

- 자바의 클래스 로더는 각각 다른 네임스페이스를 정의하므로 클래스 로더를 여러 개 사용하는 경우 싱글톤 인스턴스가 여러 개 생길 수 있다. 이런 경우에는 클래스 로더를 직접 지정해서 문제를 해결해야 한다.

- 싱글턴은 사실상 두 개의 책임을 가지고 있는 클래스가 된다. 

  1. 자신의 인스턴스 관리 (전역 접근 제공)
  2. 인스턴스 내에서의 작업

<br>

### 커맨드 패턴

- 특정 작업 요청을 캡슐화