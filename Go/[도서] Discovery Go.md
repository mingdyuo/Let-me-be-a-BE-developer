## Chapter 3

#### 문자열

- 문자열은 바이트들의 연속적인 나열
- 두 가지 방법으로 표현 가능
  1. `string` → 읽기 전용
  2. `[]byte` (`byte` == `uint8`)
- 문자열 잇는 방법
  1. `+` 연산자 사용
  
     간단한 문자열 붙히기 좋다.
  
  2. `fmt.Sprint()` 사용
  
     문자열이 아닌 것들도 서로 이어붙일 수 있다.
  
  3.  `fmt.Sprintf()` 사용
  
     형식 지정 가능
  
  4. `strings.Join()` 사용
  
     문자열 슬라이스나 배열에 대해서 쓰면 좋다. 특히 구분자 사용해서 이어 붙일 때 좋다.

#### 문자열 <-> 숫자

- 사용할 수 있는 패키지

  1. `strconv`

     Atoi(), ParseInt(), ParseFloat() 등

  2. `fmt`

     `fmt.Sscanf()`, `fmt.Sprint()`

     ```go
     var num int
     fmt.Sscanf("553", "%d", &num)
     
     var s string
     s = fmt.Sprint(3.14) // s == "3.14"
     s = fmt.Sprintf("%x", 13402077) // s == "cc7fdd"
     ```

#### 인코딩

- Go의 소스 코드는 UTF-8로 되어 있음 (유니코드 포인트를 나타내기 위한 바이트 수가 가변적이다.)

- `for i, r := range "문자열"` 을 통해서 UTF-8로 인코딩된 문자열을 다룰 수 있다.

  여기서 `i` 에는 바이트 위치가 들어가고 `r` 에는 문자의 바이트 값(유니코드 번호, `rune` == `int32` )가 들어간다.

  바이트 값 내용을 찍어보기 위해서는 `string()` 을 쓰면 된다.

#### 참고

- 굳이 UTF-8로 인코딩되어 있지 않은 문자열을 `string`으로 처리할 일은 많지 않다. 대부분 `[]byte` 를 이용해서 처리하는 것이 좋다. 
- 어떤 문자들이 들어있는지를 중시한다면 `string`으로, 실제 바이트 표현을 중요시한다면 `[]byte` 를 사용하는 것이 좋다.

<br>

### 테스트

- 파일명 마지막에 `_test` 를 붙히고, 함수명 맨 앞에 `Example` 을 붙혀서 작성한다.

- 함수 바디의 가장 아랫 부분에 나와야 하는 출력을 주석으로 작성한다.

  ```go
  func ExampleExample(){
  		fmt.Println("Example 1 2 3")
  		// Output:
  		// Example 1 2 3
  }
  ```


<br>

### 배열

- 배열은 연속된 메모리 공간을 순차적으로 이용한다.
- 배열 선언하기

```go
var newArr [N]Type // N을 꼭 써줘야 함
newArr := [N]Type{...}
newArr := [...]Type{...} // N 대신 ... 써주면 초기화 원소 개수 맞춰서 생성
```

- **배열의 길이는 타입(자료형)의 일부**이므로 크기를 조정할 수 없다.
- (정적) 배열은 `append` 자체가 안된다.

### 슬라이스

- 배열보다는 슬라이스를 더 많이 쓴다.

  `[]` 안을 비워놓으면 슬라이스가 생성된다.

  ```go
  friuts := make([]string, n)
  nums := make([]int, 길이, 용량) // 용량 지정 가능
  nums := make([]int, 0, 15) // 공간 미리 예약하기
  ```

- 슬라이스는 내부적으로 세 가지로 이루어짐

  1. 포인터(시작 주소)

  2. 길이 (length) - 슬라이스가 포함하는 원소의 개수

  3. 용량 (capacity) - 슬라이스가 포함하는 원소부터 원본 배열의 끝까지

     용량이 가득 찼는데, 새로운 내용을 덧붙이려는 경우 더 넓은 메모리 공간으로 이동 및 복사가 이루어진다. 새로운 내용은 `append`로 붙임

  > `C++`의 벡터와 비슷한 것 같다

- 같은 배열에서 잘라낸 슬라이스들은 모두 같은 원본 배열 (동일한 메모리)를 바라본다.

- 기본적으로 빈 슬라이스에는 `nil` 값이 들어 있음.

- 슬라이싱 (슬라이스에 대해서 인덱싱)을 할 때에는 **범위가 넘어가지 않도록 조심해야 한다.**

  범위가 넘어가는 경우 패닉이 발생한다.

- 복사하기

  ```go
  // src라는 슬라이스가 존재
  copy(dest1, src) // 이 경우에는 dest에 복사될 공간이 충분해야 한다.반환값으로 복사된 원소의 개수를 준다.반환값으로 모두 복사됬는지 체크
  desc2 := src // 이건 얕은 복사. 내부 원소들이 각각 복사되는 것이 아니라, 슬라이스 구성값(포인터, 길이, 용량)이 복사된 것, 원본 배열의 원소가 변하면 같이 바뀐다
  ```

- 삽입하기

  ```go
  // i를 중간에 삽입하는 경우
  a = append(a[:i+1], a[i:]...)
  a[i] = x
  // i가 len(a)번째인 경우
  a = append(a, x)
  ```

  다른 방법

  ```go
  // x가 1개 값인 경우
  a = append(a, x)
  copy(a[i+1:], a[i])
  a[i] = x
  // x가 슬라이스인 경우
  a = append(a, x...)
  copy(a[i+len(x):], a[i:])
  copy(a[i:], x)
  ```

- 삭제하기

  ```go
  // 1개를 지우는 경우
  a = append(a[:i], a[i+1:]...)
  // i~i+k만큼 지우는 경우
  a = append(a[:i], a[i+k:]...)
  ```

  복사 연산을 줄이고 싶은 경우

  ```go
  // 1개 삭제
  a[i] = a[len(a) - 1]
  a = a[:len(a)-1]
  // k개 삭제
  start := len(a) - k
  if i+k>start{
  		start = i + k
  }
  copy(a[i:i+k], a[start:])
  a = a[:len(a)-k]
  ```

- 삭제할 때 유의할 점

  슬라이스의 범위에 들어있지 않지만 원본 배열에 있는 포인터가 삭제되지 않는 경우, 유효하게 존재하므로 해당 포인터가 가리키는 메모리가 제거되지 않는다. (GC가 작동하지 않음)

  따라서 원소로 포인터를 갖는 경우 변경될 공간을 모두 `nil` 으로 바꿔주어야 GC가 메모리를 회수할 수 있다

<br>

### 스택

- 언어 차원에서 지원하는 자료구조는 없으며, 슬라이스를 사용하여 구현한다.

<br>

### 맵

- 해시 테이블로 구현되며, 순서가 없다.

- 키를 통해 값을 상수 시간에 가져올 수 있다.

- 값을 읽을 때 두 개의 변수로 받으면, 해당 키가 존재하는지의 여부를 받을 수 있다.

- 특정 키에 해당하는 원소를 아예 삭제하기

  ```go
  delete(mapName, keyName)
  ```
  
- 맵의 쓰기는 thread-safe하지 않다.

### 맵을 사용할 때 함수 테스트하기

- 맵을 이용하는 함수를 테스트할 때 해시값의 순서에 의존적인 코드를 작성하면 안된다. 

  1. `reflect.DeepEqual` 사용하기

     결과로 나와야 하는 맵을 직접 작성해서 실행 결과 값인 맵과 비교

  2. 맵의 크기, 각각의 키와 값들을 모두 비교

     직접 해당 키에 대한 값들을 비교문으로 작성

  3. `range`를 통해 맵 내부에 있는 키와 값을 각각 가져오고, 정렬하여 테스트

<br>

### 집합

- 맵을 통해 구현 가능하다.

  키에는 집합의 원소, 값에는 빈 구조체를 넣어준다. 빈 구조체는 메모리를 따로 차지하지 않으므로 오버헤드가 없다.

  만약 값을 `bool`로 넣으면 메모리를 차지한다.

- 해당 원소의 존재 여부는, 반환값을 두개 받아서 두번째 반환값을 조사한다.

<br>

### 입출력

- 바이트를 읽고 쓸 수 있는 인터페이스인 `io.Reader`, `io.Writer`를 이용해서 입출력한다.

- **표준 입출력, 파일, 버퍼, 소켓 등을 통해 입출력이 가능하다.**

  함수 작성 시 `io.Reader`, `io.Writer`를 인자로 받는다면 위의 요소들에 대해 **모두 적용할 수 있다.** 

- `io.Reader`를 받아서 `scanner := bufio.NewScanner()`로 스캐너를 생성해서 읽을 수 있다.

  `scanner.Scan()`을 실행하고(스캔 성공한 true 반환) `scanner.Text()`로 읽은 것을 가져온다.

  > 한 줄을 읽으며 delimeter를 포함하지 않는다. Reader를 사용하는 경우에는 delimeter가 들어있으므로, trim하는 작업이 추가적으로 필요함

  `scanner.Err()`의 반환값이 `nil`이 아니라면 non-EOF인 에러가 발생한 것이다.

- `strings`, `bytes` 패키지를 사용하여 바이트 버퍼를 쓰면, 입출력과 테스트시 용이하다. 파일 쓰듯이 버퍼를 쓸 수 있다.

<br>

## Chapter 4

### 에러

- 에러값을 반환하는 경우 가장 마지막 인자로 위치하는 것이 관례이다.
- 문자열 메시지로 에러 생성하기
  1. `errors.New()`
  2. `fmt.Errorf()`



### 함수

- Go에서의 서브루틴, 코드의 덩어리를 추상화 한 것이다.
- Go는 call by value만 지원한다. 받은 변수의 값을 변경하려면 주소값을 받아서 바꾼다.
- 슬라이스를 넘길 때에도 포인터로 넘긴다. 슬라이스 변경시 구조 내의 용량과 길이도 변경해야 하기 때문
- 리턴값의 이름을 미리 명명할 수는 있으나 권장하지 않음

### 가변 인자 매개변수

- 함수 선언

  ```go
  func WriteTo(w io.Writer, lines ...string) (){}
  ```

  함수 내에서 `lines`는 슬라이스로 쓴다. 나열된 값을 받을 수 있음

- 슬라이스를 넘기는 경우

  ```go
  lines := []string{"hello", "world", "golang"}
  WriteTo(w, lines...)
  ```

  그냥 `lines`로 넘기면 슬라이스를 담는 슬라이스로 만들어서 넘기는 것이다.

  `...`를 뒤에 붙여주어 넘겨줘야 한다.

### 일급 시민(first-class citizen)

- 값으로 변수에 담길 수 있고, 다른 함수로 넘기거나 돌려받을 수 있는 것
- 자료구조 내에도 담을 수 있다.
- go에서는 함수도 일급 시민이다.

### 함수 리터럴

- 이름 없이 선언한 함수이다. 익명 함수라고도 부른다. 
- 변수에 담아서 다른 함수에 넘겨주거나, 그대로 실행할 수 있다.
- 함수형 언어의 람다 함수와 같다.

### 고계 함수 (high-order function)

- 함수의 함수이다. 즉 함수를 넘기고 받는 함수.

  ```go
  func ReadFrom(r io.Reader, f func(line string)) error{}
  // 함수를 인자로 받음. 함수 내에서 f() 함수를 호출하여 실행시킬 수 있다.
  func NewIntGenerator() func() int{...}
  // 함수를 반환함. 보통 함수 리터럴을 만들어서 반환하는 듯
  ```

### 클로저

- 외부에서 선언한 변수를 함수 리터럴 내에서 마음대로 접근할 수 있는 코드를 의미한다.

- 이 함수 리터럴을 고계 함수를 통해서 넘어간 후에도 해당 변수에 여전히 접근할 수 있다.

- 생성기를 만드는 데에 사용될 수 있다. 

  변화시킬 변수를 선언하고, 해당 변수를 사용하는 함수 리터럴을 반환한다.

- 생성기를 여러 번 만들면 각 생성기 내의 변수는 서로 관련이 없다.

### 명명된 자료형/함수형

- `type` 키워드를 사용해서 별칭 지정
- 컴파일 타임에 자료형을 검사해서 버그 예방하는데에 좋다.
- 명명된 자료형끼리는 실제로는 같은 내장 타입이더라도 서로 호환되지 않는다.
- 대입하는 경우 한쪽은 명명된 자료형이고, 한쪽은 명명되지 않은 자료형인 경우 호환이 가능하다.
- 함수를 명명해서 클로저 형태로 쓰면 인자 고정을 해주어 호출 부분을 단순화 시킬 수 있다.

### 패턴의 추상화

- 변수 - 어떤 값이나 연산 결과에 이름을 붙이고 추상화

  함수 - 코드를 값의 입출력으로 추상화

  고계 함수 - 

- 연산을 과도하게 추상화시키면 코드가 읽기 어려워지므로, 자주 반복되는 패턴이 있는 경우 등에만 적용하자

### 메서드

- 함수에 리시버를 붙인 형태
- 자료형에 이름을 붙이면 메서드를 정의할 수 있다. 이렇게 하면 자료형을 추상화 하는 효과도 있다.
- 자료형이 포인터형을 리시버로 받으면 포인터 리시버이다.

### 공개 및 비공개

- 함수 및 자료형의 이름이 대문자로 시작하면 다른 모듈에서 호출이 가능하다. 
- 하나의 모듈은 여러 개의 파일로 구성될 수 있다. 파일이 달라도 같은 모듈이라면 소문자로 정의한 함수/변수/상수 등을 사용할 수 있다.
- 공개된 타입들은 주석을 달자.

### 패키지 소개

1. `time`
   - `time.Sleep`, `time.AfterFunc(시간, 콜백함수)`, `{time.AfterFunc()의 반환값}.Stop()`
2. `path/filepath`
   - 파일 이름 경로를 다룬다.
   - 디렉터리 경로 아래에서 일들을 수행할 수 있다.

<br>

## Chapter 5

- 구조체는 필드들의 집합이다.

- 인터페이스는 메서드의 집합이다. 구현은 없고, 메서드의 형태만 존재한다.

  인터페이스의 메서드를 모두 구현하기만 하면 해당 인터페이스를 구현하는 것으로 취급된다.

- 빈 인터페이스는 와일드카드로, 어떤 자료형이든 받을 수 있다.

### 구조체

- 구조체를 선언하여 변수를 만들 때 필드를 넣지 않으면 기본 값으로 설정된다.

- `bool`을 쓰는 곳에는 상수로 선언하여 `enum`과 같이 쓰자.

- 상수를 모아서 선언할 때 첫 필드를 `iota` 놓으면 다름 필드들까지 알아서 increment한 값으로 지정된다.

- 구조체에 입력/출력 필드를 만들어서 테이블 기반 테스팅을 하는 데 사용할 수 있다.

- **구조체 내장**

  구조체 내부에 구조체를 선언할 때 필드명을 생략하여 쓰는 경우에 내장된다.

  내장된 구조체의 필드를 바로 접근할 수 있다.
  
  원래 구조체를 고치지 않고 원하는 필드만 추가/제외하여 직렬화 할 수 있다. 

### 직렬화

- 직렬화를 사용하는 곳

  1. 보조 기억장치에 저장 및 불러오기
  2. 네트워크를 통해서 다른 사람에게 메시지 전송
  3. 네트워크를 통해서 다른 기계에게 작업 지시 (RPC, Remote Procedure Call)

### JSON을 이용한 직렬화

- `json.Marshal({struct})`

  1. 구조체

     대문자로 시작하는 필드만 직렬화한다.

     직렬화를 원하지 않는 필드는 소문자로 시작하도록 한다.

  2. 맵

     `map[string]interface{}`로 넣으면 값에 문자열과 숫자 등을 모두 넣을 수 있다.

- Json 태그

  이름과 옵션을 붙일 수 있다.

  `json:"{field name},option"`
  
  option으로는 `-`, `omitempty`, `string` 등이 있다.
  
- `int64`를 id로 사용하는 경우 꼭 `string`으로 바꾸어서 전송하도록 하자. 그렇지 않으면 아래쪽 자리 수가 소실된다.

  정확한 값의 전달이 필요하거나, 값의 열화가 일어나면 안되는 경우(시간값)에 string으로 바꿔서 보내는 것이 좋다.

- 직렬화/역직렬화를 명명된 자료형에 대해서 직접 작성해줄 수 있다.

  이 경우 작업량이 너무 많다면 `go generate`를 사용해서 코드를 생성할 수 있다.

### Gob를 이용한 직렬화

- go 에서만 읽고 쓸 수 있는 형태이다.

  주고 받는 코드가 모두 go 인 경우 사용하면 좋다.

- `gob.NewEncoder(), gob.NewDecoder()`로 인코더와 디코더를 생성해서 사용한다. 이 때 각각 `io.Writer, io.Reader`를 넘겨준다. `bytes.Buffer`를 넘길 수도 있다.

### 인터페이스

- 메서드들을 묶어 놓은 것이다.
- 메서드 이름에 `er` 을 붙혀서 인터페이스 명을 정하는 경우가 많다.
- 구조체 내장처럼 여러 인터페이스를 합칠 수 있다.

### 정렬

- go의 `sort.Sort`는 비교정렬이며, 퀵소트 알고리즘을 쓰는 unstable sort이다. 피봇 3개를 골라서 가운데 값을 고르는 중위법을 사용하여 최악의 경우를 피한다.

  7개 이하의 값에 대해서는 삽입 정렬이 가장 효율적이므로 이걸 쓴다. 

  너무 깊이가 깊어지면 힙 정렬을 이용한다.

- 정렬 인터페이스가 있으므로, 직접 만든 자료형도 `Less()` 비교 메소드를 넣어주면 정렬할 수 있다.

### 힙

- 가장 작은/큰 값을 O(logN)으로 꺼낼 수 있는 자료구조다. 

- 정렬은 O(NlogN)이 걸린다. 

  퀵소트보다 느리고 메모리를 여기저기 임의로 액세스 해야 하므로 캐시를 효율적으로 사용할 수 없다. 

  다만, 무작위 퀵소트나 머지소트는 정렬이 모두 끝난 후에 정렬된 자료를 사용할 수 있지만, 힙 정렬은 선택 정렬의 일종이기 때문에 정렬이 끝나지 않은 상황에서도 좀 더 일찍 첫 자료를 받아볼 수 있다. 

  정렬된 순서로 자료를 받는 중간에 어떤 조건을 만족하는 상황에서 더 이상 자료가 필요없어지는 경우 유용하게 사용할 수 있다.

  예를 들어 생산자와 소비자가 있고 소비자는 순서가 있는 값을 차례로 소비해야 하는 경우 효율적이다. (우선순위 큐)

  정렬된 여러 자료를 하나로 합칠 때에도 효율적이다.

- 인터페이스에는 세 가지가 있다. `sort.Interface, Push(x), POP()`

### 테스트할 때 외부 의존성 줄이기

- 함수의 인자를 `io.Writer`로 해놓으면 실제 구현에서는 파일을, 테스트에서는 `bytes.Buffer`를 사용해서 넘길 수 있다. 

- 닫는 연산이 필요하면 `io.WriteCloser`, 순차적으로 쓰는 경우가 아니라면 `io.WriteSeeker, io.WriterAt`을 사용할 수 있다.

- 파일 시스템에 접근하는 경우에는 파일 시스템 인터페이스를 만들어서 이용하면 유연성이 높아진다.

  구조체를 사용해서 테스트 용도의 가짜 파일 시스템을 만들어 이용할 수 있다.

### 빈 인터페이스와 형 단언

- `interface{}` 를 원래 타입으로 바꾸기 위해서는 형 변환이 아닌 형 단언(type assertion)을 해야 한다. 이는 자료형이 맞는지 런타임에 검사한다.

- `.({typename})`를 붙힌다.

  ```go
  popped := heap.Pop(&apple) // interface{}로 반환
  s := popped.(string) // 형 단언
  ```

- 자료형이 맞지 않으면 패닉이 일어나므로 조심한다. 

  이 경우 두 개의 반환을 받으면, 두 번째 값으로 검사할 수 있으며 패닉이 방지된다.

- `.(type)`을 붙히면 `switch`문에서 자료형에 따라 다른 구현을 할 수 있다.

<br>

<br>

## Chapter 6

- http 서버 시작하기

  ```go
  http.ListenAndServe(":8080", nil)
  ```

  2번째 인자는 handler이다. 보통 `nil`을 넣는데, 이 경우에는 `DefaultServerMux`가 들어가게 된다.

  `Handle`, `HandleFunc`함수로 핸들러를 정하면 이게 `DefaultServeMux`로 추가가 된다.

### Data Access Object

- 데이터베이스에 필요한 연산을 추상 인터페이스로 만들어 사용하는 것

- 데이터베이스와 비즈니스 로직 구분 가능

- 단점도 있다. 

- 데이터 접근 변수를 생성시 인터페이스를 반환하면 유연하게 처리할 수 있다.

- 에러를 `json` 형태로 반환하기 위해서는 `MarshalJson`함수를 메소드로 구현해야 한다.

- `int64`는 자바스크립트에서 53비트까지만 정확히 읽을 수 있다. 정수형이 따로 없고 실수형으로 처리되기 때문이다.

  따라서 `int64` 의 경우에는 무조건 `string` 태그를 달고 변환하도록 하자.

### 코드 리팩토링

1. 통일성 있게 파일 나누기

2. 라우터 사용하기

   `gorilla/mux` 라이브러리 사용 

### HTTP 파일 서버

`http.FileServer()`

- 정적인 파일들을 디렉터리로 구조화해서 보관하고, 특정 경로로 요청이 들어오면 전송

### 몽고디비 - `mgo` 라이브러리 

- 기본적으로 12바이트짜리  ID를 생성한다.

### 에러 처리

- `error`는 표현이 정해진 자료형이 아니고 인터페이스 자료형이다.

  `Error()`라고 하는 string 주는 메소드만 있으면 된다.

- 함수를 이용해서 에러처리 단순화하기

  ```go
  func Must(err error){
  	if err != nil{
  		panic(err)
  	}
  }
  func Must(val int64, err error) int64{
  	if err != nil{
  		panic(err)
  	}
    return val
  }
  ```

- 반복된 에러 처리 피하기

  1. 에러에 추가적인 정보를 실어서 보내기
  2. 해당 정보의 처리 방법을 에러의 자료형에 맞춰서 준비하기

- 웹 애플리케시션 작성할 때에는 에러 구현을 정리해 두는 것이 좋다.

  에러 방생 시 에러 메세지와 적절한  HTTP 에러 코드 번호를 함께 돌려주는 것이 좋다.

  `ResponseWriter.WriteHeader({errorCode})`

- 에러 처리를 한 곳에서 몰아서 할 수 있다.

### Panic, recover

- 패닉이 발생하면 호출 스택을 타고 역순으로 올라가서 프로그램이 종료된다.

  `defer`함수도 이때 함께 호출해서 처리한다.

- `recover`를 사용하면 스택을 타고 올라가는 과정에서 더 이상 패닉이 전파되지 않도록 한다.

  `defer` 안에서만 효력이 있다.

  ```go
  func f() int{
  	defer func(){
  		if r := recover(); r != nil{
  			fmt.Println("Recovered in f", r)
  		} // r == nil이라면 패닉이 발생하지 않은 것
  	}()
  	panic_func()
  	return 100
  }
  ```

  패닉이 발생하면 함수 `f()`의 반환값은 기본값인 0이 된다. 

  만약 패닉 발생 시 이 값에 변화를 주고 싶다면 반환값에 이름을 미리 붙혀주고, `defer` 함수 내에서 할당하면 된다.

### 질문

210p

```go
func NewMemoryDataAccess() DataAccess{ // 리턴은 주소인데 여기서 DataAccess에 왜 *를 안붙히지
	return &MemoryDataAccess{
		tasks: map[ID]task.Task{},
		nextID: ID(1),
	}
}
```

Http handler에서 `http.ResponseWriter`는 왜 포인터 형식으로 안받는걸까
반환하지 않고 함수 스택내에서 바로 Response를 전송하는건가?

```go
func apiHandler(w http.ResponseWriter, r *http.Request){
...
}
```





## Chapter 7

## 7.1 고루틴

- 스레드와 비슷하지만 다른 것

  별개의 흐름을 만들어준다.

- 이 때 별개의 흐름은 논리적으로 다른 흐름을 의미한다.

### 병렬성과 병행성

- 병렬성(Parallelism) - 물리적으로 별개의 흐름

  동시성, 병행성(Concurrency) - 논리적으로 별개의 흐름

- 동시성이 있는 두 개의 루틴은 서로 의존 관계가 없다.

  동시성이 있어야 병렬성을 가질 수 있다.

- 고루틴은 순서대로 실행될 필요가 없다.

  장갑끼기 & 양말신기 vs 양말신기 & 신발신기

- 고루틴마다 스레드를 모두 할당하지 않으므로 스레드 생성처럼 생성 시 cost가 크지 않다.

  고루틴의 개수가 많아도 괜찮다.

### 고루틴 기다리기

```go
func main(){
  go func(){
    fmt.Println("In goroutine")
  }()
  fmt.Println("In main routine")
}
```

- 고루틴이 수행되기 전에 메인 루틴이 먼저 끝나버릴 수 있다.
- `sync.WaitGroup`을 이용해서 고루틴을 제어할 수 있다.

```go
var wg sync.WaitGroup
wg.Add(len(urls))
for _, urls := range urls{
  // 혹은 여기에 wg.Add(1)로 카운팅할 수 있다
  go func(url string){
	    defer wg.Done()
			download(url)
    }
  }(url)
}
wg.Wait()
// 다운받은 파일로 작업하기
```

- `wg.Add(1)`은 고루틴 밖에 넣어줘야 한다.

  카운팅을 올리기 전에 `wg.Wait()`을 통과할 가능성이 있기 때문이다.

- 고루틴에서 작업한 결과를 받을 때, 변수의 포인터를 이용할 수 있다.

  예를 들면 배열에서 작은 수를 찾을 때 각 고루틴에 배열의 주소를 넘겨주어 범위를 나누어 찾을 수 있다.

## 7.2 채널

- 메모리나 파일 시스템을 이용해서 고루틴간에 데이터를 공유할 수도 있지만, 그렇지 못한 경우도 있다.

- 파이프와 같은 형태의 채널을 사용하여 고루틴 간에 통신을 할 수 있다.

- 양방향, 단방향 채널이 있다.

  양방향 채널을 단방향 채널로 바꿀 수 있다.

  ```go
  c1 := make(chan int)
  var c2 chan int = c1
  var c3 <-chan int = c1 // 자료를 뺼 수만 있음 
  var c4 chan<- int = c1 // 자료를 넣을 수만 있음
  ```

- 채널을 사용할 때의 장점

  1. 생성하는 쪽에서는 상태 저장 방법을 복잡하게 고민할 필요가 없다.
  2. 받는 쪽에서는 for의 range를 이용할 수 있다.
  3. 채널 버퍼를 사용하면 멀티 코어를 활용하거나 입출력 성능상의 장점을 이용할 수 있다.

### 일대일 단방향 소통

- 한쪽에서는 보내고 다른쪽에서는 받기만 하는 패턴

  ```go
  func Example_simepleChannel(){
  	c := make(chan int)
  	go func(){
  		c <- 1
  		c <- 2
  		c <- 3
  	}()
  	fmt.Println(<-c)
  	fmt.Println(<-c)
  	fmt.Println(<-c)
  }
  ```

  이 경우 주고 받는 코드가 서로 실행되어야 서로 전달이 이루어진다.

  만약 어느 한쪽이 준비되어 있지 않다면 context switching이 일어난다.

- 주고 받는 부분이 서로 데이터의 개수를 알지 못한 상태에서 동작하도록 하자.

  ```go
  func Example_simepleChannel(){
  	c := make(chan int)
  	go func(){
  		c <- 1
  		c <- 2
  		c <- 3
      close(c)
  	}()
  	for num := range c{
  		fmt.Println(num)	
  	}
  }
  ```

  보내는 쪽에서는 channel을 닫아주었고, 받는 쪽에서는  for range를 이용해서 받는다.

- 고루틴의 반환값이 수신채널이고, 고루틴 내부에서 defer로 채널을 닫도록 해주면 좀 더 깔끔하게 작성할 수 있다.

### 생성기 패턴

- 고루틴을 통해 흐름을 분기하면서, 받기 전용 채널을 반환하는 함수이다.

  ```go
  func Fibonacci(max int         ) <-chan int{
    c := make(chan int)
    go func(){
      defer close(c)
      a, b := 0, 1
      for a <= max{
        c <- a
        a, b = b, a+b
      }
    }()
    return c
  }
  ```

### 버퍼 있는 채널

- 원래는 받는 쪽도 준비가 되어 있어야 채널에 보낼 수 있다.

  보내는 쪽과 받는 쪽의 코드의 수행 속도가 비슷하지 않을 떄 좋다. 고루틴 간에 어느 정도 격차가 생겨도 계속 동작할 수 있으므로 성능을 향상시킬 수 있다.

- 받는 쪽에서 준비하기 전에 미리 보내놓기

  ```go
  c := make(chan int, 10) // 	버퍼의 크기가 10
  ```

- 동시성이 좋지만, 코드가 복잡해질 수 있다. 

  따라서 버퍼 없는 채널을 이용하되, 필요에 따라 성능 향상을 위해서 버퍼 값을 조절하자.

### 닫힌 채널

- 채널이 닫히는 경우 `for range`가 종료된다.

- 다른 경우에는?

  1. 채널에서 두 값을 받으면, 두번째 값에 열려있는지 여부가 들어온다.

     닫힌 경우 첫번째 값에는 type의 기본값이 들어온다.

  2. 채널이 닫히면 기다리지 않는다.

- 주의

  이미 닫은 채널을 닫으면 패닉이 일어난다.

### 참고

- 굳이 영향이 없더라도 사용이 완료된 채널을 닫는 것은 좋은 습관이다.

  1. 메모리 누수를 방지

     채널이 닫히지 않아서 고루틴이 끝나지 않고 기다리면서 계속 메모리에 상주한다.

     반복적으로 고루틴을 생성하는 경우 계속 누수되는 메모리 증가

  2. Broadcast 효과

     해당 채널을 기다리는 모든 고루틴에게 알려주는 효과가 있다.

     특수한 값으로 종료 신호를 보내는 경우 값을 고루틴 수만큼 넣어줘야 한다.

- for문 안에 있는 변수를 고루틴에서 사용할 때에는 꼭 파라미터로 넣어서 고정해주자. 

  변수 참조하는 시점(고루틴 수행 시점)이 의도한 것과 달라질 수 있다.

  ```go
  for i:=0; i<N; i++{
    go func(i int){
      fmt.Println(i) 
    }(i)
  }
  ```

## 7.3 동시성 패턴

### 파이프라인 패턴

- 생성기 패턴의 일종

- 분업하는 느낌

- 한 단계의 출력이 다음 단계의 입력으로 이어지는 구조

- 받기 전용 채널에서 나온 것을 다른 파이프라인의 입력으로 넘겨줄 수 있다

  -> 출력을 입력으로 연결

- 주의 : 채널을 닫는 것은 보내는 쪽이다.

### 채널 공유로 팬아웃하기

- 쓰면 좋은 경우

  `생산 ====파이프라인==== 소비`에서 생산은 빨리 되지만 소비되는 속도가 느린 경우

- 생산 : 소비 = 1 : N

  N개의 소비자는 모두 같은 채널을 사용한다.

  채널이 닫히면 소비자가 몇명이든 상관 없이 인지한다.

![ink-image](https://aidanbae.github.io/code/golang-design/fan/ink-image.png)

### 팬인하기

- 팬아웃에서 분산된 작업을 합치는 패턴이다.

  `N ====파이프라인==== 1`의 경우이다.

  N에서는 생산을 1에서는 소비를 한다.

- 생산을 다 마치지 않았는데 채널이 닫히면 안된다. (패닉 발생)

  생산을 다 끝낸 후 채널을 닫아야 한다.

- **채널을 닫기 위한** 고루틴을 만들자.

  이 고루틴은 생산 고루틴이 다 종료된 후 채널을 닫는다. 

```go
func FanIn(ins ...<-chan int) <-chan int{
	out := make(chan int)
  
	var wg sync.WaitGroup
  wg.Add(len(ins))
  
  for _, in := range ins{
    go func(in <-chan int){
      defer wg.Done()
      for num := range in{
        out <- num
      }
    }(in) // in을 꼭 넘겨줘야 한다.파라미터를 고정하는 것
  }
  
  go func(){
    wg.Wait()
    close(out)
  }()
	
	return out // 깔때기 채널
}
```

### 분산 처리

- 팬인과 팬아웃을 합친 형태

```go
// type IntPipe func(<-chan int) <-chan int

// IntPipe ===> Distribute ===> IntPipe
func Distribute(p IntPipe, n int) IntPipe{
  return func(in <-chan int) <-chan int{
    cs := make([]<-chan int, n)
    for i:=0;i<n;i++{
      cs[i] = p(in)
    }
    return FanIn(cs...)
  }
}
```

```go
out := Chain(Cut, Distribute(Chain(Draw, Paint, Decorate), 10), Box))(in)
```

![aa](https://user-images.githubusercontent.com/41130448/125896250-752f20c6-31eb-490f-b16a-26f60917fccd.png)

```
out := Chain(Cut, Distribute(Draw, 6), Distrubite(Paint, 10), Distribute(Decorate, 3), Box)(in)
```

![b](https://user-images.githubusercontent.com/41130448/125896296-4baa2acf-9c7f-4715-b1a5-e76c5ad8a3fa.png)

### select

- 여러 채널과 동시에 통신이 가능하다.

- `switch`와 비슷하게 생겼다. 각 case에 채널 입출력이 있다.

- 모든 case가 계산된다. 

  case에 함수 호출이 있으면 해당 함수의 반환값을 받는 채널이 준비되어 있지 않더라도 항상 호출된다. 

- 입출력 가능한 채널이 있어, 해당 case가 선택되면 이 case의 코드만 수행된다.

- default가 있으면 모든 case에 있는 채널에서 입출력이 불가능할 때 코드가 수행된다.

  만약 채널이 하나라도 입출력 가능 상태라면(모든 채널이 닫힌 게 아니면) 계속 기다린다.

```
select{
	case n:= <-c1:
	case n:= <-c2:
	case c3<-f():
	default:
}
```

- select로 팬인하기

```
select{
	case n:= <-c1: out <-n
	case n:= <-c2: out <-n
 	case n:= <-c3: out <-n
}
```

- 채널이 닫히면 타입 기본값이 들어올 수 있으므로, 두번째 반환값을 가지고와서 확인 후 넣는다. 

  채널이 닫혔을 때 채널 포인터를 이용해서  nil로 만들어주면 전송/수신이 모두 block된다.

- select에 default를 넣어주면, 채널에서 값이 준비되지 않은 경우 select를 빠져 나온다.

- 일정 시간만 채널 기다리기

  `<-time.After(시간)`은 넣어준 시간이 지난 후 채널로 전달해준다. 이 채널에서 값이 나오면 함수를 끝내도록 하면 된다.

### 파이프라인 중단하기

- 파이프라인의 받는 쪽에서 그만 받고 싶을 떄

  받는 쪽에서 그냥 받기 반복문을 멈추고 빠져나오면 고루틴이 소멸되지 않는다. 채널이 닫힐 때까지 자료를 빼주어야 한다. 메모리 누수가 발생한다.

  그렇다고 받는 채널을 억지로 닫아버리면 안된다.

- done 채널을 만들어서 보내는 쪽에서 신호를 감지하는 방법이 있다.

  받는 것을 끝내고 싶을 때 done 채널을 닫으면, 보내는 모든 고루틴에게 broadcast 하는 효과가 있다.

```go
func PlusOne(done <-chan struct{}, int <-chan int) <-chan int{
  out := make(chan int)
  go func(){
    defer close(out)
    for num := range in{
      select{
      case out <- num + 1:
      case <-done: 	// 종료신호 받으면 종료
        return
      }
    }
  }
  return out
}
```

### 컨텍스트 활용하기 (`context.Context`)

- 파이프라인을 중단하는 다른 방법

- 복잡한 상황에 쓰면 좋다.

  종료 신호 뿐만 아니라 다른 정보가 같이 필요한 경우 (사용자의 인증 정보, 요청 마감 등)

- 기본 라이브러리가 아니라서 설치해줘야 한다.

  ```shell
  $ go get golang.org/x/net/context
  ```

- context는 계층 구조로 되어 있다. 가장 상위에는 `context.Background()`가 있다. 

  이 컨텍스트 하위에 트리 구조로 컨텍스트를 추가할 수 있다.

  상위 컨텍스트가 취소되면 그 하위에 있는 트리 컨텍스트들도 취소된다. 

- 채널에 값을 보내는 함수에 context를 넣어준다.

  받는 쪽에서 그만 받고 싶을 때 context에 Done 신호를 보내준다.

  ```go
  func PlusOne(ctx context.Context, in <-chan int)<-chan int{
    ...
    go func(){
      ... //보내는 쪽
      select{
      ...
      case <-ctx.Done():
        return
      }
    }
    ...
  }
  
  func main(){
    // 받는 쪽
    ...
    ctx, cancel := context.WithCancel(context.Background())
    // 새로 생성된 컨텍스트, 컨텍스트 취소하는 함수 := 상위 background() 컨텍스트 하위에 취소기능 컨텍스트 붙임
    ...
    if condition{
      cancel()
    }
  }
  ```

- `.WithCancel()`  이외에도 `.WithDeadline()`,  `.WithTimeout()`, `.WithValue()` 등을 활용할 수 있다.

- 컨텍스트는 관례상 함수의 첫번째 인자로 넣는다.

### 요청과 응답 짝짓기

- 분산 처리를 하는 경우 어떤 결과물이 어떤 순서로 나올지 알 수 없다.

  하지만 문제는, 알아야 될 필요가 있을 때다.

- 이 경우 데이터를 채널에 넘길 때 고유한 요청 ID 번호를 함께 넘기는 것이다.

  이 때 요청에 대한 응답을 받고 싶다면 채널을 요청메시지에 포함해서 넘길 수 있다.

```go
type Request struct{
	Num int
	Resp chan Response
}
type Response struct{
	Num int
	WorkerID int
}

// worker는
// request 채널 받아온다.
// request 채널에서 item을 꺼내면 그 item에 response 채널이 있다.
// 그 채널에 response를 넣어준다.
```

### 동적으로 고루틴 이어붙히기

```go
func Primes(ctx context.Context) <-chan int{
	out := make(chan int)
  go func(){
    defer close(out)
    c := Range(ctx, 2, 1)
    for {
      select{
      case := <-c: // 1
            c = FilterMultiple(i)(ctx, c)
            select{
            case out <- i: // 1-1
            case <-ctx.Done(): // 1-2
              return
            }
      case <-ctx.Done(): // 2
        		return
      }
    }
  }()
  return out
}
```



### 주의점

- 보내는 쪽에서 채널을 닫아줘야 한다.

  채널을 닫는 코드는  defer을 사용하는 것이 좋다. 보내는 중간에 return하는 경우도 있기 때문이다.

- 받는 쪽이 끝날 때까지 기다리는 것이 안정적이다. 받는 것이 끝나기 전에 종료를 하는 것에 주의한다.

  ```go
  c := make(chan int)
  done := make(chan bool)
  go func(){
   // c로 데이터 생산
    done <- true
  }
  go func(){
    // c에서 데이터 받아서 소비
  }
  <-done
  ```

- 특별한 이유가 없다면 range를 사용해서 채널 데이터를 받는 것이 좋다.

- 루틴이 끝나고/기다리는 신호는 `sync.WaitGroup`을 사용하는 것이 좋다.

- 끝났음을 때  `done` 채널을 이용하기보다는 자료를 보내는 채널을 닫는 게 낫다. 

  따로 채널을 사용하는 경우 받는 쪽에서 그만 보내달라는 채널로 쓸 수 있다.

## 7.4 경쟁 상태

- 경쟁 상태는 공유 자원에 둘 이상의 프로세스가 동시에 접근하여 잘못된 결과가 나올 수 있는 상태이다.
- go에서 경쟁 상태 문제를 해결할 수 있는 방법에는 다음과 같은 것들이 있다.
  1. 채널 사용하기
  2. `sync` 라이브러리를 활용하기
  3. `atomic` 라이브러리를 활용하기

### 동시성 디버그

- go 커맨드를 쓸 때 `-race` 옵션을 주면 경쟁 상태를 탐지할 수 있다.

- 현재 동작하는 고루틴 수는 `runtime.NumGoroutine()`을 통해 확인할 수 있다.

  만약 고루틴 개수가 점점 늘어난다면, 어디선가 고루틴이 막혀있을 가능성이 높다.

  적당한 시점에서 `panic`을 발생시키면 고루틴의 스택을 추적할 수 있다.

- 현재 사용 가능한 CPU 수와, CPU 수를 통재하기 위해 `runtime.NumCPU()`, `runtime.GOMAXPROCS()`를 사용할 수 있다.

### `atomic`과 `sync.WaitGroup`

- 한 줄의 코드라도 원자성을 갖지는 않는다.

  예) `cnt--`, `cnt > 0`

  `cnt`에 두 개 이상의 고루틴이 동시에 접근한다면 경쟁 상태가 생긴다.

- 경쟁 상태를 해결하기

  1. `atomic`

     `cnt--` -> `atomic.AddInt64(&cnt, -1)`

     `cnt > 0` -> `atomic.LoadInt64(&cnt) > 0`

  2. 채널을 사용하기

  3. `WaitGroup`

     채널을 이용해서 고루틴이 끝나기를 기다릴 수 있지만, waitGroup을 써주는 것이 더 가독성있다.

### `sync.One`

- 분산처리를 할 때 초기화가 필요한 경우 사용하면 좋다. 

  초기화는 한번만 하고, 초기화가 완료된 후 고루틴이 수행되는 경우이다.

```go
func main(){
	var once sync.Once
  var wg sync.WaitGroup
  for i:=0;i<3;i++{ 
    wg.Add(1)
    go func(i int){
      defer wg.Done()
      once.Do(func(){
        // INITIALIZE (1번만 실행해야 함)
      })
      fmt.Println("Gouroutine:", i)
    }(i)
  }
  wg.Wait()
}
```

- done 채널을 만들고 이를 이용해서 한번만 초기화 할 수도 있다.

### Mutex와 RWMutex

- 상호 배타 잠금 기능을 가진 객체이다.

- 접근 자원 포인터와 뮤텍스 포인터를 묶은 구조체를 사용하면 좋다.

  ```go
  type Accessor struct{
  	R *Resource
  	L *sync.Mutex
  }
  func (acc *Accessor) Use(){
    acc.L.Lock()
    // Use Resource
    acc.L.Unlock()
  }
  ```

- `RWMutex`는 읽기와 쓰기를 다르게 취급하는 뮤텍스이다.

  읽기는 동시에 접근을 허용하고 쓰기를 하는 경우 배타성을 갖는다.

  go의 맵은 스레드 세이프 하지 않으므로 여기에 사용하기 좋다. 읽기만 한다면 동시에 접근 가능하다.

  ```go
  type ConcurrentMap struct{
    M map[string]string
  	L *sync.RWMutex  
  }
  
  func (m ConcurrentMap) Get(key string) string{
    m.L.RLock() // 읽기 락
    defer m.L.RUnlock()
    return m.M[key]
  }
  ```

## 7.5 문맥 전환

- 여러 프로세스/스레드가 동시에 동작할 때, 기존 작업을 보관하고 다른 작업을 시작하는 과정이 필요하다. 이 때 과정을 context switch라고 한다.

  context switch 과정에서는 비용이 발생하므로 과도하게 이루어지면 좋지 않다.

- 고루틴은 스레드보다 cost가 적다. 하나의 스레드에 여러 개의 고루틴이 대응되며, switch를 적게 하도록 코드가 생성된다.

- Go 컴파일러에서는 이런 경우 context switch가 일어날 수 있다.

  1. 파일이나 네트워크 연산처럼 시간이 오래 걸리는 입출력 연산이 있을 때

     Go의 입출력은 blocking으로 연산이 완료될 때까지 기다려야 한다. 따라서 전환이 일어난다.

  2. 채널에 보내거나 받을 때

     채널에 보내는 코드가 수행된 후, 채널에서 데이터를 받는 부분으로 context switch가 일어나면 자연스럽게 연결되어 수행된다.

     컴파일 시간에 이런 것을 예측하면, 변수들을 레지스터에 할당하는 전략을 잘 세울 수 있어서 성능 향상에 도움이 된다.

  3. 고루틴이 생성될 때

  4. GC 사이클이 지난 뒤

  5. `time.Sleep(0)`과 같은 코드로 강제로 시키는 경우

     바쁜 연산을 반복하는 코드가 있을 때 다른 고루틴도 처리되기 위해 사용할 수 있다.



## 정리

- 병렬성은 물리적으로 동시에 수행되는 성질이며, 병행성은 논리적으로 동시에 실행되는 성질이다.
- 고루틴은 스레드보다 가볍고, 여러 고루틴이 하나의 스레드에 할당되므로 많이 생성해도 부담이 적다.
- 다른 고루틴이 종료되기를 기다릴 때 `sync.waitGroup`을 사용할 수 있다.
- 채널을 이용해서 고루틴끼리 통신할 수 있다.
- 채널에 버퍼를 두어서 주고 받는 고루틴이 서로 동기화하지 않아도 동작하게 할 수 있다.
- 고루틴과 채널을 이용해서 생성기 패턴, 파이프라인 패턴을 구현할 수 있다.
- 채널을 닫는 것은 이 채널에 대해 대기하는 모든 고루틴에 Broadcast효과를 줄 수 있다.
- select를 이용해서 여러 개의 채널을 동시에 다룰 수 있다. 시간 제한을 두어서 채널을 받을 수도 있다.
- 받는 쪽에서 종료를 원할 때, done 채널이나  context.Context를 이용할 수 있다.
- 경쟁 상태 발생 시 공유 메모리 보다는 채널이나  atomic, sync 패키지를 활용하여 해결한다.



