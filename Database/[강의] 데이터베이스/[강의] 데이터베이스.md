# 데이터베이스

[KOCW 데이터베이스 강의](http://www.kocw.net/home/search/kemView.do?kemId=1064626)

- [x] 1차시 관계 대수와 SQL (21/06/01)
- [x] 2차시 관계 대수와 SQL (21/06/01)
- [x] 3차시 관계 대수와 SQL (21/06/01)
- [x] 3차시 관계 대수와 SQL 데이터베이스 설계와 ER 모델 (21/06/04)
- [x] 4차시 데이터베이스 설계와 ER 모델 (21/06/04)
- [x] 5차시 데이터베이스 설계와 ER 모델 (21/06/05)
- [x] 6차시 물리적 데이터베이스 설계 (21/06/05)
- [x] 7차시 물리적 데이터베이스 설계 (21/06/05)
- [x] 7차시 물리적 데이터베이스 설계, 릴레이션 정규화 (21/06/08)
- [x] 8차시 릴레이션 정규화 (21/06/08)
- [x] 9차시 릴레이션 정규화, 뷰와 시스템 카탈로그 (21/06/08, 09)
- [x] 10차시 뷰와 시스템 카탈로그 (21/06/09)
- [x] 11차시 트랜잭션 (21/06/09)
- [ ] 12차시 트랜잭션 (21/07/04)
- [ ] 13차시 데이터베이스의 저장과 접근 : 해싱 빅테이터 관리 서론
- [ ] 14차시 빅테이터 관리 서론
- [ ] 15차시 NoSQL Database Patterns
- [ ] 15차시 NoSQL Database Patterns

<br>

### 공부 가능한 사이트 / 소스

[SqlZoo](https://sqlzoo.net/)
[sql-ex](https://sql-ex.ru/)
[공공데이터포털](https://www.data.go.kr/)

<br>

## 목차

### [관계 대수와 SQL](#관계 대수와 SQL)

[관계 대수](# 관계 대수)
[SQL](# SQL)
[리눅스와 MySQL 접속 방법](#리눅스와 MySQL 접속 방법)
[데이터베이스 설계](#데이터베이스 설계)

### [ER 모델](#ER 모델)

[엔티티](#엔티티)
[약한 엔티티 타입](#약한 엔티티 타입)
[애트리뷰트](#애트리뷰트)
[관계와 관계 타입](#관계와 관계 타입)
[논리적 설계](#논리적 설계)

### [물리적 데이터베이스 설계](#물리적 데이터베이스 설계)

[보조 기억 장치](#보조 기억 장치)
[보조 기억 장치 - 자기 디스크](#보조 기억 장치 - 자기 디스크)
[버퍼 관리와 운영 체제](#버퍼 관리와 운영 체제)
[디스크 상에서 file의 레코드 배치](#디스크 상에서 file의 레코드 배치)
[file structure](#file structure)

<br>



## 트랜잭션

- 아주 중요한 기능. 이 기능이 있기 때문에 비싼 돈을 주고 DBMS를 쓰는 것임
- 동시성 제어와 회복을 다룰 것이다.

### 트랜잭션이 뭐냐 (Transaction)

- 간단하게 말해서는 데이터 어플리케이션

- 대규모 데이터 베이스를 많은 여러 사용자들이 동시에 접근, 서로 같거다 다른 부분에 접근하면서 데이터 베이스를 사용한다.

  1. 동시성 제어 (concurrency control)

     - 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향은 이들을 순차적으로 수행하였을 때 데이터베이스에 미치는 영향과 같도록 보장
     - 다수의 사용자가 DB를 동시에 접근하도록 허용하면서 DB의 일관성을 유지함

     > 통상 정보 시스템의 성능 평가는 1초에 몇 개의 트랜잭션을 처리하는지(TPS)로 한다.
     >
     > 이거에 비해서는 운영체제에서 쓰는 동시성 제어는 간단하다.
     >
     > CPU, 하드의 성능이 좋다고 해서 정보 시스템의 성능이 좋은 것이 아니다. 소프트웨어와 하드웨어가 조화를 이루어야 함
     >
     > 컴퓨터 + 애플리케이션 + 정보 시스템 → 다 묶여서 성능이 측정됨
     >
     > 성능을 평가할 때 데이터가 다 미리 준비되어 있음 이걸로 벤치마킹을 함.

  2. 회복 (recovery)

     - DB 갱신 과정에서 시스템이 고장나도 일관성을 유지함

       > worst case가 발생했을 때 어떻게 자동화 해서 복구해야 하는지
       >
       > 어떤 상황에서도 데이터를 잃어버리면 안됨

- 응용의 예시

  모든 사원의 급여를 6% 인상하는 연산을 수행해야 한다.

  ```sql
  UPDATE EMPLOYEE
  SET SALARY = SALARY * 1.06;
  ```

  - 이 때 사원 전원의 급여가 수정되거나 모두 수정되지 않도록 보장해야 함. (원자성)

  - 310명 수정째에 컴퓨터 시스템이 다운되고 재가동된다면?

  - DBMS가 추가로 정보를 유지하지 않으면 DBMS는 재가동 후에 어디까지 수정했는지 알 수 없음. 심지어 돌리던 질의가 수백 수천개라면? 

    → 이를 위해서 로그를 유지할 필요가 있다.

- 응용의 예시 2 : 송금과 이체

  (송금자의 계좌에서 돈을 빼는 연산 + 수신자의 계좌에 돈을 넣는 연산)으로 이루어짐

  하나만 수행하고 시스템이 다운되는 경우 복구하거나 수행을 다시 제대로 해야 한다.

  두 연산을 하나의 단위(트랜잭션)으로 보아서 원자성을 띠도록 DBMS가 보장해야 함

- 응용의 예시 3 : 비행기 좌석 예약

  트랜잭션 과정에서 좌석 확인 후 꽉 차면 ABORT, 그렇지 않으면 예약 정보를 넣고 COMMIT

  한번 COMMIT이 되어 업데이트 되면 어떤 상황에서도 이 데이터를 보장해야 한다.

- 트랜잭션 덩어리는 하나의 SQL문이라고 가정하고 수행되어야 함

  이거 때문에 가격이 비싸고 개발하기가 어렵다.

- 트랜잭션의 특징 (ACID)

  1. 원자성 (Atomicity)

     - all or nothing. 완전히 실행되거나 아예 안되거나

     - DBMS의 회복 모듈은 시스템이 다운되는 경우에 부분적으로 DB를 갱신한 트랜잭션의 영향을 취소하여 원자성을 보장
     - 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행(REDO)함으로써 트랜잭션의 원자성을 보장 (COMMIT 된 트랜잭션이 제대로 반영 되었는지 확인)

  2. 일관성 (Consistency)

     - 어떤 트랜잭션이 수행되기 전에 DB가 일관된 상태를 가졌다면, 트랜잭션이 수행된 후에 DB는 또 다른 일관된 상태를 가진다.

     - 트랜잭션이 수행되는 도중에서는 일시적으로 일관되지 않은 상태를 가질 수 있다.

       ![image](https://user-images.githubusercontent.com/41130448/121327017-09900e80-c94e-11eb-97f2-9c5869a53830.png)

       중간결과 (temporary, 일시적, 불일치 상태일 수 있음) : 한 계좌에서 송금을 위해 돈을 뺏지만 아직 상대방 계좌에 넣지 않은 상태

  3. 고립성 (Isolation)

     - 한 트랜잭션이 데이터를 갱신하는 동안, 완료 전에는 갱신중인 데이터를 다른 트랜잭션이 접근하면 안됨.

       (데이터를 중심으로 분리해야 하므로 관리하기가 까다롭다.)

     - 다수의 트랜잭션이 동시에 수행되더라도, 그 결과는 어떤 순서에 따라 하나씩 수행한 결과와 같아야 한다.

       > 실제로는 병행해서 수행하지만, 순서대로 수행하는 것과 같은 효과를 갖는다.

     - DBMS의 동시성 제어 모듈이 트랜잭션의 고립성을 보장한다.

     - DBMS는 응용 프로그램의 요구사항에 따라서 다양한 고립 수준을 제공한다. (isolation level)

  4. 지속성 (Durability)

     - 일단 한 트랜잭션이 완료되면 이 갱신 내용은 후에 시스템에 고장이 나더라도 손실되지 않고 DB에 반영되어 있어야 함.
     - DBMS의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장한다. 

  ![image](https://user-images.githubusercontent.com/41130448/121327727-a94d9c80-c94e-11eb-96e0-ed31b3dee6be.png)

- 트랜잭션의 완료와 철회

  1. 완료 (commit)

     - 변경하려는 내용이 DB에 완전히 반영됨
     - SQL 구문 상으로 `COMMIT WORK`
     - DB는 새로운 일관된 상태를 갖는다.

  2. 철회 (abort)

     - 트랜잭션에서 변경하려는 내용이 데이터베이스에 일부만 반영된 경우에는 원자성을 보장하기 위해서 트랜잭션이 갱신한 사항을 트랜잭션이 수행되기 전의 상태로 되돌린다.

       원상복구 ! UNDO ! 옛날 값과 상태를 알아야 한다. 로그에 기록해야 함.

     - SQL 구문 상으로 `ROLLBACK WORK`

     - DB는 불일치 상태를 가질 수 있다.

- 트랜잭션이 성공하지 못하는 원인 (failure의 원인)

  1. 시스템(사이트) 고장

     CPU, 주기억장치, 전원 공급 장치 등이 고장 (서버에서는 얘의 원인 비율이 적다.)

  2. 트랜잭션 고장

     트랜잭션 고장은 트랜잭션이 수행되는 도중에 철회됨

  3. 매체 고장

     디스크 헤드, 콘트롤러 등이 고장나서 보조 기억 장치의 전부나 일부 내용이 지워지는 것

     > 하드디스크 이중화 등으로 대응

  4. 통신 고장

  5. 자연적 재해

  6. 부주의 또는 고의적 고장

<br>

### 동시성 제어

- 대부분의 DBMS는 다수의 사용자가 쓴다.

  동시에 동일한 테이블 접근하기도 한다.

- DBMS 성능을 높이기 위해서 여러 사용자의 질의나 프로그램을 동시에 수행하는 것이 필수적이다.

- 동시성 제어 기법은 여러 사용자들이 동시 수행하는 환경에서 부정확한 결과를 생성할 수 있는 간섭, 충돌이 생기지 않도록 함

  > 특히 같이 읽는건 괜찮은데 동시에 쓰기를 할 때 충돌 발생

- data의 뭘 공유하느냐?

  릴레이션, 튜플 값, 애트리뷰트 ? 이런 공유 레벨이 다양함

- 동시성 제어

  1. 직렬 스케쥴(serial schedule)

     여러 트랜잭션들의 집합을 한번에 한 트랜잭션씩 차례대로 수행함

     어떤 순서든 상관없이 하나씩 처리

  2. 비직렬 스케쥴(non-serial schedule)

     어떤 트랜잭션들을 동시에 수행. 어떤 순서로 하는지 모름

  3. 직렬 가능(serializable)

     비직렬 스케쥴의 결과가 어떤 직렬 스케쥴의 수행 결과과 동등함

  > 이거 잘못하면 스케쥴하다가 시간 다간다
  >
  > 어떤 때에 어떤 트랜잭션이 들어올지 모르고 스케쥴링 하는 시간 자체의 오버헤드 이런 것도 존재한다.
  >
  > → 모든 트랜잭션이 어떤 규칙을 따라서 실행되기만 하면 됨

- 데이터베이스 연산

  디스크 → 주기억장치 (버퍼) → 응용프로그램 내의 변수

  이걸 각각 둘로 쪼갠다.

  1. `Input(X)`

     데이터베이스 항목 X를 포함하고 있는 블록을 주기억 장치의 버퍼로 읽어들임 

  2. `Output(X)`

     데이터베이스 항목 X를 포함하고 있는 블록을 디스크에 기록함

  3. `read_item(X)`

     주기억 장치 버퍼에서 DB 항목 X의 값을 프로그램 변수 X로 복사함

  4. `write_item(X)`

     프로그램 변수 X의 값을 주기억 장치 내의 DB 항목 X에 기록함

- 동시성 제어를 하지 않고 병렬 처리 시 발생할 수 있는 문제

  1. 갱신 손실(lost update)

     수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어 씀으로써 갱신이 무효가 되는 것

     트랜잭션이 잘 업데이트 해 놨는데 교통정리 안되서 다른 트랜잭션이 업데이트해서 이전의 결과가 반영이 안된 것처럼 되버리는 것

     > 열심히 업데이트 했는데 없어짐. Consistent하지 않은 현상

  2. dirty read

     (완료되지 않은 트랜잭션이 갱신한) 데이터를 읽는 것

     완료된 트랜잭션의 데이터를 clean하다고 함. 중간 결과를 갖다 썼는데, 갱신하던 트랜잭션이 롤백하는 경우 또 같이 롤백이 일어나야 함 (cascade, 연쇄 복귀 일어나야 함)

     항상 worst case 생각해야 함. 그 경우 오버헤드가 굉장히 커진다. 커밋한 경우에는 또 롤백이 안된다. 더티 데이터 읽은 경우에는 커밋하지 말고 계속 대기타야 한다. 왜냐면 그 데이터를 제공한 트랜잭션이 롤백하는 경우 같이 롤백해야 하므로. 그러면 병렬성의 의미가 없자나?

  3. unrepeatable read
  
     한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽는 것
  
- 로킹 (locking) 

  - 동시에 수행되는 트랜잭션들의 동시성을 제어하기 위해서 가장 널리 사용되는 기법이다.

    배타적인 리소스에 대한 충돌 방지 가능

  - lock은 DB 내의 각 데이터 항목과 연관된 하나의 변수이다.

    각 트랜잭션이 수행을 시작하여 데이터 항목을 접근할 때마다, 요청한 락에 대한 정보는 락 테이블(lock table) 등에 유지된다.

    트랜잭션이 데이터 항목에 대한 접근을 끝낸 후에 락을 해제한다

  - 독점 락 (X-lock, eXclusive lock)

    트랜잭션에서 갱신을 목적으로 데이터 항목을 접근할 때 요청하는 것

    이 락을 언제 언락하느냐? -> 

  - 공유 락 (S-lock, Shared lock)

    트랜잭션에서 읽을 목적으로 데이터 항목을 접근할 떄 요청하는 것

  - 락을 아무렇게나 쓰면 안된다. 정교한 메커니즘을 갖고 써야한다.

  ![image](https://user-images.githubusercontent.com/41130448/124358926-8a94aa00-dc5d-11eb-8da9-9db9453ff75f.png)

  이 방법만 가지고 있을 때에는 동시성 제어 문제 발생 가능

- 2단계 락 프로토콜 (2-phase locking protocol)

  - 락을 요청/해제하는 것이 2단계로 이루어진다.
  - 락 확장 단계가 지난 후에 락 수축 단계에 들어간다.
  - 일단 락을 한 개라도 해제하면 락 수축 단계에 들어간다. 
  - 한번 걸었으면 내가 사용할 모든 락에 대해 해제 못해. 죄다 락을 걸어. 있는 락을 다 걸었으면 락을 해제할 수 있음. 하나를 해제하면 죄다 해제해야 함

  1. 락 확장 단계 (1단계)

     확장 단계에서는 트랜잭션이 데이터 항목에 대해서 새로운 락을 요청할 수 있지만, 보유하고 있는 락을 하나도 해제할 수 없음.

  2. 락 수축 단계 (2단계)

     수축 단계에서는 보유하고 있던 락을 해제할 수 있지만, 새로운 락을 요청할 수 없음

     락을 조금씩 해제할 수도 있고, 트랜잭션이 완료 시점에 이르렀을 떄 (커밋할 때) 한꺼번에 모든 락을 해제할 수도 있음. 일반적으로는 한꺼번에 해제하는 방식을 사용

  - 락 포인트

    한 트랜잭션에서 필요로 하는 모든 락을 걸어놓은 시점

  ![image](https://user-images.githubusercontent.com/41130448/124359093-5cfc3080-dc5e-11eb-8318-5e61cd15e0ec.png)

  이 중 한꺼번에 하는 방법을 많이 사용한다.

  > 분산 환경에서는 2-phase commit protocol이라는 것도 있다.

- 데드락

  - 2단계 락 프로토콜에서 발생 가능
  - 두 개 이상의 트랜잭션들이 서로 상대방이 보유하고 있는 락을 요청하면서 기다리고 있는 상태
  - 데드록을 방지하는 기법이나, 데드락을 탐지하고 victim을 선정해서 푸는 기법 등을 사용하여 해결한다. 



40:00 부터 보면 됩니다.
